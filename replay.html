<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction — Replay</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script src="game-core.js"></script>
    <script src="engine.js"></script>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION — Replay Viewer (uses game-core.js + engine.js)
    //
    // Supports both round-based and continuous replays.
    // Load via: ?file=replay.json (static file) or /replay/{sessionId} (API)
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // REPLAY STATE
    // =====================================================================
    let replayData = null;
    let replayEvents = [];
    let eventIdx = 0;
    let replayTime = 0;
    let totalDuration = 0;
    let playing = false;
    let speed = 1;
    let lastFrameTime = 0;

    let currentRound = 0;
    let totalRounds = 0;
    let totalScore = 0;
    let replayGameState = 'waiting'; // waiting, playing, resolving, ended
    let isContinuous = false;

    let loading = true;
    let errorMsg = null;

    let uiButtons = [];

    // Game instance for physics — replaced on replay load for continuous mode
    let game = new Game(400, 700, {}, Math.random);

    // =====================================================================
    // RESIZE
    // =====================================================================
    function resize() {
        engineResize(canvas);
        game.W = W;
        game.H = H;
    }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // REPLAY EVENT PROCESSING
    // =====================================================================
    function processEvent(ev) {
        if (ev.type === 'round_start') {
            currentRound = ev.data.round;
            game.setupRound(ev.data.round);
            // Replace generated dots with recorded positions
            game.dots = ev.data.dots.map(d => ({
                x: d.x, y: d.y, vx: d.vx, vy: d.vy,
                active: true, type: d.type || 'standard', bloomTimer: 0,
            }));
            game.totalDots = game.dots.length;
            engineResetVisuals();
            replayGameState = 'playing';
        } else if (ev.type === 'tap') {
            game.tap(ev.data.x, ev.data.y);
            replayGameState = 'resolving';
        } else if (ev.type === 'clear') {
            totalScore += game.score;
            spawnCelebration(`Round ${ev.data.round} Clear!`, 200, 1.4);
        } else if (ev.type === 'fail') {
            spawnCelebration(`Round ${ev.data.round} Failed`, 0, 1.0);
            totalScore += game.score;
            replayGameState = 'ended';
        }
    }

    // =====================================================================
    // UPDATE + DRAW
    // =====================================================================
    function update(dt) {
        game.step(dt);

        // Process game-core events for visual effects
        engineProcessEvents(game.events, game);
        game.events = [];
        engineUpdateVisuals(game);

        // Fever decay when chain done
        if (feverIntensity > 0 && game.explosions.length === 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }

        // Track resolving → done transition
        if (replayGameState === 'resolving' && game.gameState !== 'resolving') {
            replayGameState = 'playing';
        }

        // Continuous: check overflow
        if (isContinuous && game.overflowed && replayGameState !== 'ended') {
            replayGameState = 'ended';
            spawnCelebration('OVERFLOW', 0, 1.6);
        }
    }

    function draw() {
        if (loading) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('Loading replay...', W/2, H/2);
            return;
        }
        if (errorMsg) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,120,120,0.8)';
            ctx.fillText(errorMsg, W/2, H/2);
            drawNavButtons();
            return;
        }

        const mappedState = replayGameState === 'playing' ? 'playing'
            : replayGameState === 'resolving' ? 'resolving' : 'start';
        engineDrawScene(ctx, game, mappedState, false);

        drawReplayHUD();
        drawNavButtons();
        drawProgressBar();
    }

    function drawReplayHUD() {
        const s = Math.max(1, Math.min(W, H) / 600);

        if (isContinuous) {
            // Continuous mode HUD
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const tierNames = { CALM: 'Calm', FLOW: 'Flow', SURGE: 'Surge', TRANSCENDENCE: 'Transcendence', IMPOSSIBLE: 'Impossible' };
            const tierName = tierNames[replayData.tier] || replayData.tier;
            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.letterSpacing = '2px';
            ctx.fillText(tierName.toUpperCase(), W/2, 14 * s);
            ctx.letterSpacing = '0px';

            // Time
            const secs = Math.floor(replayTime / 1000);
            const mins = Math.floor(secs / 60);
            const remSecs = secs % 60;
            ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillText(`${mins}:${remSecs.toString().padStart(2, '0')}`, W/2, 28 * s);

            // Density bar
            const density = game.density();
            if (density > 0) {
                const barW = 80 * s, barH = 4 * s;
                const barX = W/2 - barW/2, barY = 72 * s;
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH, barH/2); ctx.fill();
                const fill = Math.min(1, density);
                const hue = fill < 0.5 ? 200 : fill < 0.7 ? 40 : 0;
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.5)`;
                ctx.beginPath(); ctx.roundRect(barX, barY, barW * fill, barH, barH/2); ctx.fill();
                ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`${(density * 100).toFixed(0)}%`, W/2, barY + barH + 4 * s);
            }

            // Chain count
            if (game.chainCount > 0) {
                ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.fillText(`Chain: ${game.chainCount}`, W/2, 92 * s);
                ctx.restore();
            }

            // Score
            if (game.score > 0) {
                ctx.font = `300 ${11 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Score: ${game.score.toLocaleString()}`, W/2, 110 * s);
            }

            // Bot label
            const botNames = { CALM: 'Dumb', FLOW: 'Average', SURGE: 'Good', TRANSCENDENCE: 'Pro', IMPOSSIBLE: 'Inhuman' };
            const botName = botNames[replayData.botProfile] || replayData.botProfile;
            ctx.font = `400 ${9 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255, 255, 100, 0.35)';
            ctx.textAlign = 'left';
            ctx.fillText(`BOT: ${botName}`, 10 * s, 14 * s);
        } else if (currentRound > 0) {
            // Round mode HUD
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.letterSpacing = '2px';
            ctx.fillText('ROUND', W/2, 14 * s);
            ctx.letterSpacing = '0px';

            ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillText(currentRound, W/2, 28 * s);

            if (totalRounds > 0) {
                ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`of ${totalRounds}`, W/2, 68 * s);
            }

            if (game.chainCount > 0) {
                ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.fillText(`Chain: ${game.chainCount}`, W/2, 84 * s);
                ctx.restore();
            }

            if (totalScore > 0 || game.score > 0) {
                ctx.font = `300 ${11 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Score: ${(totalScore + game.score).toLocaleString()}`, W/2, 100 * s);
            }
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.font = `600 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(100, 180, 255, 0.35)';
        ctx.letterSpacing = '2px';
        ctx.fillText('REPLAY', W - 10 * s, 10 * s);
        ctx.letterSpacing = '0px';

        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    function drawNavButtons() {
        uiButtons = [];
        const s = Math.max(1, Math.min(W, H) / 600);
        const btnY = H - 28 * s;

        const backRect = drawPill(ctx, 50 * s, btnY, '< Game', false, 200);
        uiButtons.push({ id: 'back', ...backRect });

        if (!loading && !errorMsg) {
            const playLabel = playing ? 'Pause' : 'Play';
            const playRect = drawPill(ctx, W/2 - 55 * s, btnY, playLabel, playing, 120);
            uiButtons.push({ id: 'playpause', ...playRect });

            const speeds = [1, 2, 4];
            const speedLabels = ['1x', '2x', '4x'];
            for (let i = 0; i < speeds.length; i++) {
                const sx = W/2 + (i * 40 - 10) * s;
                const rect = drawPill(ctx, sx, btnY, speedLabels[i], speed === speeds[i], 55);
                uiButtons.push({ id: `speed_${speeds[i]}`, ...rect });
            }

            if (replayData) {
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = `300 ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                if (isContinuous) {
                    ctx.fillText(`${replayData.tier} · seed ${replayData.seed}`, W - 12 * s, btnY);
                } else {
                    const name = replayData.player_name || (replayData.is_bot ? 'Bot' : 'Anonymous');
                    ctx.fillText(`${name} — R${replayData.peak_round}`, W - 12 * s, btnY);
                }
            }
        }
    }

    function drawProgressBar() {
        if (!replayEvents.length || totalDuration <= 0) return;
        const s = Math.max(1, Math.min(W, H) / 600);
        const barY = H - 48 * s;
        const barX = 12 * s;
        const barW = W - 24 * s;
        const barH = 3 * s;

        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW, barH, barH / 2);
        ctx.fill();

        const progress = Math.min(1, replayTime / totalDuration);
        if (progress > 0) {
            ctx.fillStyle = 'rgba(100, 180, 255, 0.4)';
            ctx.beginPath();
            ctx.roundRect(barX, barY, barW * progress, barH, barH / 2);
            ctx.fill();
        }

        const headX = barX + barW * progress;
        ctx.beginPath();
        ctx.arc(headX, barY + barH / 2, 4 * s, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100, 180, 255, 0.7)';
        ctx.fill();
    }

    // =====================================================================
    // MAIN LOOP
    // =====================================================================
    function loop(now) {
        if (playing && replayEvents.length > 0 && !loading && !errorMsg) {
            const dt = (now - lastFrameTime) * speed;
            replayTime += dt;

            while (eventIdx < replayEvents.length && replayEvents[eventIdx].t <= replayTime) {
                processEvent(replayEvents[eventIdx]);
                eventIdx++;
            }

            update(Math.min(dt, 50));
        } else {
            update(0);
        }
        lastFrameTime = now;

        draw();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // LOAD REPLAY
    // =====================================================================
    async function loadReplay() {
        const params = new URLSearchParams(window.location.search);
        const file = params.get('file');

        try {
            let data;
            if (file) {
                // Load from static file: ?file=replays/surge-137.json
                const res = await fetch(file);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                data = await res.json();
            } else {
                // Load from API: /replay/{sessionId}
                const pathParts = window.location.pathname.split('/');
                const sessionId = pathParts[pathParts.length - 1];
                if (!sessionId) { loading = false; errorMsg = 'No replay ID in URL. Use ?file=replay.json'; return; }
                const res = await fetch(`/api/replay/${sessionId}`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                data = await res.json();
            }

            replayData = data;
            replayEvents = data.events || [];
            if (replayEvents.length === 0) { loading = false; errorMsg = 'Replay has no events'; return; }

            // Detect continuous mode
            isContinuous = data.mode === 'continuous';

            if (isContinuous) {
                // Deterministic replay: same seed → same spawning
                const vp = data.viewport || { w: 390, h: 844 };
                game = new Game(vp.w, vp.h, {}, createRNG(data.seed));
                game.startContinuous(data.tierConfig);
                game.W = W;
                game.H = H;
                replayGameState = 'playing';

                totalDuration = replayEvents[replayEvents.length - 1].t + 5000; // pad 5s after last tap
                document.title = `Replay — ${data.tier} · seed ${data.seed}`;
            } else {
                totalDuration = replayEvents[replayEvents.length - 1].t;
                totalRounds = data.peak_round || 0;
                const name = data.player_name || (data.is_bot ? 'Bot' : 'Anonymous');
                document.title = `Replay — ${name} R${data.peak_round}`;
            }

            loading = false;
            playing = true;
            lastFrameTime = performance.now();
        } catch (e) {
            loading = false;
            errorMsg = `Failed to load replay: ${e.message}`;
        }
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    function hitTestButtons(x, y) {
        for (const btn of uiButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                return btn.id;
            }
        }
        return null;
    }

    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        const x = e.clientX, y = e.clientY;
        const hit = hitTestButtons(x, y);

        if (hit === 'back') { window.location.href = '/'; return; }
        if (hit === 'playpause') {
            playing = !playing;
            if (playing) lastFrameTime = performance.now();
            return;
        }
        if (hit && hit.startsWith('speed_')) {
            speed = parseInt(hit.split('_')[1]);
            return;
        }
    });

    document.addEventListener('keydown', e => {
        if (e.key === ' ') { e.preventDefault(); playing = !playing; if (playing) lastFrameTime = performance.now(); }
        if (e.key === '1') speed = 1;
        if (e.key === '2') speed = 2;
        if (e.key === '4') speed = 4;
        if (e.key === 'Escape') window.location.href = '/';
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    requestAnimationFrame(loop);
    loadReplay();

    </script>
</body>
</html>
