<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction — Replay</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script src="game-core.js"></script>
    <script src="engine.js"></script>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION — Replay Viewer (uses game-core.js + engine.js)
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // REPLAY STATE
    // =====================================================================
    let replayData = null;
    let replayEvents = [];
    let eventIdx = 0;
    let replayTime = 0;
    let totalDuration = 0;
    let playing = false;
    let speed = 1;
    let lastFrameTime = 0;

    let currentRound = 0;
    let totalRounds = 0;
    let totalScore = 0;
    let replayGameState = 'waiting'; // waiting, playing, resolving, ended

    let loading = true;
    let errorMsg = null;

    let uiButtons = [];

    // Game instance for physics
    const game = new Game(400, 700, {}, Math.random);

    // =====================================================================
    // RESIZE
    // =====================================================================
    function resize() {
        engineResize(canvas);
        game.W = W;
        game.H = H;
    }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // REPLAY EVENT PROCESSING
    // =====================================================================
    function processEvent(ev) {
        if (ev.type === 'round_start') {
            currentRound = ev.data.round;
            game.setupRound(ev.data.round);
            // Replace generated dots with recorded positions
            game.dots = ev.data.dots.map(d => ({
                x: d.x, y: d.y, vx: d.vx, vy: d.vy,
                active: true, type: d.type || 'standard', bloomTimer: 0,
            }));
            game.totalDots = game.dots.length;
            engineResetVisuals();
            replayGameState = 'playing';
        } else if (ev.type === 'tap') {
            game.tap(ev.data.x, ev.data.y);
            spawnFloatingText(ev.data.x, ev.data.y + 20, 'TAP', 200);
            replayGameState = 'resolving';
        } else if (ev.type === 'clear') {
            totalScore += game.score;
            spawnCelebration(`Round ${ev.data.round} Clear!`, 200, 1.4);
        } else if (ev.type === 'fail') {
            spawnCelebration(`Round ${ev.data.round} Failed`, 0, 1.0);
            totalScore += game.score;
            replayGameState = 'ended';
        }
    }

    // =====================================================================
    // UPDATE + DRAW
    // =====================================================================
    function update(dt) {
        game.step(dt);

        // Process game-core events for visual effects
        engineProcessEvents(game.events, game);
        game.events = [];
        engineUpdateVisuals(game);

        // Fever decay when chain done
        if (feverIntensity > 0 && game.explosions.length === 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }

        // Track resolving → done transition
        if (replayGameState === 'resolving' && game.gameState !== 'resolving') {
            replayGameState = 'playing';
        }
    }

    function draw() {
        if (loading) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('Loading replay...', W/2, H/2);
            return;
        }
        if (errorMsg) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,120,120,0.8)';
            ctx.fillText(errorMsg, W/2, H/2);
            drawNavButtons();
            return;
        }

        const mappedState = replayGameState === 'playing' ? 'playing'
            : replayGameState === 'resolving' ? 'resolving' : 'start';
        engineDrawScene(ctx, game, mappedState, false);

        drawReplayHUD();
        drawNavButtons();
        drawProgressBar();
    }

    function drawReplayHUD() {
        const s = Math.max(1, Math.min(W, H) / 600);

        if (currentRound > 0) {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.letterSpacing = '2px';
            ctx.fillText('ROUND', W/2, 14 * s);
            ctx.letterSpacing = '0px';

            ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillText(currentRound, W/2, 28 * s);

            if (totalRounds > 0) {
                ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`of ${totalRounds}`, W/2, 68 * s);
            }

            if (game.chainCount > 0) {
                ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.fillText(`Chain: ${game.chainCount}`, W/2, 84 * s);
                ctx.restore();
            }

            if (totalScore > 0 || game.score > 0) {
                ctx.font = `300 ${11 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Score: ${(totalScore + game.score).toLocaleString()}`, W/2, 100 * s);
            }
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.font = `600 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(100, 180, 255, 0.35)';
        ctx.letterSpacing = '2px';
        ctx.fillText('REPLAY', W - 10 * s, 10 * s);
        ctx.letterSpacing = '0px';

        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    function drawNavButtons() {
        uiButtons = [];
        const s = Math.max(1, Math.min(W, H) / 600);
        const btnY = H - 28 * s;

        const backRect = drawPill(ctx, 50 * s, btnY, '< Game', false, 200);
        uiButtons.push({ id: 'back', ...backRect });

        if (!loading && !errorMsg) {
            const playLabel = playing ? 'Pause' : 'Play';
            const playRect = drawPill(ctx, W/2 - 55 * s, btnY, playLabel, playing, 120);
            uiButtons.push({ id: 'playpause', ...playRect });

            const speeds = [1, 2, 4];
            const speedLabels = ['1x', '2x', '4x'];
            for (let i = 0; i < speeds.length; i++) {
                const sx = W/2 + (i * 40 - 10) * s;
                const rect = drawPill(ctx, sx, btnY, speedLabels[i], speed === speeds[i], 55);
                uiButtons.push({ id: `speed_${speeds[i]}`, ...rect });
            }

            if (replayData) {
                const name = replayData.player_name || (replayData.is_bot ? 'Bot' : 'Anonymous');
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = `300 ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillText(`${name} — R${replayData.peak_round}`, W - 12 * s, btnY);
            }
        }
    }

    function drawProgressBar() {
        if (!replayEvents.length || totalDuration <= 0) return;
        const s = Math.max(1, Math.min(W, H) / 600);
        const barY = H - 48 * s;
        const barX = 12 * s;
        const barW = W - 24 * s;
        const barH = 3 * s;

        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW, barH, barH / 2);
        ctx.fill();

        const progress = Math.min(1, replayTime / totalDuration);
        if (progress > 0) {
            ctx.fillStyle = 'rgba(100, 180, 255, 0.4)';
            ctx.beginPath();
            ctx.roundRect(barX, barY, barW * progress, barH, barH / 2);
            ctx.fill();
        }

        const headX = barX + barW * progress;
        ctx.beginPath();
        ctx.arc(headX, barY + barH / 2, 4 * s, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100, 180, 255, 0.7)';
        ctx.fill();
    }

    // =====================================================================
    // MAIN LOOP
    // =====================================================================
    function loop(now) {
        if (playing && replayEvents.length > 0 && !loading && !errorMsg) {
            const dt = (now - lastFrameTime) * speed;
            replayTime += dt;

            while (eventIdx < replayEvents.length && replayEvents[eventIdx].t <= replayTime) {
                processEvent(replayEvents[eventIdx]);
                eventIdx++;
            }

            update(Math.min(dt, 50));
        } else {
            update(0);
        }
        lastFrameTime = now;

        draw();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // LOAD REPLAY
    // =====================================================================
    async function loadReplay() {
        const pathParts = window.location.pathname.split('/');
        const sessionId = pathParts[pathParts.length - 1];
        if (!sessionId) {
            loading = false;
            errorMsg = 'No replay ID in URL';
            return;
        }
        try {
            const res = await fetch(`/api/replay/${sessionId}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            replayData = await res.json();
            replayEvents = replayData.events || [];
            if (replayEvents.length === 0) {
                loading = false;
                errorMsg = 'Replay has no events';
                return;
            }

            totalDuration = replayEvents[replayEvents.length - 1].t;
            totalRounds = replayData.peak_round || 0;

            const name = replayData.player_name || (replayData.is_bot ? 'Bot' : 'Anonymous');
            document.title = `Replay — ${name} R${replayData.peak_round}`;

            loading = false;
            playing = true;
            lastFrameTime = performance.now();
        } catch (e) {
            loading = false;
            errorMsg = `Failed to load replay: ${e.message}`;
        }
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    function hitTestButtons(x, y) {
        for (const btn of uiButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                return btn.id;
            }
        }
        return null;
    }

    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        const x = e.clientX, y = e.clientY;
        const hit = hitTestButtons(x, y);

        if (hit === 'back') { window.location.href = '/'; return; }
        if (hit === 'playpause') {
            playing = !playing;
            if (playing) lastFrameTime = performance.now();
            return;
        }
        if (hit && hit.startsWith('speed_')) {
            speed = parseInt(hit.split('_')[1]);
            return;
        }
    });

    document.addEventListener('keydown', e => {
        if (e.key === ' ') { e.preventDefault(); playing = !playing; if (playing) lastFrameTime = performance.now(); }
        if (e.key === '1') speed = 1;
        if (e.key === '2') speed = 2;
        if (e.key === '4') speed = 4;
        if (e.key === 'Escape') window.location.href = '/';
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    requestAnimationFrame(loop);
    loadReplay();

    </script>
</body>
</html>
