<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction — Replay</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script src="/engine.js"></script>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION — Replay Viewer (uses shared engine.js)
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // REPLAY STATE
    // =====================================================================
    let replayData = null;
    let events = [];
    let eventIdx = 0;
    let replayTime = 0;
    let totalDuration = 0;
    let playing = false;
    let speed = 1;
    let lastFrameTime = 0;

    let currentRound = 0;
    let totalRounds = 0;
    let totalScore = 0;
    let replayGameState = 'waiting'; // waiting, playing, resolving, ended

    let loading = true;
    let errorMsg = null;

    // UI buttons for canvas-drawn controls
    let uiButtons = [];

    // =====================================================================
    // RESIZE (delegates to engine)
    // =====================================================================
    function resize() { engineResize(canvas); }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // REPLAY EVENT PROCESSING
    // =====================================================================
    function processEvent(ev) {
        if (ev.type === 'round_start') {
            currentRound = ev.data.round;
            roundRadiusScale = getRoundRadiusScale(currentRound);
            recalcExplosionRadius();
            dots = ev.data.dots.map(d => new Dot(d.x, d.y, d.vx, d.vy, d.type));
            roundTotalDots = dots.length;
            engineResetRound();
            replayGameState = 'playing';
        } else if (ev.type === 'tap') {
            const x = ev.data.x, y = ev.data.y;
            const exp = new Explosion(x, y, 0, explosionRadius, handleDotCaught);
            explosions.push(exp);
            spawnFloatingText(x, y + 20, 'TAP', 200);
            replayGameState = 'resolving';
        } else if (ev.type === 'clear') {
            totalScore += score;
            spawnCelebration(`Round ${ev.data.round} Clear!`, 200, 1.4);
        } else if (ev.type === 'fail') {
            spawnCelebration(`Round ${ev.data.round} Failed`, 0, 1.0);
            totalScore += score;
            replayGameState = 'ended';
        }
    }

    // =====================================================================
    // UPDATE + DRAW
    // =====================================================================
    function update() {
        engineUpdatePhysics();

        // Fever decay
        if (feverIntensity > 0 && explosions.length === 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }
    }

    function draw() {
        if (loading) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('Loading replay...', W/2, H/2);
            return;
        }
        if (errorMsg) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,120,120,0.8)';
            ctx.fillText(errorMsg, W/2, H/2);
            drawNavButtons();
            return;
        }

        // Use the shared scene renderer (background, vignette, dots, explosions, particles, etc.)
        engineDrawScene(ctx, replayGameState === 'playing' ? 'playing' : replayGameState === 'resolving' ? 'resolving' : 'start', false);

        // Replay HUD
        drawReplayHUD();
        drawNavButtons();
        drawProgressBar();
    }

    function drawReplayHUD() {
        const s = Math.max(1, Math.min(W, H) / 600);

        // Top center: Round info
        if (currentRound > 0) {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.letterSpacing = '2px';
            ctx.fillText('ROUND', W/2, 14 * s);
            ctx.letterSpacing = '0px';

            ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillText(currentRound, W/2, 28 * s);

            if (totalRounds > 0) {
                ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`of ${totalRounds}`, W/2, 68 * s);
            }

            // Chain count during active chains
            if (chainCount > 0) {
                ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.fillText(`Chain: ${chainCount}`, W/2, 84 * s);
                ctx.restore();
            }

            // Running score
            if (totalScore > 0 || score > 0) {
                ctx.font = `300 ${11 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Score: ${(totalScore + score).toLocaleString()}`, W/2, 100 * s);
            }
        }

        // Top-right: REPLAY badge
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.font = `600 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(100, 180, 255, 0.35)';
        ctx.letterSpacing = '2px';
        ctx.fillText('REPLAY', W - 10 * s, 10 * s);
        ctx.letterSpacing = '0px';

        // Build version
        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    function drawNavButtons() {
        uiButtons = [];
        const s = Math.max(1, Math.min(W, H) / 600);
        const btnY = H - 28 * s;

        // Left: "< Game" button
        const backRect = drawPill(ctx, 50 * s, btnY, '< Game', false, 200);
        uiButtons.push({ id: 'back', ...backRect });

        if (!loading && !errorMsg) {
            // Center: Play/Pause
            const playLabel = playing ? 'Pause' : 'Play';
            const playRect = drawPill(ctx, W/2 - 55 * s, btnY, playLabel, playing, 120);
            uiButtons.push({ id: 'playpause', ...playRect });

            // Speed buttons
            const speeds = [1, 2, 4];
            const speedLabels = ['1x', '2x', '4x'];
            for (let i = 0; i < speeds.length; i++) {
                const sx = W/2 + (i * 40 - 10) * s;
                const rect = drawPill(ctx, sx, btnY, speedLabels[i], speed === speeds[i], 55);
                uiButtons.push({ id: `speed_${speeds[i]}`, ...rect });
            }

            // Right: player info
            if (replayData) {
                const name = replayData.player_name || (replayData.is_bot ? 'Bot' : 'Anonymous');
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = `300 ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillText(`${name} — R${replayData.peak_round}`, W - 12 * s, btnY);
            }
        }
    }

    function drawProgressBar() {
        if (!events.length || totalDuration <= 0) return;
        const s = Math.max(1, Math.min(W, H) / 600);
        const barY = H - 48 * s;
        const barX = 12 * s;
        const barW = W - 24 * s;
        const barH = 3 * s;

        // Background track
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW, barH, barH / 2);
        ctx.fill();

        // Progress fill
        const progress = Math.min(1, replayTime / totalDuration);
        if (progress > 0) {
            ctx.fillStyle = 'rgba(100, 180, 255, 0.4)';
            ctx.beginPath();
            ctx.roundRect(barX, barY, barW * progress, barH, barH / 2);
            ctx.fill();
        }

        // Playhead dot
        const headX = barX + barW * progress;
        ctx.beginPath();
        ctx.arc(headX, barY + barH / 2, 4 * s, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100, 180, 255, 0.7)';
        ctx.fill();
    }

    // =====================================================================
    // MAIN LOOP
    // =====================================================================
    function loop(now) {
        if (playing && events.length > 0 && !loading && !errorMsg) {
            const dt = (now - lastFrameTime) * speed;
            replayTime += dt;

            while (eventIdx < events.length && events[eventIdx].t <= replayTime) {
                processEvent(events[eventIdx]);
                eventIdx++;
            }
        }
        lastFrameTime = now;

        update();
        draw();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // LOAD REPLAY
    // =====================================================================
    async function loadReplay() {
        const pathParts = window.location.pathname.split('/');
        const sessionId = pathParts[pathParts.length - 1];
        if (!sessionId) {
            loading = false;
            errorMsg = 'No replay ID in URL';
            return;
        }
        try {
            const res = await fetch(`/api/replay/${sessionId}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            replayData = await res.json();
            events = replayData.events || [];
            if (events.length === 0) {
                loading = false;
                errorMsg = 'Replay has no events';
                return;
            }

            // Calculate total duration and total rounds
            totalDuration = events[events.length - 1].t;
            totalRounds = replayData.peak_round || 0;

            const name = replayData.player_name || (replayData.is_bot ? 'Bot' : 'Anonymous');
            document.title = `Replay — ${name} R${replayData.peak_round}`;

            loading = false;
            playing = true;
            lastFrameTime = performance.now();
        } catch (e) {
            loading = false;
            errorMsg = `Failed to load replay: ${e.message}`;
        }
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    function hitTestButtons(x, y) {
        for (const btn of uiButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                return btn.id;
            }
        }
        return null;
    }

    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        const x = e.clientX, y = e.clientY;
        const hit = hitTestButtons(x, y);

        if (hit === 'back') {
            window.location.href = '/';
            return;
        }
        if (hit === 'playpause') {
            playing = !playing;
            if (playing) lastFrameTime = performance.now();
            return;
        }
        if (hit && hit.startsWith('speed_')) {
            speed = parseInt(hit.split('_')[1]);
            return;
        }
    });

    document.addEventListener('keydown', e => {
        if (e.key === ' ') {
            e.preventDefault();
            playing = !playing;
            if (playing) lastFrameTime = performance.now();
        }
        if (e.key === '1') speed = 1;
        if (e.key === '2') speed = 2;
        if (e.key === '4') speed = 4;
        if (e.key === 'Escape') window.location.href = '/';
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    requestAnimationFrame(loop);
    loadReplay();

    </script>
</body>
</html>
