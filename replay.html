<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction — Replay</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas { display: block; }
        #controls {
            position: fixed;
            top: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(8px);
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 10;
            font-size: 13px;
            color: rgba(255,255,255,0.8);
        }
        #controls button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 5px 14px;
            border-radius: 16px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
        }
        #controls button:hover { background: rgba(255,255,255,0.2); }
        #controls button.active { background: rgba(100,180,255,0.3); border-color: rgba(100,180,255,0.5); }
        #controls .info { opacity: 0.6; }
        #controls .spacer { flex: 1; }
        #loading {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.5);
            font-size: 16px;
            z-index: 20;
        }
        #error {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            color: rgba(255,120,120,0.8);
            font-size: 16px;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="loading">Loading replay...</div>
    <div id="error"></div>
    <div id="controls" style="display:none">
        <button id="playBtn">Play</button>
        <button id="speed1" class="active">1x</button>
        <button id="speed2">2x</button>
        <button id="speed4">4x</button>
        <span class="spacer"></span>
        <span id="roundInfo" class="info">Round 0</span>
        <span id="scoreInfo" class="info">Score: 0</span>
        <span id="metaInfo" class="info"></span>
    </div>
    <canvas id="game"></canvas>
    <script>
    'use strict';

    // =====================================================================
    // CONSTANTS (copied from game)
    // =====================================================================
    const EXPLOSION_RADIUS_PCT = 0.10;
    const EXPLOSION_RADIUS_MIN_PX = 35;
    const EXPLOSION_GROW_MS = 200;
    const EXPLOSION_HOLD_MS = 1000;
    const EXPLOSION_SHRINK_MS = 500;
    const CASCADE_STAGGER_MS = 80;
    const CASCADE_RADIUS_GROWTH = 0.08;
    const CASCADE_HOLD_GROWTH_MS = 200;
    const CASCADE_GEN_CAP = 4;
    const SCREEN_MARGIN = 16;
    const DOT_TRAIL_LENGTH = 8;
    const SHAKE_MAX_OFFSET = 14;
    const SHAKE_DECAY = 0.90;
    const SHAKE_TRAUMA_PER_DOT = 0.06;
    const PARTICLE_POOL_SIZE = 4000;
    const AMBIENT_PARTICLE_COUNT = 120;

    const DOT_TYPES = {
        standard: { label: 'standard', radiusMult: 1.0, speedMult: 1.0 },
        gravity:  { label: 'gravity',  radiusMult: 1.0, speedMult: 0.7, pullRange: 2.5, pullForce: 0.012 },
        volatile: { label: 'volatile', radiusMult: 1.5, speedMult: 1.3 },
    };

    const MULT_THRESHOLDS = [
        { chain: 0, mult: 1 }, { chain: 5, mult: 2 },
        { chain: 10, mult: 3 }, { chain: 15, mult: 4 },
        { chain: 20, mult: 5 }, { chain: 30, mult: 8 },
    ];

    const CELEBRATIONS = [
        { chain: 5, text: 'NICE!', hue: 50, size: 1.0 },
        { chain: 10, text: 'AMAZING!', hue: 35, size: 1.3 },
        { chain: 15, text: 'INCREDIBLE!', hue: 15, size: 1.6 },
        { chain: 20, text: 'LEGENDARY!', hue: 300, size: 2.0 },
        { chain: 30, text: 'GODLIKE!', hue: 280, size: 2.5 },
    ];

    const easeOutExpo = t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    const easeInQuad = t => t * t;
    const easeOutBack = t => 1 + 2.70158 * Math.pow(t - 1, 3) + 1.70158 * Math.pow(t - 1, 2);
    const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

    // =====================================================================
    // STATE
    // =====================================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H, refDim, explosionRadius;
    let DOT_RADIUS = 5;
    let DOT_GLOW_SIZE = 18;

    let replayData = null;
    let events = [];
    let eventIdx = 0;
    let replayTime = 0;
    let playing = false;
    let speed = 1;
    let lastFrameTime = 0;

    let dots = [];
    let explosions = [];
    let pendingExplosions = [];
    let scheduledDetonations = new Set();
    let chainCount = 0;
    let score = 0;
    let totalScore = 0;
    let currentRound = 0;
    let currentMultiplier = 1;
    let floatingTexts = [];
    let chainLines = [];
    let shakeTrauma = 0;
    let shakeX = 0, shakeY = 0;
    let bgPulse = 0;
    let feverIntensity = 0;
    let screenFlash = 0;
    let beatPulse = 0;
    let slowMo = 1.0;
    let lastCelebration = -1;

    // =====================================================================
    // RESIZE
    // =====================================================================
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        refDim = Math.min(W, H, 800);
        const screenMin = Math.min(W, H);
        explosionRadius = Math.max(EXPLOSION_RADIUS_MIN_PX, refDim * EXPLOSION_RADIUS_PCT);
        DOT_RADIUS = Math.max(6, screenMin * 0.014);
        DOT_GLOW_SIZE = Math.max(28, screenMin * 0.06);
    }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // PARTICLE POOL (simplified from game)
    // =====================================================================
    const particles = {
        x: new Float32Array(PARTICLE_POOL_SIZE),
        y: new Float32Array(PARTICLE_POOL_SIZE),
        vx: new Float32Array(PARTICLE_POOL_SIZE),
        vy: new Float32Array(PARTICLE_POOL_SIZE),
        life: new Float32Array(PARTICLE_POOL_SIZE),
        maxLife: new Float32Array(PARTICLE_POOL_SIZE),
        hue: new Float32Array(PARTICLE_POOL_SIZE),
        size: new Float32Array(PARTICLE_POOL_SIZE),
        friction: new Float32Array(PARTICLE_POOL_SIZE),
        gravity: new Float32Array(PARTICLE_POOL_SIZE),
        count: 0,
        spawn(x, y, vx, vy, life, hue, size, friction, gravity) {
            if (this.count >= PARTICLE_POOL_SIZE) return;
            const i = this.count;
            this.x[i]=x; this.y[i]=y; this.vx[i]=vx; this.vy[i]=vy;
            this.life[i]=life; this.maxLife[i]=life; this.hue[i]=hue;
            this.size[i]=size; this.friction[i]=friction; this.gravity[i]=gravity;
            this.count++;
        },
        update() {
            let i = 0;
            while (i < this.count) {
                this.vx[i] *= this.friction[i]; this.vy[i] *= this.friction[i];
                this.vy[i] += this.gravity[i];
                this.x[i] += this.vx[i]; this.y[i] += this.vy[i];
                this.life[i]--;
                if (this.life[i] <= 0) {
                    this.count--;
                    if (i < this.count) {
                        this.x[i]=this.x[this.count]; this.y[i]=this.y[this.count];
                        this.vx[i]=this.vx[this.count]; this.vy[i]=this.vy[this.count];
                        this.life[i]=this.life[this.count]; this.maxLife[i]=this.maxLife[this.count];
                        this.hue[i]=this.hue[this.count]; this.size[i]=this.size[this.count];
                        this.friction[i]=this.friction[this.count]; this.gravity[i]=this.gravity[this.count];
                    }
                } else { i++; }
            }
        },
        draw(ctx) {
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < this.count; i++) {
                const a = this.life[i] / this.maxLife[i];
                const s = this.size[i] * (0.4 + a * 0.6);
                const alpha = a * a;
                if (alpha < 0.01) continue;
                ctx.globalAlpha = alpha;
                const h = this.hue[i];
                if (s > 3) {
                    const gr = s * 2;
                    const grd = ctx.createRadialGradient(this.x[i], this.y[i], 0, this.x[i], this.y[i], gr);
                    grd.addColorStop(0, `hsla(${h}, 100%, ${70+a*20}%, 0.7)`);
                    grd.addColorStop(0.5, `hsla(${h}, 90%, ${55+a*15}%, 0.15)`);
                    grd.addColorStop(1, `hsla(${h}, 80%, 50%, 0)`);
                    ctx.fillStyle = grd;
                    ctx.fillRect(this.x[i]-gr, this.y[i]-gr, gr*2, gr*2);
                } else {
                    ctx.fillStyle = `hsl(${h}, 100%, ${60+a*25}%)`;
                    ctx.fillRect(this.x[i]-s*0.5, this.y[i]-s*0.5, s, s);
                }
            }
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        },
        clear() { this.count = 0; }
    };

    function emitParticles(x, y, hue, gen) {
        const depth = Math.min(8, gen);
        const burstN = 8 + depth * 2;
        for (let i = 0; i < burstN; i++) {
            const a = (Math.PI * 2 * i) / burstN + (Math.random() - 0.5) * 0.5;
            const spd = 3.5 + Math.random() * 5;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                22 + Math.random()*18, hue + (Math.random()-0.5)*30, 2 + Math.random()*3, 0.92, 0.04);
        }
        const driftN = 4 + depth;
        for (let i = 0; i < driftN; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 0.8 + Math.random() * 1.5;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                50 + Math.random()*35, hue + (Math.random()-0.5)*20, 3.5 + Math.random()*4, 0.97, -0.025);
        }
    }

    function emitCelebrationBurst(x, y, hue, count) {
        for (let i = 0; i < count; i++) {
            const a = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.4;
            const spd = 5 + Math.random() * 10;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                35 + Math.random()*25, hue + (Math.random()-0.5)*60, 3 + Math.random()*5, 0.94, 0.03);
        }
    }

    // =====================================================================
    // AMBIENT
    // =====================================================================
    const ambientStars = [];
    function initAmbient() {
        ambientStars.length = 0;
        for (let i = 0; i < AMBIENT_PARTICLE_COUNT; i++) {
            const isBright = Math.random() < 0.15;
            ambientStars.push({
                x: Math.random() * W, y: Math.random() * H,
                vx: (Math.random()-0.5)*0.12, vy: (Math.random()-0.5)*0.12,
                size: isBright ? (1.5+Math.random()*2) : (0.5+Math.random()*1.8),
                alpha: isBright ? (0.15+Math.random()*0.2) : (0.04+Math.random()*0.12),
                phase: Math.random()*Math.PI*2,
                hue: isBright ? (180+Math.random()*60) : 220,
            });
        }
    }
    function updateAmbient() {
        for (const s of ambientStars) {
            s.x += s.vx; s.y += s.vy; s.phase += 0.008;
            if (s.x < 0) s.x = W; if (s.x > W) s.x = 0;
            if (s.y < 0) s.y = H; if (s.y > H) s.y = 0;
        }
    }
    function drawAmbient() {
        ctx.globalCompositeOperation = 'lighter';
        for (const s of ambientStars) {
            const a = s.alpha * (0.5 + 0.5 * Math.sin(s.phase));
            if (a < 0.01) continue;
            ctx.globalAlpha = a;
            if (s.size > 2) {
                const gr = s.size * 3;
                const grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, gr);
                grd.addColorStop(0, `hsla(${s.hue}, 40%, 80%, 0.6)`);
                grd.addColorStop(0.3, `hsla(${s.hue}, 30%, 70%, 0.15)`);
                grd.addColorStop(1, `hsla(${s.hue}, 30%, 60%, 0)`);
                ctx.fillStyle = grd;
                ctx.fillRect(s.x-gr, s.y-gr, gr*2, gr*2);
            }
            ctx.fillStyle = `hsla(${s.hue}, 30%, 85%, 1)`;
            ctx.fillRect(s.x-s.size*0.5, s.y-s.size*0.5, s.size, s.size);
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    // =====================================================================
    // FLOATING TEXT
    // =====================================================================
    function spawnFloatingText(x, y, text, hue) {
        floatingTexts.push({ x, y, text, hue, age: 0, maxAge: 50 });
    }
    function spawnCelebration(text, hue, scale) {
        floatingTexts.push({ x: W/2, y: H*0.35, text, hue, age: 0, maxAge: 120, scale, celebration: true });
        emitCelebrationBurst(W/2, H/2, hue, Math.floor(40 * (scale || 1)));
        shakeTrauma = Math.min(1.0, shakeTrauma + 0.3 * (scale || 1));
        screenFlash = Math.min(0.6, 0.40 * (scale || 1));
    }
    function updateFloatingTexts() {
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            const ft = floatingTexts[i];
            ft.age++;
            ft.y -= (ft.celebration ? 0.5 : 1.5) * (1 - ft.age / ft.maxAge);
            if (ft.age >= ft.maxAge) floatingTexts.splice(i, 1);
        }
    }
    function drawFloatingTexts() {
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const baseSize = Math.max(14, Math.min(W, H) * 0.022);
        for (const ft of floatingTexts) {
            const a = 1 - easeInQuad(ft.age / ft.maxAge);
            if (ft.celebration) {
                const entryScale = easeOutBack(Math.min(1, ft.age / 12));
                const sz = Math.round(baseSize * 3 * (ft.scale || 1) * entryScale);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.shadowColor = `hsla(${ft.hue}, 90%, 60%, 0.8)`;
                ctx.shadowBlur = 20;
                ctx.font = `900 ${sz}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${ft.hue}, 90%, 75%)`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            } else {
                const scale = 0.8 + 0.4 * easeOutBack(Math.min(1, ft.age / 8));
                const sz = Math.round(baseSize * scale);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.shadowColor = `hsla(${ft.hue}, 80%, 60%, 0.5)`;
                ctx.shadowBlur = 8;
                ctx.font = `600 ${sz}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${ft.hue}, 80%, 78%)`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            }
        }
        ctx.globalAlpha = 1;
    }

    // =====================================================================
    // CHAIN LINES
    // =====================================================================
    function spawnChainLine(x1, y1, x2, y2) {
        chainLines.push({ x1, y1, x2, y2, age: 0, maxAge: 40 });
    }
    function updateChainLines() {
        for (let i = chainLines.length - 1; i >= 0; i--) {
            chainLines[i].age++;
            if (chainLines[i].age >= chainLines[i].maxAge) chainLines.splice(i, 1);
        }
    }
    function drawChainLines() {
        ctx.globalCompositeOperation = 'lighter';
        for (const cl of chainLines) {
            const a = 0.15 * (1 - cl.age / cl.maxAge);
            ctx.globalAlpha = a;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(cl.x1, cl.y1); ctx.lineTo(cl.x2, cl.y2); ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    // =====================================================================
    // DOT (simplified)
    // =====================================================================
    class Dot {
        constructor(x, y, vx, vy, type) {
            this.type = type || 'standard';
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.active = true;
            this.alpha = 0;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.trail = [];
            this.bloomTimer = 0;
            this._neighbors = 0;
        }
        getHue() {
            if (this.type === 'gravity') return 270;
            if (this.type === 'volatile') return 15;
            return 195 - (this.y / H) * 180;
        }
        update() {
            if (!this.active && this.bloomTimer <= 0) return;
            if (this.bloomTimer > 0) { this.bloomTimer--; return; }
            if (this.alpha < 1) this.alpha = Math.min(1, this.alpha + 0.025);
            this.x += this.vx * slowMo;
            this.y += this.vy * slowMo;
            this.pulsePhase += 0.05;
            // Gravity dots pull nearby dots
            if (this.type === 'gravity' && this.active) {
                const pullR = explosionRadius * DOT_TYPES.gravity.pullRange;
                for (const o of dots) {
                    if (o === this || !o.active) continue;
                    const dist = Math.hypot(o.x - this.x, o.y - this.y);
                    if (dist < pullR && dist > 5) {
                        const f = DOT_TYPES.gravity.pullForce * slowMo / (dist / explosionRadius);
                        o.vx += (this.x - o.x) / dist * f;
                        o.vy += (this.y - o.y) / dist * f;
                    }
                }
            }
            if (this.x < SCREEN_MARGIN) { this.vx = Math.abs(this.vx); this.x = SCREEN_MARGIN; }
            if (this.x > W - SCREEN_MARGIN) { this.vx = -Math.abs(this.vx); this.x = W - SCREEN_MARGIN; }
            if (this.y < SCREEN_MARGIN) { this.vy = Math.abs(this.vy); this.y = SCREEN_MARGIN; }
            if (this.y > H - SCREEN_MARGIN) { this.vy = -Math.abs(this.vy); this.y = H - SCREEN_MARGIN; }
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > DOT_TRAIL_LENGTH) this.trail.shift();
        }
        draw(ctx) {
            if (!this.active && this.bloomTimer <= 0) return;
            const hue = this.getHue();
            const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;
            const r = DOT_RADIUS * pulse;
            const a = this.alpha;
            if (this.bloomTimer > 0) {
                const bt = 1 - this.bloomTimer / 12;
                const br = r * (1 + bt * 5);
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = (1 - bt) * 0.9;
                const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, br);
                g.addColorStop(0, `hsla(${hue}, 70%, 95%, 1)`);
                g.addColorStop(0.3, `hsla(${hue}, 80%, 70%, 0.6)`);
                g.addColorStop(1, `hsla(${hue}, 80%, 60%, 0)`);
                ctx.fillStyle = g;
                ctx.fillRect(this.x-br, this.y-br, br*2, br*2);
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                return;
            }
            // Glow
            ctx.globalCompositeOperation = 'lighter';
            const glowR = DOT_GLOW_SIZE;
            const glowA = a * 0.14;
            const gg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowR);
            gg.addColorStop(0, `hsla(${hue}, 85%, 70%, ${glowA})`);
            gg.addColorStop(0.4, `hsla(${hue}, 80%, 55%, ${glowA * 0.4})`);
            gg.addColorStop(1, `hsla(${hue}, 80%, 50%, 0)`);
            ctx.globalAlpha = 1;
            ctx.fillStyle = gg;
            ctx.fillRect(this.x-glowR, this.y-glowR, glowR*2, glowR*2);
            ctx.globalCompositeOperation = 'source-over';
            // Core
            ctx.globalAlpha = a;
            const cg = ctx.createRadialGradient(this.x-r*0.2, this.y-r*0.2, 0, this.x, this.y, r);
            cg.addColorStop(0, `hsla(${hue}, 60%, 95%, 1)`);
            cg.addColorStop(0.4, `hsla(${hue}, 85%, ${65+pulse*10}%, 1)`);
            cg.addColorStop(1, `hsla(${hue}, 90%, ${45+pulse*10}%, 0.9)`);
            ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI*2);
            ctx.fillStyle = cg; ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // =====================================================================
    // EXPLOSION (simplified)
    // =====================================================================
    class Explosion {
        constructor(x, y, generation, radius, onCaught, parentX, parentY, dotType) {
            this.x = x; this.y = y;
            this.generation = generation;
            this.dotType = dotType || 'standard';
            const typeDef = DOT_TYPES[this.dotType] || DOT_TYPES.standard;
            let baseRadius = radius * typeDef.radiusMult;
            const effectiveGen = Math.min(generation, CASCADE_GEN_CAP);
            if (effectiveGen > 0) baseRadius *= (1 + CASCADE_RADIUS_GROWTH * effectiveGen);
            this.explosionRadius = baseRadius;
            this.holdMs = EXPLOSION_HOLD_MS + (effectiveGen > 0 ? CASCADE_HOLD_GROWTH_MS * effectiveGen : 0);
            this.onCaught = onCaught;
            this.createdAt = performance.now();
            this.phase = 'grow';
            this.radius = 0;
            this.caught = new Set();
            this.hue = this.dotType === 'gravity' ? 270 : this.dotType === 'volatile' ? 15 : 195 - (y / H) * 180;
            this.parentX = parentX; this.parentY = parentY;
            this.shockwaveRadius = 0;
            this.flashAlpha = 1;
        }
        update(now) {
            if (!this._virtualAge) this._virtualAge = 0;
            const realDelta = now - (this._lastNow || this.createdAt);
            this._lastNow = now;
            this._virtualAge += realDelta * slowMo;
            const age = this._virtualAge;
            this.flashAlpha = Math.max(0, 1 - age / 80);
            this.shockwaveRadius = Math.min(this.explosionRadius * 1.6, age * 0.8);
            if (this.phase === 'grow') {
                if (age >= EXPLOSION_GROW_MS) this.phase = 'hold';
                this.radius = this.explosionRadius * easeOutExpo(Math.min(age / EXPLOSION_GROW_MS, 1));
            } else if (this.phase === 'hold') {
                if (age >= EXPLOSION_GROW_MS + this.holdMs) this.phase = 'shrink';
                this.radius = this.explosionRadius;
            } else if (this.phase === 'shrink') {
                const t = (age - EXPLOSION_GROW_MS - this.holdMs) / EXPLOSION_SHRINK_MS;
                if (t >= 1) { this.phase = 'done'; return false; }
                this.radius = this.explosionRadius * (1 - easeInQuad(t));
            }
            if (this.phase === 'grow' || this.phase === 'hold') {
                for (let i = 0; i < dots.length; i++) {
                    const dot = dots[i];
                    if (!dot.active || this.caught.has(i)) continue;
                    if (Math.hypot(dot.x - this.x, dot.y - this.y) <= this.radius) {
                        this.caught.add(i);
                        if (this.onCaught) this.onCaught(dot, i, this.generation, this.x, this.y);
                    }
                }
            }
            return true;
        }
        draw(ctx) {
            if (this.phase === 'done') return;
            const r = Math.max(0.1, this.radius);
            const age = this._virtualAge || 0;
            let alpha = 1;
            if (this.phase === 'shrink') {
                const t = (age - EXPLOSION_GROW_MS - this.holdMs) / EXPLOSION_SHRINK_MS;
                alpha = 1 - easeInQuad(Math.min(t, 1));
            }
            ctx.globalCompositeOperation = 'lighter';
            if (this.generation === 0) {
                // Ripple only
                if (age < 500 && this.shockwaveRadius > 0) {
                    ctx.globalAlpha = 0.5 * (1 - age/500) * alpha;
                    ctx.beginPath(); ctx.arc(this.x, this.y, Math.max(0.1, this.shockwaveRadius), 0, Math.PI*2);
                    ctx.strokeStyle = 'hsla(0,0%,90%,1)'; ctx.lineWidth = 2.5; ctx.stroke();
                }
                if (this.flashAlpha > 0) {
                    ctx.globalAlpha = this.flashAlpha * 0.4;
                    const fr = 8;
                    const fg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, fr);
                    fg.addColorStop(0, 'rgba(255,255,255,0.8)'); fg.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = fg; ctx.fillRect(this.x-fr, this.y-fr, fr*2, fr*2);
                }
                ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over'; return;
            }
            const genBoost = Math.min(0.5, this.generation * 0.08);
            const hue = this.hue + this.generation * 3;
            // Ambient glow
            const ambR = r * (2.5 + genBoost);
            ctx.globalAlpha = alpha * (0.12 + genBoost * 0.15);
            const ag = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, ambR);
            ag.addColorStop(0, `hsla(${hue+10}, 60%, 70%, 1)`);
            ag.addColorStop(0.5, `hsla(${hue}, 50%, 50%, 0.3)`);
            ag.addColorStop(1, `hsla(${hue}, 50%, 40%, 0)`);
            ctx.fillStyle = ag; ctx.fillRect(this.x-ambR, this.y-ambR, ambR*2, ambR*2);
            // Core
            ctx.globalAlpha = alpha * (0.75 + genBoost * 0.2);
            const cg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
            cg.addColorStop(0, `hsla(45, 100%, 95%, 0.9)`);
            cg.addColorStop(0.4, `hsla(${hue+15}, 80%, 65%, 0.3)`);
            cg.addColorStop(1, `hsla(${hue}, 60%, 45%, 0)`);
            ctx.fillStyle = cg; ctx.fillRect(this.x-r, this.y-r, r*2, r*2);
            // Edge ring
            ctx.globalAlpha = alpha * 0.85;
            ctx.beginPath(); ctx.arc(this.x, this.y, Math.max(0.1, r), 0, Math.PI*2);
            ctx.strokeStyle = `hsla(30, 95%, 65%, ${alpha})`; ctx.lineWidth = 2.5; ctx.stroke();
            ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
        }
    }

    // =====================================================================
    // REPLAY ENGINE
    // =====================================================================
    function getMultiplier(chain) {
        let m = 1;
        for (const t of MULT_THRESHOLDS) { if (chain >= t.chain) m = t.mult; }
        return m;
    }

    function handleDotCaught(dot, dotIndex, generation, expX, expY) {
        if (scheduledDetonations.has(dotIndex)) return;
        scheduledDetonations.add(dotIndex);
        detonateDot(dot, dotIndex, generation, expX, expY);
    }

    function detonateDot(dot, dotIndex, generation, parentX, parentY) {
        dot.active = false;
        dot.bloomTimer = 12;
        chainCount++;
        const newMult = getMultiplier(chainCount);
        if (newMult > currentMultiplier) {
            currentMultiplier = newMult;
            spawnFloatingText(W/2, H*0.25, `x${newMult}!`, 50);
        }
        const basePoints = 10 * (generation + 1);
        const points = basePoints * currentMultiplier;
        score += points;
        spawnFloatingText(dot.x, dot.y - 15, `+${points}`, dot.getHue());
        emitParticles(dot.x, dot.y, dot.getHue(), generation);
        if (parentX !== undefined) spawnChainLine(parentX, parentY, dot.x, dot.y);
        shakeTrauma = Math.min(1.0, shakeTrauma + SHAKE_TRAUMA_PER_DOT);
        bgPulse = Math.min(0.3, bgPulse + 0.03);
        if (chainCount >= 15) feverIntensity = Math.min(1.0, feverIntensity + 0.15);
        else if (chainCount >= 5) feverIntensity = Math.min(0.3, feverIntensity + 0.05);
        for (const cel of CELEBRATIONS) {
            if (chainCount === cel.chain && lastCelebration < cel.chain) {
                lastCelebration = cel.chain;
                spawnCelebration(cel.text, cel.hue, cel.size);
                break;
            }
        }
        // Schedule child explosion
        const jitter = (Math.random() - 0.5) * 2 * 25;
        const delay = CASCADE_STAGGER_MS + jitter;
        pendingExplosions.push({
            x: dot.x, y: dot.y,
            generation: generation + 1,
            time: performance.now() + delay,
            parentX: dot.x, parentY: dot.y,
            dotType: dot.type,
        });
    }

    function processEvent(ev) {
        if (ev.type === 'round_start') {
            currentRound = ev.data.round;
            dots = ev.data.dots.map(d => new Dot(d.x, d.y, d.vx, d.vy, d.type));
            explosions = [];
            pendingExplosions = [];
            scheduledDetonations = new Set();
            chainCount = 0;
            score = 0;
            currentMultiplier = 1;
            lastCelebration = -1;
            feverIntensity = 0;
            floatingTexts = [];
            chainLines = [];
            particles.clear();
            document.getElementById('roundInfo').textContent = `Round ${currentRound}`;
        } else if (ev.type === 'tap') {
            const x = ev.data.x, y = ev.data.y;
            const exp = new Explosion(x, y, 0, explosionRadius, handleDotCaught);
            explosions.push(exp);
            // Tap marker
            spawnFloatingText(x, y + 20, 'TAP', 200);
        } else if (ev.type === 'clear') {
            totalScore += score;
            spawnCelebration(`Round ${ev.data.round} Clear!`, 200, 1.4);
            document.getElementById('scoreInfo').textContent = `Score: ${totalScore}`;
        } else if (ev.type === 'fail') {
            spawnCelebration(`Round ${ev.data.round} Failed`, 0, 1.0);
            document.getElementById('scoreInfo').textContent = `Score: ${totalScore + score}`;
        }
    }

    // =====================================================================
    // UPDATE + DRAW
    // =====================================================================
    function update() {
        updateAmbient();
        updateFloatingTexts();
        updateChainLines();
        particles.update();

        const now = performance.now();
        for (let i = pendingExplosions.length - 1; i >= 0; i--) {
            if (now >= pendingExplosions[i].time) {
                const p = pendingExplosions[i];
                explosions.push(new Explosion(p.x, p.y, p.generation, explosionRadius, handleDotCaught, p.parentX, p.parentY, p.dotType));
                pendingExplosions.splice(i, 1);
            }
        }
        for (const d of dots) d.update();
        explosions = explosions.filter(e => e.update(now));

        if (shakeTrauma > 0.001) {
            const s = shakeTrauma * shakeTrauma;
            shakeX = SHAKE_MAX_OFFSET * s * (Math.random()*2-1);
            shakeY = SHAKE_MAX_OFFSET * s * (Math.random()*2-1);
            shakeTrauma *= SHAKE_DECAY;
        } else { shakeX = 0; shakeY = 0; }
        if (bgPulse > 0.001) bgPulse *= 0.93; else bgPulse = 0;
        if (feverIntensity > 0 && explosions.length === 0) feverIntensity = Math.max(0, feverIntensity - 0.008);
        if (screenFlash > 0.005) screenFlash *= 0.78; else screenFlash = 0;
        if (beatPulse > 0.001) beatPulse *= 0.86; else beatPulse = 0;
    }

    function draw() {
        ctx.fillStyle = '#020210';
        ctx.fillRect(0, 0, W, H);
        const bp = bgPulse + beatPulse;
        const bgGrad = ctx.createRadialGradient(W/2, H*0.55, 0, W/2, H*0.55, Math.max(W,H)*0.7);
        bgGrad.addColorStop(0, `rgba(${12+bp*80|0}, ${8+bp*40|0}, ${25+bp*100|0}, 1)`);
        bgGrad.addColorStop(0.5, `rgba(${5+bp*40|0}, ${4+bp*20|0}, ${18+bp*50|0}, 1)`);
        bgGrad.addColorStop(1, 'rgba(2, 2, 12, 1)');
        ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, W, H);
        if (feverIntensity > 0) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = feverIntensity * 0.04;
            const fh = (performance.now() * 0.05) % 360;
            const fg = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.5);
            fg.addColorStop(0, `hsla(${fh}, 80%, 50%, 1)`);
            fg.addColorStop(1, `hsla(${fh+30}, 60%, 30%, 0)`);
            ctx.fillStyle = fg; ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
        }
        if (screenFlash > 0.005) {
            ctx.fillStyle = `rgba(255, 255, 255, ${screenFlash})`;
            ctx.fillRect(0, 0, W, H);
        }
        drawAmbient();
        ctx.save();
        ctx.translate(shakeX, shakeY);
        drawChainLines();
        for (const e of explosions) e.draw(ctx);
        particles.draw(ctx);
        for (const d of dots) d.draw(ctx);
        drawFloatingTexts();
        ctx.restore();

        // HUD
        if (currentRound > 0) {
            const s = Math.max(1, Math.min(W, H) / 600);
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            ctx.font = `400 ${13*s|0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.letterSpacing = '2px'; ctx.fillText('ROUND', W/2, 54*s); ctx.letterSpacing = '0px';
            ctx.font = `300 ${38*s|0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillText(currentRound, W/2, 68*s);
            if (chainCount > 0) {
                ctx.font = `700 ${14*s|0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.fillText(`Chain: ${chainCount}`, W/2, 112*s);
            }
        }
    }

    // =====================================================================
    // MAIN LOOP
    // =====================================================================
    function loop(now) {
        if (playing && events.length > 0) {
            const dt = (now - lastFrameTime) * speed;
            replayTime += dt;

            // Process events up to current replay time
            while (eventIdx < events.length && events[eventIdx].t <= replayTime) {
                processEvent(events[eventIdx]);
                eventIdx++;
            }
        }
        lastFrameTime = now;

        update();
        draw();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // LOAD + CONTROLS
    // =====================================================================
    async function loadReplay() {
        const pathParts = window.location.pathname.split('/');
        const sessionId = pathParts[pathParts.length - 1];
        if (!sessionId) {
            showError('No replay ID in URL');
            return;
        }
        try {
            const res = await fetch(`/api/replay/${sessionId}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            replayData = await res.json();
            events = replayData.events || [];
            if (events.length === 0) {
                showError('Replay has no events');
                return;
            }
            // Populate meta info
            const meta = document.getElementById('metaInfo');
            const name = replayData.player_name || (replayData.is_bot ? 'Bot' : 'Anonymous');
            meta.textContent = `${name} — R${replayData.peak_round} — ${Number(replayData.total_score).toLocaleString()}`;
            document.title = `Replay — ${name} R${replayData.peak_round}`;

            document.getElementById('loading').style.display = 'none';
            document.getElementById('controls').style.display = 'flex';

            // Auto-play
            playing = true;
            lastFrameTime = performance.now();
            document.getElementById('playBtn').textContent = 'Pause';
        } catch (e) {
            showError(`Failed to load replay: ${e.message}`);
        }
    }

    function showError(msg) {
        document.getElementById('loading').style.display = 'none';
        const el = document.getElementById('error');
        el.textContent = msg;
        el.style.display = 'flex';
    }

    // Controls
    document.getElementById('playBtn').addEventListener('click', () => {
        playing = !playing;
        if (playing) lastFrameTime = performance.now();
        document.getElementById('playBtn').textContent = playing ? 'Pause' : 'Play';
    });
    document.getElementById('speed1').addEventListener('click', () => { setSpeed(1); });
    document.getElementById('speed2').addEventListener('click', () => { setSpeed(2); });
    document.getElementById('speed4').addEventListener('click', () => { setSpeed(4); });

    function setSpeed(s) {
        speed = s;
        document.querySelectorAll('#speed1,#speed2,#speed4').forEach(b => b.classList.remove('active'));
        document.getElementById(`speed${s}`).classList.add('active');
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
        if (e.key === ' ') { e.preventDefault(); document.getElementById('playBtn').click(); }
        if (e.key === '1') setSpeed(1);
        if (e.key === '2') setSpeed(2);
        if (e.key === '4') setSpeed(4);
    });

    // Init
    initAmbient();
    requestAnimationFrame(loop);
    loadReplay();

    </script>
</body>
</html>
