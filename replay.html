<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction — Replay</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script src="game-core.js"></script>
    <script src="engine.js"></script>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION — Replay Viewer (uses game-core.js + engine.js)
    //
    // Supports both round-based and continuous replays.
    // Load via: ?file=replay.json (static file) or /replay/{sessionId} (API)
    //
    // Continuous replays are deterministic: same seed → same spawning.
    // Only tap events are recorded. Scrubbing re-creates the game from seed
    // and fast-forwards (~0.3s for 90s of gameplay).
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // REPLAY STATE
    // =====================================================================
    let replayData = null;
    let replayEvents = [];
    let eventIdx = 0;
    let replayTime = 0;
    let totalDuration = 0;
    let playing = false;
    let speed = 1;
    let lastFrameTime = 0;

    let currentRound = 0;
    let totalRounds = 0;
    let totalScore = 0;
    let replayGameState = 'waiting'; // waiting, playing, resolving, ended
    let isContinuous = false;

    let loading = true;
    let errorMsg = null;

    let uiButtons = [];

    // Game instance for physics — replaced on replay load
    let game = new Game(400, 700, {}, Math.random);

    // =====================================================================
    // RESIZE — continuous replays use fixed viewport, CSS-scaled
    // =====================================================================
    function resize() {
        if (isContinuous && replayData) {
            // Fixed viewport matching the replay — uniform CSS scale to fit screen
            const vp = replayData.viewport;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = vp.w * dpr;
            canvas.height = vp.h * dpr;
            // Single scale factor → circles stay circles
            const scale = Math.min(window.innerWidth / vp.w, window.innerHeight / vp.h);
            canvas.style.width = Math.floor(vp.w * scale) + 'px';
            canvas.style.height = Math.floor(vp.h * scale) + 'px';
            W = vp.w;
            H = vp.h;
            refDim = Math.min(W, H, 800);
            const screenMin = Math.min(W, H);
            DOT_RADIUS = Math.max(6, screenMin * 0.014);
            DOT_GLOW_SIZE = Math.max(28, screenMin * 0.06);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        } else {
            engineResize(canvas);
            game.W = W;
            game.H = H;
        }
    }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // COORDINATE MAPPING — screen coords → game coords for input
    // =====================================================================
    function screenToGame(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (clientX - rect.left) / rect.width * W,
            y: (clientY - rect.top) / rect.height * H,
        };
    }

    // =====================================================================
    // SEEK — re-create game from seed and fast-forward to target time
    // =====================================================================
    function seekTo(targetTime) {
        if (!isContinuous || !replayData) return;

        targetTime = Math.max(0, Math.min(targetTime, totalDuration));

        // Re-create deterministic game from seed
        const vp = replayData.viewport;
        game = new Game(vp.w, vp.h, {}, createRNG(replayData.seed));
        game.startContinuous(replayData.tierConfig);

        // Fast-forward: step + apply taps
        const DT = 16.67;
        eventIdx = 0;
        while (game.time < targetTime && !game.overflowed) {
            while (eventIdx < replayEvents.length && replayEvents[eventIdx].t <= game.time) {
                const ev = replayEvents[eventIdx];
                if (ev.type === 'tap') game.tap(ev.data.x, ev.data.y);
                eventIdx++;
            }
            game.step(DT);
            game.events = [];
        }
        // Apply any remaining taps at the exact target time
        while (eventIdx < replayEvents.length && replayEvents[eventIdx].t <= targetTime) {
            const ev = replayEvents[eventIdx];
            if (ev.type === 'tap') game.tap(ev.data.x, ev.data.y);
            eventIdx++;
        }

        replayTime = targetTime;
        engineResetVisuals();
        replayGameState = game.overflowed ? 'ended' : 'playing';
        lastFrameTime = performance.now();
    }

    // =====================================================================
    // REPLAY EVENT PROCESSING
    // =====================================================================
    function processEvent(ev) {
        if (ev.type === 'round_start') {
            currentRound = ev.data.round;
            game.setupRound(ev.data.round);
            game.dots = ev.data.dots.map(d => ({
                x: d.x, y: d.y, vx: d.vx, vy: d.vy,
                active: true, type: d.type || 'standard', bloomTimer: 0,
            }));
            game.totalDots = game.dots.length;
            engineResetVisuals();
            replayGameState = 'playing';
        } else if (ev.type === 'tap') {
            game.tap(ev.data.x, ev.data.y);
            replayGameState = 'resolving';
        } else if (ev.type === 'clear') {
            totalScore += game.score;
            spawnCelebration(`Round ${ev.data.round} Clear!`, 200, 1.4);
        } else if (ev.type === 'fail') {
            spawnCelebration(`Round ${ev.data.round} Failed`, 0, 1.0);
            totalScore += game.score;
            replayGameState = 'ended';
        }
    }

    // =====================================================================
    // UPDATE + DRAW
    // =====================================================================
    function update(dt) {
        // Stop stepping if overflowed or ended
        if (replayGameState === 'ended') {
            engineUpdateVisuals(game);
            return;
        }

        game.step(dt);

        engineProcessEvents(game.events, game);
        game.events = [];
        engineUpdateVisuals(game);

        if (feverIntensity > 0 && game.explosions.length === 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }

        if (replayGameState === 'resolving' && game.gameState !== 'resolving') {
            replayGameState = 'playing';
        }

        if (isContinuous && game.overflowed && replayGameState !== 'ended') {
            replayGameState = 'ended';
            playing = false;
            spawnCelebration('OVERFLOW', 0, 1.6);
        }
    }

    function draw() {
        if (loading) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('Loading replay...', W/2, H/2);
            return;
        }
        if (errorMsg) {
            ctx.fillStyle = '#020210';
            ctx.fillRect(0, 0, W, H);
            drawAmbient(ctx);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 16px Inter, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(255,120,120,0.8)';
            ctx.fillText(errorMsg, W/2, H/2);
            drawNavButtons();
            return;
        }

        const mappedState = replayGameState === 'playing' ? 'playing'
            : replayGameState === 'resolving' ? 'resolving' : 'start';
        engineDrawScene(ctx, game, mappedState, false);

        drawReplayHUD();
        drawNavButtons();
        drawProgressBar();
    }

    function drawReplayHUD() {
        const s = Math.max(1, Math.min(W, H) / 600);

        if (isContinuous) {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const tierNames = { CALM: 'Calm', FLOW: 'Flow', SURGE: 'Surge', TRANSCENDENCE: 'Transcendence', IMPOSSIBLE: 'Impossible' };
            const tierName = tierNames[replayData.tier] || replayData.tier;
            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.letterSpacing = '2px';
            ctx.fillText(tierName.toUpperCase(), W/2, 14 * s);
            ctx.letterSpacing = '0px';

            const secs = Math.floor(replayTime / 1000);
            const mins = Math.floor(secs / 60);
            const remSecs = secs % 60;
            ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillText(`${mins}:${remSecs.toString().padStart(2, '0')}`, W/2, 28 * s);

            const density = game.density();
            if (density > 0) {
                const barW = 80 * s, barH = 4 * s;
                const barX = W/2 - barW/2, barY = 72 * s;
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH, barH/2); ctx.fill();
                const fill = Math.min(1, density);
                const hue = fill < 0.5 ? 200 : fill < 0.7 ? 40 : 0;
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.5)`;
                ctx.beginPath(); ctx.roundRect(barX, barY, barW * fill, barH, barH/2); ctx.fill();
                ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`${(density * 100).toFixed(0)}%`, W/2, barY + barH + 4 * s);
            }

            if (game.chainCount > 0) {
                ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.fillText(`Chain: ${game.chainCount}`, W/2, 92 * s);
                ctx.restore();
            }

            if (game.score > 0) {
                ctx.font = `300 ${11 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Score: ${game.score.toLocaleString()}`, W/2, 110 * s);
            }

            const botNames = { CALM: 'Dumb', FLOW: 'Average', SURGE: 'Good', TRANSCENDENCE: 'Pro', IMPOSSIBLE: 'Inhuman' };
            const botName = botNames[replayData.botProfile] || replayData.botProfile;
            ctx.font = `400 ${9 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255, 255, 100, 0.35)';
            ctx.textAlign = 'left';
            ctx.fillText(`BOT: ${botName}`, 10 * s, 14 * s);
        } else if (currentRound > 0) {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.letterSpacing = '2px';
            ctx.fillText('ROUND', W/2, 14 * s);
            ctx.letterSpacing = '0px';

            ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillText(currentRound, W/2, 28 * s);

            if (totalRounds > 0) {
                ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`of ${totalRounds}`, W/2, 68 * s);
            }

            if (game.chainCount > 0) {
                ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.fillText(`Chain: ${game.chainCount}`, W/2, 84 * s);
                ctx.restore();
            }

            if (totalScore > 0 || game.score > 0) {
                ctx.font = `300 ${11 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Score: ${(totalScore + game.score).toLocaleString()}`, W/2, 100 * s);
            }
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.font = `600 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(100, 180, 255, 0.35)';
        ctx.letterSpacing = '2px';
        ctx.fillText('REPLAY', W - 10 * s, 10 * s);
        ctx.letterSpacing = '0px';

        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    function drawNavButtons() {
        uiButtons = [];
        const s = Math.max(1, Math.min(W, H) / 600);
        const btnY = H - 28 * s;

        const backRect = drawPill(ctx, 50 * s, btnY, '< Game', false, 200);
        uiButtons.push({ id: 'back', ...backRect });

        if (!loading && !errorMsg) {
            const playLabel = playing ? 'Pause' : (replayGameState === 'ended' ? 'Restart' : 'Play');
            const playRect = drawPill(ctx, W/2 - 75 * s, btnY, playLabel, playing, 120);
            uiButtons.push({ id: 'playpause', ...playRect });

            const speeds = [1, 2, 4, 8, 16];
            const speedLabels = ['1x', '2x', '4x', '8x', '16x'];
            for (let i = 0; i < speeds.length; i++) {
                const sx = W/2 + (i * 32 - 30) * s;
                const rect = drawPill(ctx, sx, btnY, speedLabels[i], speed === speeds[i], 45);
                uiButtons.push({ id: `speed_${speeds[i]}`, ...rect });
            }

            if (replayData) {
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = `300 ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                if (isContinuous) {
                    ctx.fillText(`${replayData.tier} · seed ${replayData.seed}`, W - 12 * s, btnY);
                } else {
                    const name = replayData.player_name || (replayData.is_bot ? 'Bot' : 'Anonymous');
                    ctx.fillText(`${name} — R${replayData.peak_round}`, W - 12 * s, btnY);
                }
            }
        }
    }

    function drawProgressBar() {
        if (!replayEvents.length || totalDuration <= 0) return;
        const s = Math.max(1, Math.min(W, H) / 600);
        const barY = H - 48 * s;
        const barX = 12 * s;
        const barW = W - 24 * s;
        const barH = 5 * s;

        // Track
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW, barH, barH / 2);
        ctx.fill();

        // Fill
        const progress = Math.min(1, replayTime / totalDuration);
        if (progress > 0) {
            ctx.fillStyle = 'rgba(100, 180, 255, 0.4)';
            ctx.beginPath();
            ctx.roundRect(barX, barY, barW * progress, barH, barH / 2);
            ctx.fill();
        }

        // Tap markers
        ctx.fillStyle = 'rgba(255, 255, 100, 0.25)';
        for (const ev of replayEvents) {
            if (ev.type !== 'tap') continue;
            const tx = barX + (ev.t / totalDuration) * barW;
            ctx.fillRect(tx - 0.5, barY - 1, 1, barH + 2);
        }

        // Playhead
        const headX = barX + barW * progress;
        ctx.beginPath();
        ctx.arc(headX, barY + barH / 2, 5 * s, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100, 180, 255, 0.7)';
        ctx.fill();

        // Clickable region for scrubbing
        uiButtons.push({ id: 'progressbar', x: barX, y: barY - 10 * s, w: barW, h: barH + 20 * s });
    }

    // =====================================================================
    // MAIN LOOP
    // =====================================================================
    function loop(now) {
        if (playing && replayEvents.length > 0 && !loading && !errorMsg && replayGameState !== 'ended') {
            const dt = (now - lastFrameTime) * speed;
            replayTime += dt;

            // Cap at total duration
            if (replayTime >= totalDuration) {
                replayTime = totalDuration;
                playing = false;
            }

            while (eventIdx < replayEvents.length && replayEvents[eventIdx].t <= replayTime) {
                processEvent(replayEvents[eventIdx]);
                eventIdx++;
            }

            update(Math.min(dt, 50));
        } else {
            update(0);
        }
        lastFrameTime = now;

        draw();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // LOAD REPLAY
    // =====================================================================
    async function loadReplay() {
        const params = new URLSearchParams(window.location.search);
        const file = params.get('file');

        try {
            let data;
            if (file) {
                const res = await fetch(file);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                data = await res.json();
            } else {
                const pathParts = window.location.pathname.split('/');
                const sessionId = pathParts[pathParts.length - 1];
                if (!sessionId) { loading = false; errorMsg = 'No replay ID. Use ?file=replay.json'; return; }
                const res = await fetch(`/api/replay/${sessionId}`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                data = await res.json();
            }

            replayData = data;
            replayEvents = data.events || [];
            if (replayEvents.length === 0) { loading = false; errorMsg = 'Replay has no events'; return; }

            isContinuous = data.mode === 'continuous';

            if (isContinuous) {
                const vp = data.viewport || { w: 390, h: 844 };
                game = new Game(vp.w, vp.h, {}, createRNG(data.seed));
                game.startContinuous(data.tierConfig);
                replayGameState = 'playing';
                totalDuration = data.duration || replayEvents[replayEvents.length - 1].t + 5000;
                document.title = `Replay — ${data.tier} · seed ${data.seed}`;
            } else {
                totalDuration = replayEvents[replayEvents.length - 1].t;
                totalRounds = data.peak_round || 0;
                const name = data.player_name || (data.is_bot ? 'Bot' : 'Anonymous');
                document.title = `Replay — ${name} R${data.peak_round}`;
            }

            // Apply correct viewport for continuous replays
            resize();

            loading = false;
            playing = true;
            lastFrameTime = performance.now();
        } catch (e) {
            loading = false;
            errorMsg = `Failed to load replay: ${e.message}`;
        }
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    function hitTestButtons(gx, gy) {
        for (const btn of uiButtons) {
            if (gx >= btn.x && gx <= btn.x + btn.w && gy >= btn.y && gy <= btn.y + btn.h) {
                return btn;
            }
        }
        return null;
    }

    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        const { x: gx, y: gy } = screenToGame(e.clientX, e.clientY);
        const hit = hitTestButtons(gx, gy);

        if (!hit) return;
        if (hit.id === 'back') { window.location.href = '/'; return; }
        if (hit.id === 'playpause') {
            if (replayGameState === 'ended') {
                // Restart
                seekTo(0);
                playing = true;
            } else {
                playing = !playing;
            }
            if (playing) lastFrameTime = performance.now();
            return;
        }
        if (hit.id && hit.id.startsWith('speed_')) {
            speed = parseInt(hit.id.split('_')[1]);
            return;
        }
        if (hit.id === 'progressbar') {
            const frac = Math.max(0, Math.min(1, (gx - hit.x) / hit.w));
            seekTo(frac * totalDuration);
            return;
        }
    });

    // Drag scrubbing on progress bar
    let scrubbing = false;
    let scrubBtn = null;
    canvas.addEventListener('pointermove', e => {
        if (!scrubbing) return;
        e.preventDefault();
        const { x: gx } = screenToGame(e.clientX, e.clientY);
        const frac = Math.max(0, Math.min(1, (gx - scrubBtn.x) / scrubBtn.w));
        seekTo(frac * totalDuration);
    });
    canvas.addEventListener('pointerdown', e => {
        const { x: gx, y: gy } = screenToGame(e.clientX, e.clientY);
        const hit = hitTestButtons(gx, gy);
        if (hit && hit.id === 'progressbar') {
            scrubbing = true;
            scrubBtn = hit;
        }
    });
    canvas.addEventListener('pointerup', () => { scrubbing = false; });
    canvas.addEventListener('pointercancel', () => { scrubbing = false; });

    document.addEventListener('keydown', e => {
        if (e.key === ' ') {
            e.preventDefault();
            if (replayGameState === 'ended') { seekTo(0); playing = true; }
            else { playing = !playing; }
            if (playing) lastFrameTime = performance.now();
        }
        if (e.key === '1') speed = 1;
        if (e.key === '2') speed = 2;
        if (e.key === '4') speed = 4;
        if (e.key === '8') speed = 8;
        if (e.key === '0') speed = 16;
        if (e.key === 'ArrowLeft') seekTo(replayTime - 5000);
        if (e.key === 'ArrowRight') seekTo(replayTime + 5000);
        if (e.key === 'Escape') window.location.href = '/';
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    requestAnimationFrame(loop);
    loadReplay();

    </script>
</body>
</html>
