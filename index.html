<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: crosshair;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION v3 — Dopamine Edition
    // Simple tap, ascending scale, multiplier, celebrations, bigger radius
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // CONSTANTS
    // =====================================================================

    // Explosion radius — generous! Fun moments should be frequent
    const EXPLOSION_RADIUS_PCT = 0.13;
    const EXPLOSION_RADIUS_MIN_PX = 35;

    // Explosion lifecycle (ms)
    const EXPLOSION_GROW_MS = 200;
    const EXPLOSION_HOLD_MS = 1000;
    const EXPLOSION_SHRINK_MS = 500;
    const TOTAL_EXPLOSION_MS = EXPLOSION_GROW_MS + EXPLOSION_HOLD_MS + EXPLOSION_SHRINK_MS;

    // Cascade timing
    const CASCADE_STAGGER_MS = 80;
    const CASCADE_JITTER_MS = 25;

    // Dots
    let DOT_RADIUS = 5;
    let DOT_GLOW_SIZE = 18;
    const MIN_DOT_DISTANCE = 25;
    const SCREEN_MARGIN = 16;
    const DOT_TRAIL_LENGTH = 8;

    // Particles
    const PARTICLE_POOL_SIZE = 4000;
    const AMBIENT_PARTICLE_COUNT = 120;

    // Screen shake
    const SHAKE_MAX_OFFSET = 14;
    const SHAKE_DECAY = 0.90;
    const SHAKE_TRAUMA_PER_DOT = 0.06;

    // Audio
    const MAX_VOICES = 48;

    // Hit freeze
    const HIT_FREEZE_FRAMES = 3;

    // Ascending pentatonic scale (C3 to A6) — each chain hit goes UP
    const SCALE_NOTES = [
        130.81, 146.83, 164.81, 196.00, 220.00,
        261.63, 293.66, 329.63, 392.00, 440.00,
        523.25, 587.33, 659.25, 783.99, 880.00,
        1046.50, 1174.66, 1318.51, 1567.98, 1760.00,
    ];

    // Multiplier thresholds
    const MULT_THRESHOLDS = [
        { chain: 0, mult: 1 }, { chain: 5, mult: 2 },
        { chain: 10, mult: 3 }, { chain: 15, mult: 4 },
        { chain: 20, mult: 5 }, { chain: 30, mult: 8 },
    ];

    // Celebration milestones
    const CELEBRATIONS = [
        { chain: 5, text: 'NICE!', hue: 50, size: 1.0 },
        { chain: 10, text: 'AMAZING!', hue: 35, size: 1.3 },
        { chain: 15, text: 'INCREDIBLE!', hue: 15, size: 1.6 },
        { chain: 20, text: 'LEGENDARY!', hue: 300, size: 2.0 },
        { chain: 30, text: 'GODLIKE!', hue: 280, size: 2.5 },
    ];

    // =====================================================================
    // EASING
    // =====================================================================
    const easeOutExpo = t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    const easeInQuad = t => t * t;
    const easeOutQuad = t => 1 - (1 - t) * (1 - t);
    const easeOutBack = t => 1 + 2.70158 * Math.pow(t - 1, 3) + 1.70158 * Math.pow(t - 1, 2);
    const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
    const easeInOutCubic = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3) / 2;

    // =====================================================================
    // GLOBALS
    // =====================================================================
    let W, H, refDim;
    let explosionRadius;
    let round = 0;
    let chainCount = 0;
    let score = 0;
    let bestRound = parseInt(localStorage.getItem('cr3_bestRound') || '0', 10);
    let bestScore = parseInt(localStorage.getItem('cr3_bestScore') || '0', 10);
    let gameState = 'start';
    let freezeFrames = 0;
    let bgPulse = 0;
    let shakeTrauma = 0;
    let shakeX = 0, shakeY = 0;
    let floatingTexts = [];
    let chainLines = [];
    let pendingExplosions = [];
    let scheduledDetonations = new Set();
    let gameOverTimer = 0;
    let lastChainFreqs = [];
    let totalScore = 0;

    // Multiplier
    let currentMultiplier = 1;
    let multiplierPulse = 0;

    // Fever (visual intensity during big chains)
    let feverIntensity = 0;
    let lastCelebration = -1;

    // Slow-mo
    let slowMo = 1.0;
    let slowMoTarget = 1.0;

    // Ambient music timer
    let nextAmbientNote = 0;

    // =====================================================================
    // RESIZE
    // =====================================================================
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        refDim = Math.min(W, H, 800);
        const screenMin = Math.min(W, H);
        explosionRadius = Math.max(EXPLOSION_RADIUS_MIN_PX, refDim * EXPLOSION_RADIUS_PCT);
        DOT_RADIUS = Math.max(6, screenMin * 0.014);
        DOT_GLOW_SIZE = Math.max(28, screenMin * 0.06);
    }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // ROUND FORMULA — easier early, generous throughout
    // =====================================================================
    function getRoundParams(r) {
        const dots = Math.min(60, Math.floor(10 + r * 2.5));
        const pct = Math.min(0.80, 0.05 + (r - 1) * 0.028);
        const target = Math.max(1, Math.ceil(dots * pct));
        const speedMin = 0.25 + Math.min(0.25, (r - 1) * 0.01);
        const speedMax = 0.5 + Math.min(0.5, (r - 1) * 0.02);
        return { dots, target, pct, speedMin, speedMax };
    }

    function getMultiplier(chain) {
        let m = 1;
        for (const t of MULT_THRESHOLDS) { if (chain >= t.chain) m = t.mult; }
        return m;
    }

    // =====================================================================
    // AUDIO ENGINE
    // =====================================================================
    const audio = {
        ctx: null,
        masterGain: null,
        compressor: null,
        delayNode: null,
        voices: [],
        droneOsc: null,
        droneGain: null,
        droneFilter: null,
        initialized: false,

        init() {
            if (this.initialized) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.ctx.resume();

            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.6;

            this.compressor = this.ctx.createDynamicsCompressor();
            this.compressor.threshold.value = -18;
            this.compressor.knee.value = 12;
            this.compressor.ratio.value = 6;

            this.delayNode = this._createDelay(0.18, 0.25, 0.18);

            this.masterGain.connect(this.compressor);
            this.compressor.connect(this.delayNode.input);
            this.delayNode.output.connect(this.ctx.destination);

            setTimeout(() => {
                const reverb = this._createReverb(2.0, 3.0, 0.22);
                this.delayNode.output.disconnect();
                this.delayNode.output.connect(reverb.input);
                reverb.output.connect(this.ctx.destination);
            }, 0);

            this._startDrone();
            this.initialized = true;
        },

        // Ascending scale — chain position determines pitch
        playChainNote(chainIndex, generation) {
            if (!this.initialized) return;
            const noteIdx = Math.min(chainIndex, SCALE_NOTES.length - 1);
            const baseFreq = SCALE_NOTES[noteIdx];
            const detune = (Math.random() - 0.5) * 12;
            const freq = baseFreq * Math.pow(2, detune / 1200);
            lastChainFreqs.push(baseFreq);

            const chainBoost = Math.min(1.5, 1 + chainIndex * 0.02);
            let attack, decay, susLvl, susTime, release, vol;
            if (generation === 0) {
                attack = 0.002; decay = 0.05; susLvl = 0.35;
                susTime = 0.1; release = 0.5; vol = 0.18 * chainBoost;
            } else {
                attack = 0.005; decay = 0.04; susLvl = 0.3;
                susTime = 0.06; release = 0.4 + Math.min(0.3, generation * 0.02);
                vol = Math.max(0.06, 0.16 * chainBoost - generation * 0.005);
            }

            this._voicePlay(freq, 'triangle', vol, attack, decay, susLvl, susTime, release);

            if (chainIndex >= 3) {
                this._voicePlay(freq * 2, 'sine', vol * 0.08, 0.003, 0.03, 0.1, 0.02, 0.3);
            }
            if (chainIndex < 3) {
                this._voicePlay(freq * 0.5, 'sine', vol * 0.07, 0.01, 0.06, 0.15, 0.05, 0.4);
            }
            if (chainIndex >= 8) {
                this._voicePlay(freq * 1.5, 'sine', vol * 0.05, 0.008, 0.04, 0.1, 0.03, 0.35);
            }
        },

        playAmbientNote() {
            if (!this.initialized) return;
            const noteIdx = 5 + Math.floor(Math.random() * 5);
            this._voicePlay(SCALE_NOTES[noteIdx], 'sine', 0.02, 0.4, 0.2, 0.3, 0.4, 2.0);
            if (Math.random() < 0.3) {
                const lowIdx = Math.floor(Math.random() * 5);
                this._voicePlay(SCALE_NOTES[lowIdx], 'sine', 0.015, 0.5, 0.3, 0.2, 0.5, 2.5);
            }
        },

        playMiss() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const buf = c.createBuffer(1, Math.floor(c.sampleRate * 0.08), c.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (c.sampleRate * 0.02));
            const src = c.createBufferSource(); src.buffer = buf;
            const f = c.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 600;
            const g = c.createGain();
            g.gain.setValueAtTime(0.0001, now);
            g.gain.linearRampToValueAtTime(0.06, now + 0.002);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.06);
            src.connect(f); f.connect(g); g.connect(this.ctx.destination);
            src.start(now); src.stop(now + 0.08);
            src.onended = () => { src.disconnect(); f.disconnect(); g.disconnect(); };
        },

        playTap() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const osc = c.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
            const g = c.createGain();
            g.gain.setValueAtTime(0.15, now);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
            osc.connect(g); g.connect(this.masterGain);
            osc.start(now); osc.stop(now + 0.2);
            osc.onended = () => { osc.disconnect(); g.disconnect(); };
        },

        playCelebration(level) {
            if (!this.initialized) return;
            const baseIdx = Math.min(10, level * 2);
            for (let i = 0; i < 4; i++) {
                const idx = Math.min(SCALE_NOTES.length - 1, baseIdx + i);
                setTimeout(() => {
                    this._voicePlay(SCALE_NOTES[idx], 'sine', 0.14, 0.01, 0.08, 0.6, 0.15, 1.2);
                    this._voicePlay(SCALE_NOTES[idx] * 2, 'sine', 0.04, 0.02, 0.05, 0.3, 0.1, 0.8);
                }, i * 80);
            }
        },

        playRoundClear() {
            if (!this.initialized) return;
            const chord = [
                SCALE_NOTES[5], SCALE_NOTES[7], SCALE_NOTES[8],
                SCALE_NOTES[10], SCALE_NOTES[12],
            ];
            chord.forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'sine', 0.12, 0.15, 0.1, 0.7, 1.0, 2.0);
                    this._voicePlay(f * 2, 'sine', 0.03, 0.2, 0.08, 0.4, 0.8, 1.5);
                }, i * 60);
            });
        },

        playGameOver() {
            if (!this.initialized) return;
            [220, 196, 164.81].forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'triangle', 0.10, 0.1, 0.15, 0.5, 0.3, 1.5);
                }, i * 150);
            });
        },

        _startDrone() {
            const c = this.ctx;
            this.droneOsc = c.createOscillator();
            this.droneOsc.type = 'sine';
            this.droneOsc.frequency.value = SCALE_NOTES[0];

            this.droneFilter = c.createBiquadFilter();
            this.droneFilter.type = 'lowpass';
            this.droneFilter.frequency.value = 200;
            this.droneFilter.Q.value = 1;

            this.droneGain = c.createGain();
            this.droneGain.gain.value = 0;

            const drone2 = c.createOscillator();
            drone2.type = 'sine';
            drone2.frequency.value = SCALE_NOTES[0] * 1.5;

            this.droneOsc.connect(this.droneFilter);
            drone2.connect(this.droneFilter);
            this.droneFilter.connect(this.droneGain);
            this.droneGain.connect(this.masterGain);

            this.droneOsc.start();
            drone2.start();

            const lfo = c.createOscillator();
            lfo.type = 'sine'; lfo.frequency.value = 0.1;
            const lfoG = c.createGain(); lfoG.gain.value = 100;
            lfo.connect(lfoG); lfoG.connect(this.droneFilter.frequency);
            lfo.start();
        },

        updateDrone(state, intensity) {
            if (!this.droneGain) return;
            const now = this.ctx.currentTime;
            let vol = 0;
            if (state === 'playing') vol = 0.02;
            else if (state === 'resolving') vol = 0.03 + intensity * 0.03;
            else if (state === 'gameover') vol = 0.01;
            this.droneGain.gain.setTargetAtTime(vol, now, 0.3);
            const freq = state === 'resolving' ? 300 + intensity * 400 : 200;
            this.droneFilter.frequency.setTargetAtTime(freq, now, 0.3);
        },

        _voicePlay(freq, type, vol, attack, decay, susLvl, susTime, release) {
            while (this.voices.length >= MAX_VOICES) {
                const old = this.voices.shift();
                try {
                    old.gain.gain.setValueAtTime(old.gain.gain.value, this.ctx.currentTime);
                    old.gain.gain.linearRampToValueAtTime(0.0001, this.ctx.currentTime + 0.005);
                    old.osc.stop(this.ctx.currentTime + 0.01);
                } catch(e) {}
            }
            const c = this.ctx; const now = c.currentTime;
            const osc = c.createOscillator();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, now);
            const env = c.createGain();
            env.gain.setValueAtTime(0.0001, now);
            env.gain.linearRampToValueAtTime(vol, now + attack);
            env.gain.linearRampToValueAtTime(vol * susLvl, now + attack + decay);
            const relStart = now + attack + decay + susTime;
            env.gain.setValueAtTime(vol * susLvl, relStart);
            env.gain.exponentialRampToValueAtTime(0.0001, relStart + release);
            osc.connect(env); env.connect(this.masterGain);
            osc.start(now); osc.stop(relStart + release + 0.05);
            const voice = { osc, gain: env };
            this.voices.push(voice);
            osc.onended = () => {
                osc.disconnect(); env.disconnect();
                const idx = this.voices.indexOf(voice);
                if (idx !== -1) this.voices.splice(idx, 1);
            };
        },

        _createDelay(time, feedback, wet) {
            const c = this.ctx;
            const input = c.createGain(), output = c.createGain();
            const delay = c.createDelay(2.0), fb = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            const filt = c.createBiquadFilter();
            delay.delayTime.value = time; fb.gain.value = feedback;
            wetG.gain.value = wet; dryG.gain.value = 1.0;
            filt.type = 'lowpass'; filt.frequency.value = 2500;
            input.connect(dryG); dryG.connect(output);
            input.connect(delay); delay.connect(filt); filt.connect(fb); fb.connect(delay);
            delay.connect(wetG); wetG.connect(output);
            return { input, output };
        },

        _createReverb(dur, dec, mix) {
            const c = this.ctx;
            const len = Math.floor(c.sampleRate * dur);
            const buf = c.createBuffer(2, len, c.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const d = buf.getChannelData(ch);
                for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-dec * (i / c.sampleRate));
            }
            const conv = c.createConvolver(); conv.buffer = buf;
            const input = c.createGain(), output = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            wetG.gain.value = mix; dryG.gain.value = 1.0;
            input.connect(dryG); dryG.connect(output);
            input.connect(conv); conv.connect(wetG); wetG.connect(output);
            return { input, output };
        }
    };

    // =====================================================================
    // PARTICLE POOL
    // =====================================================================
    const particles = {
        x: new Float32Array(PARTICLE_POOL_SIZE),
        y: new Float32Array(PARTICLE_POOL_SIZE),
        vx: new Float32Array(PARTICLE_POOL_SIZE),
        vy: new Float32Array(PARTICLE_POOL_SIZE),
        life: new Float32Array(PARTICLE_POOL_SIZE),
        maxLife: new Float32Array(PARTICLE_POOL_SIZE),
        hue: new Float32Array(PARTICLE_POOL_SIZE),
        size: new Float32Array(PARTICLE_POOL_SIZE),
        friction: new Float32Array(PARTICLE_POOL_SIZE),
        gravity: new Float32Array(PARTICLE_POOL_SIZE),
        count: 0,

        spawn(x, y, vx, vy, life, hue, size, friction, gravity) {
            if (this.count >= PARTICLE_POOL_SIZE) return;
            const i = this.count;
            this.x[i] = x; this.y[i] = y;
            this.vx[i] = vx; this.vy[i] = vy;
            this.life[i] = life; this.maxLife[i] = life;
            this.hue[i] = hue; this.size[i] = size;
            this.friction[i] = friction; this.gravity[i] = gravity;
            this.count++;
        },

        update() {
            let i = 0;
            while (i < this.count) {
                this.vx[i] *= this.friction[i];
                this.vy[i] *= this.friction[i];
                this.vy[i] += this.gravity[i];
                this.x[i] += this.vx[i];
                this.y[i] += this.vy[i];
                this.life[i]--;
                if (this.life[i] <= 0) {
                    this.count--;
                    if (i < this.count) {
                        this.x[i] = this.x[this.count]; this.y[i] = this.y[this.count];
                        this.vx[i] = this.vx[this.count]; this.vy[i] = this.vy[this.count];
                        this.life[i] = this.life[this.count]; this.maxLife[i] = this.maxLife[this.count];
                        this.hue[i] = this.hue[this.count]; this.size[i] = this.size[this.count];
                        this.friction[i] = this.friction[this.count]; this.gravity[i] = this.gravity[this.count];
                    }
                } else { i++; }
            }
        },

        draw(ctx) {
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < this.count; i++) {
                const a = this.life[i] / this.maxLife[i];
                const s = this.size[i] * (0.4 + a * 0.6);
                const alpha = a * a;
                if (alpha < 0.01) continue;
                ctx.globalAlpha = alpha;
                const h = this.hue[i];
                if (s > 3) {
                    const gr = s * 2;
                    const grd = ctx.createRadialGradient(this.x[i], this.y[i], 0, this.x[i], this.y[i], gr);
                    grd.addColorStop(0, `hsla(${h}, 100%, ${70 + a * 20}%, 0.7)`);
                    grd.addColorStop(0.5, `hsla(${h}, 90%, ${55 + a * 15}%, 0.15)`);
                    grd.addColorStop(1, `hsla(${h}, 80%, 50%, 0)`);
                    ctx.fillStyle = grd;
                    ctx.fillRect(this.x[i] - gr, this.y[i] - gr, gr * 2, gr * 2);
                } else {
                    ctx.fillStyle = `hsl(${h}, 100%, ${60 + a * 25}%)`;
                    ctx.fillRect(this.x[i] - s * 0.5, this.y[i] - s * 0.5, s, s);
                }
            }
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        },

        clear() { this.count = 0; }
    };

    function emitParticles(x, y, hue, gen) {
        const burstN = Math.max(4, 14 - Math.floor(gen / 3));
        const driftN = Math.max(2, 8 - Math.floor(gen / 2));
        const sparkN = Math.max(0, 6 - gen);
        const emberN = gen < 6 ? 3 : 1;

        for (let i = 0; i < burstN; i++) {
            const a = (Math.PI * 2 * i) / burstN + (Math.random() - 0.5) * 0.5;
            const spd = 3.5 + Math.random() * 5;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                22 + Math.random()*18, hue + (Math.random()-0.5)*30, 2 + Math.random()*3, 0.92, 0.04);
        }
        for (let i = 0; i < driftN; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 0.8 + Math.random() * 1.5;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                50 + Math.random()*35, hue + (Math.random()-0.5)*20, 3.5 + Math.random()*4, 0.97, -0.025);
        }
        for (let i = 0; i < sparkN; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 7 + Math.random() * 9;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                8 + Math.random()*8, hue + 30, 1 + Math.random()*0.8, 0.88, 0.12);
        }
        for (let i = 0; i < emberN; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 0.3 + Math.random() * 0.6;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                100 + Math.random()*60, hue, 1.5 + Math.random(), 0.99, -0.008);
        }
    }

    function emitCelebrationBurst(x, y, hue, count) {
        for (let i = 0; i < count; i++) {
            const a = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.4;
            const spd = 5 + Math.random() * 10;
            const h = hue + (Math.random() - 0.5) * 60;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                35 + Math.random()*25, h, 3 + Math.random()*5, 0.94, 0.03);
        }
    }

    // =====================================================================
    // AMBIENT BACKGROUND
    // =====================================================================
    const ambientStars = [];
    function initAmbient() {
        ambientStars.length = 0;
        for (let i = 0; i < AMBIENT_PARTICLE_COUNT; i++) {
            const isBright = Math.random() < 0.15;
            ambientStars.push({
                x: Math.random() * W, y: Math.random() * H,
                vx: (Math.random() - 0.5) * 0.12,
                vy: (Math.random() - 0.5) * 0.12,
                size: isBright ? (1.5 + Math.random() * 2) : (0.5 + Math.random() * 1.8),
                alpha: isBright ? (0.15 + Math.random() * 0.2) : (0.04 + Math.random() * 0.12),
                phase: Math.random() * Math.PI * 2,
                hue: isBright ? (180 + Math.random() * 60) : 220,
            });
        }
    }

    function updateAmbient() {
        for (const s of ambientStars) {
            s.x += s.vx; s.y += s.vy; s.phase += 0.008;
            if (s.x < 0) s.x = W; if (s.x > W) s.x = 0;
            if (s.y < 0) s.y = H; if (s.y > H) s.y = 0;
        }
    }

    function drawAmbient() {
        ctx.globalCompositeOperation = 'lighter';
        for (const s of ambientStars) {
            const a = s.alpha * (0.5 + 0.5 * Math.sin(s.phase));
            if (a < 0.01) continue;
            ctx.globalAlpha = a;
            if (s.size > 2) {
                const gr = s.size * 3;
                const grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, gr);
                grd.addColorStop(0, `hsla(${s.hue}, 40%, 80%, 0.6)`);
                grd.addColorStop(0.3, `hsla(${s.hue}, 30%, 70%, 0.15)`);
                grd.addColorStop(1, `hsla(${s.hue}, 30%, 60%, 0)`);
                ctx.fillStyle = grd;
                ctx.fillRect(s.x - gr, s.y - gr, gr * 2, gr * 2);
            }
            ctx.fillStyle = `hsla(${s.hue}, 30%, 85%, 1)`;
            ctx.fillRect(s.x - s.size * 0.5, s.y - s.size * 0.5, s.size, s.size);
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    // =====================================================================
    // FLOATING TEXT
    // =====================================================================
    function spawnFloatingText(x, y, text, hue) {
        floatingTexts.push({ x, y, text, hue, age: 0, maxAge: 50 });
    }

    function spawnCelebration(text, hue, scale) {
        floatingTexts.push({
            x: W/2, y: H * 0.35, text, hue,
            age: 0, maxAge: 90, scale: scale || 1, celebration: true
        });
        emitCelebrationBurst(W/2, H/2, hue, Math.floor(30 * (scale || 1)));
        shakeTrauma = Math.min(1.0, shakeTrauma + 0.25 * (scale || 1));
        bgPulse = Math.min(0.4, bgPulse + 0.1 * (scale || 1));
    }

    function updateFloatingTexts() {
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            const ft = floatingTexts[i];
            ft.age++;
            const drift = ft.celebration ? 0.5 : 1.5;
            ft.y -= drift * (1 - ft.age / ft.maxAge);
            if (ft.age >= ft.maxAge) floatingTexts.splice(i, 1);
        }
    }

    function drawFloatingTexts() {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const baseSize = Math.max(14, Math.min(W, H) * 0.022);
        for (const ft of floatingTexts) {
            const a = 1 - easeInQuad(ft.age / ft.maxAge);

            if (ft.celebration) {
                const entryScale = easeOutBack(Math.min(1, ft.age / 12));
                const sz = Math.round(baseSize * 3 * (ft.scale || 1) * entryScale);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.shadowColor = `hsla(${ft.hue}, 90%, 60%, 0.8)`;
                ctx.shadowBlur = 20;
                ctx.font = `900 ${sz}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${ft.hue}, 90%, 75%)`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.shadowBlur = 40;
                ctx.globalAlpha = a * 0.5;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            } else {
                const scale = 0.8 + 0.4 * easeOutBack(Math.min(1, ft.age / 8));
                const sz = Math.round(baseSize * scale);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.shadowColor = `hsla(${ft.hue}, 80%, 60%, 0.5)`;
                ctx.shadowBlur = 8;
                ctx.font = `600 ${sz}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${ft.hue}, 80%, 78%)`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            }
        }
        ctx.globalAlpha = 1;
    }

    // =====================================================================
    // CHAIN LINES
    // =====================================================================
    function spawnChainLine(x1, y1, x2, y2) {
        chainLines.push({ x1, y1, x2, y2, age: 0, maxAge: 40 });
    }
    function updateChainLines() {
        for (let i = chainLines.length - 1; i >= 0; i--) {
            chainLines[i].age++;
            if (chainLines[i].age >= chainLines[i].maxAge) chainLines.splice(i, 1);
        }
    }
    function drawChainLines() {
        ctx.globalCompositeOperation = 'lighter';
        for (const cl of chainLines) {
            const a = 0.15 * (1 - cl.age / cl.maxAge);
            ctx.globalAlpha = a;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(cl.x1, cl.y1);
            ctx.lineTo(cl.x2, cl.y2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    // =====================================================================
    // DOT
    // =====================================================================
    class Dot {
        constructor(x, y, speedMin, speedMax) {
            this.x = x; this.y = y;
            const a = Math.random() * Math.PI * 2;
            const spd = speedMin + Math.random() * (speedMax - speedMin);
            this.vx = Math.cos(a) * spd;
            this.vy = Math.sin(a) * spd;
            this.active = true;
            this.alpha = 0;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.trail = [];
            this.bloomTimer = 0;
            this.nearMiss = 0;
        }

        getHue() { return 195 - (this.y / H) * 180; }

        update() {
            if (!this.active && this.bloomTimer <= 0) return;
            if (this.bloomTimer > 0) { this.bloomTimer--; return; }
            if (this.alpha < 1) this.alpha = Math.min(1, this.alpha + 0.025);

            this.x += this.vx * slowMo;
            this.y += this.vy * slowMo;
            this.pulsePhase += 0.05;

            if (this.x < SCREEN_MARGIN) { this.vx = Math.abs(this.vx); this.x = SCREEN_MARGIN; }
            if (this.x > W - SCREEN_MARGIN) { this.vx = -Math.abs(this.vx); this.x = W - SCREEN_MARGIN; }
            if (this.y < SCREEN_MARGIN) { this.vy = Math.abs(this.vy); this.y = SCREEN_MARGIN; }
            if (this.y > H - SCREEN_MARGIN) { this.vy = -Math.abs(this.vy); this.y = H - SCREEN_MARGIN; }

            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > DOT_TRAIL_LENGTH) this.trail.shift();

            if (this.nearMiss > 0) this.nearMiss = Math.max(0, this.nearMiss - 0.012);
        }

        draw(ctx) {
            if (!this.active && this.bloomTimer <= 0) return;
            const hue = this.getHue();
            const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;
            const r = DOT_RADIUS * pulse;
            const a = this.alpha;

            if (this.bloomTimer > 0) {
                const bt = 1 - this.bloomTimer / 12;
                const br = r * (1 + bt * 5);
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = (1 - bt) * 0.9;
                const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, br);
                g.addColorStop(0, `hsla(${hue}, 70%, 95%, 1)`);
                g.addColorStop(0.3, `hsla(${hue}, 80%, 70%, 0.6)`);
                g.addColorStop(1, `hsla(${hue}, 80%, 60%, 0)`);
                ctx.fillStyle = g;
                ctx.fillRect(this.x - br, this.y - br, br * 2, br * 2);
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                return;
            }

            // Trail
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < this.trail.length - 1; i++) {
                const t = this.trail[i];
                const tp = (i + 1) / this.trail.length;
                ctx.globalAlpha = a * tp * 0.12;
                const ts = r * tp * 0.8;
                const tg = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, ts * 2);
                tg.addColorStop(0, `hsla(${hue}, 70%, 60%, 0.5)`);
                tg.addColorStop(1, `hsla(${hue}, 70%, 60%, 0)`);
                ctx.fillStyle = tg;
                ctx.fillRect(t.x - ts * 2, t.y - ts * 2, ts * 4, ts * 4);
            }

            // Outer glow
            const glowR = DOT_GLOW_SIZE;
            const glowA = a * (0.14 + pulse * 0.08);
            const gg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowR);
            gg.addColorStop(0, `hsla(${hue}, 85%, 70%, ${glowA})`);
            gg.addColorStop(0.4, `hsla(${hue}, 80%, 55%, ${glowA * 0.4})`);
            gg.addColorStop(1, `hsla(${hue}, 80%, 50%, 0)`);
            ctx.globalAlpha = 1;
            ctx.fillStyle = gg;
            ctx.fillRect(this.x - glowR, this.y - glowR, glowR * 2, glowR * 2);
            ctx.globalCompositeOperation = 'source-over';

            // Core
            ctx.globalAlpha = a;
            const cg = ctx.createRadialGradient(this.x - r * 0.2, this.y - r * 0.2, 0, this.x, this.y, r);
            cg.addColorStop(0, `hsla(${hue}, 60%, 95%, 1)`);
            cg.addColorStop(0.4, `hsla(${hue}, 85%, ${65 + pulse * 10}%, 1)`);
            cg.addColorStop(1, `hsla(${hue}, 90%, ${45 + pulse * 10}%, 0.9)`);
            ctx.beginPath();
            ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
            ctx.fillStyle = cg;
            ctx.fill();

            // Near-miss red pulse
            if (this.nearMiss > 0) {
                const nmP = Math.sin(performance.now() * 0.012) * 0.3 + 0.7;
                const nmR = DOT_GLOW_SIZE * 1.2;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.nearMiss * nmP * 0.25;
                const ng = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, nmR);
                ng.addColorStop(0, 'hsla(0, 90%, 60%, 0.6)');
                ng.addColorStop(0.5, 'hsla(0, 80%, 50%, 0.15)');
                ng.addColorStop(1, 'hsla(0, 70%, 40%, 0)');
                ctx.fillStyle = ng;
                ctx.fillRect(this.x - nmR, this.y - nmR, nmR * 2, nmR * 2);
                ctx.globalCompositeOperation = 'source-over';
            }
            ctx.globalAlpha = 1;
        }
    }

    // =====================================================================
    // EXPLOSION
    // =====================================================================
    class Explosion {
        constructor(x, y, generation, radius, onCaught, parentX, parentY) {
            this.x = x; this.y = y;
            this.generation = generation;
            this.explosionRadius = radius;
            this.onCaught = onCaught;
            this.createdAt = performance.now();
            this.phase = 'grow';
            this.radius = 0;
            this.caught = new Set();
            this.hue = 195 - (y / H) * 180;
            this.parentX = parentX;
            this.parentY = parentY;
            this.shockwaveRadius = 0;
            this.flashAlpha = 1;
        }

        update(now) {
            if (!this._virtualAge) this._virtualAge = 0;
            const realDelta = now - (this._lastNow || this.createdAt);
            this._lastNow = now;
            this._virtualAge += realDelta * slowMo;
            const age = this._virtualAge;

            this.flashAlpha = Math.max(0, 1 - age / 80);
            this.shockwaveRadius = Math.min(this.explosionRadius * 1.6, age * 0.8);

            if (this.phase === 'grow') {
                if (age >= EXPLOSION_GROW_MS) this.phase = 'hold';
                this.radius = this.explosionRadius * easeOutExpo(Math.min(age / EXPLOSION_GROW_MS, 1));
            } else if (this.phase === 'hold') {
                if (age >= EXPLOSION_GROW_MS + EXPLOSION_HOLD_MS) this.phase = 'shrink';
                this.radius = this.explosionRadius;
            } else if (this.phase === 'shrink') {
                const t = (age - EXPLOSION_GROW_MS - EXPLOSION_HOLD_MS) / EXPLOSION_SHRINK_MS;
                if (t >= 1) { this.phase = 'done'; return false; }
                this.radius = this.explosionRadius * (1 - easeInQuad(t));
            }

            if (this.phase === 'grow' || this.phase === 'hold') {
                for (let i = 0; i < dots.length; i++) {
                    const dot = dots[i];
                    if (!dot.active || this.caught.has(i)) continue;
                    if (Math.hypot(dot.x - this.x, dot.y - this.y) <= this.radius) {
                        this.caught.add(i);
                        if (this.onCaught) this.onCaught(dot, i, this.generation, this.x, this.y);
                    }
                }
            }
            return true;
        }

        draw(ctx) {
            if (this.phase === 'done') return;
            const r = Math.max(0.1, this.radius);
            const age = this._virtualAge || 0;
            let alpha = 1;
            if (this.phase === 'shrink') {
                const t = (age - EXPLOSION_GROW_MS - EXPLOSION_HOLD_MS) / EXPLOSION_SHRINK_MS;
                alpha = 1 - easeInQuad(Math.min(t, 1));
            }

            ctx.globalCompositeOperation = 'lighter';

            // Ambient glow
            const ambR = r * 2.5;
            ctx.globalAlpha = alpha * 0.12;
            const ag = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, ambR);
            ag.addColorStop(0, `hsla(${this.hue + 10}, 60%, 70%, 1)`);
            ag.addColorStop(0.5, `hsla(${this.hue}, 50%, 50%, 0.3)`);
            ag.addColorStop(1, `hsla(${this.hue}, 50%, 40%, 0)`);
            ctx.fillStyle = ag;
            ctx.fillRect(this.x - ambR, this.y - ambR, ambR * 2, ambR * 2);

            // Flash
            if (this.flashAlpha > 0) {
                ctx.globalAlpha = this.flashAlpha * 0.7;
                const fr = r * 0.6 * (1 + (1 - this.flashAlpha) * 0.8);
                const fg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, fr);
                fg.addColorStop(0, '#ffffffee');
                fg.addColorStop(0.5, `hsla(50, 100%, 90%, 0.5)`);
                fg.addColorStop(1, `hsla(50, 100%, 80%, 0)`);
                ctx.fillStyle = fg;
                ctx.fillRect(this.x - fr, this.y - fr, fr * 2, fr * 2);
            }

            // Shockwave
            if (age < 400 && this.shockwaveRadius > 0) {
                ctx.globalAlpha = 0.45 * (1 - age / 400);
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0.1, this.shockwaveRadius), 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${this.hue}, 70%, 85%, 1)`;
                ctx.lineWidth = 2.5;
                ctx.stroke();
            }

            // Core
            ctx.globalAlpha = alpha * 0.75;
            const cg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
            cg.addColorStop(0, `hsla(45, 100%, 95%, 0.9)`);
            cg.addColorStop(0.15, `hsla(40, 95%, 80%, 0.6)`);
            cg.addColorStop(0.4, `hsla(${this.hue + 15}, 80%, 65%, 0.3)`);
            cg.addColorStop(0.7, `hsla(${this.hue}, 70%, 55%, 0.1)`);
            cg.addColorStop(1, `hsla(${this.hue}, 60%, 45%, 0)`);
            ctx.fillStyle = cg;
            ctx.fillRect(this.x - r, this.y - r, r * 2, r * 2);

            // Edge ring
            ctx.globalAlpha = alpha * 0.85;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Math.max(0.1, r), 0, Math.PI * 2);
            ctx.strokeStyle = `hsla(30, 95%, 65%, ${alpha})`;
            ctx.lineWidth = 2.5;
            ctx.stroke();

            // Inner core
            ctx.globalAlpha = alpha * 0.8;
            const cr = r * 0.2;
            const ig = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, cr);
            ig.addColorStop(0, `hsla(50, 100%, 97%, 1)`);
            ig.addColorStop(1, `hsla(45, 90%, 80%, 0)`);
            ctx.fillStyle = ig;
            ctx.fillRect(this.x - cr, this.y - cr, cr * 2, cr * 2);

            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    // =====================================================================
    // GAME STATE
    // =====================================================================
    let dots = [];
    let explosions = [];

    function generateDots(count, speedMin, speedMax) {
        dots = [];
        let attempts = 0;
        const topMargin = SCREEN_MARGIN + 50;
        while (dots.length < count && attempts < 5000) {
            const x = SCREEN_MARGIN + Math.random() * (W - SCREEN_MARGIN * 2);
            const y = topMargin + Math.random() * (H - topMargin - SCREEN_MARGIN);
            let valid = true;
            for (const d of dots) {
                if (Math.hypot(d.x - x, d.y - y) < MIN_DOT_DISTANCE) { valid = false; break; }
            }
            if (valid) dots.push(new Dot(x, y, speedMin, speedMax));
            attempts++;
        }
    }

    function startRound() {
        const params = getRoundParams(round);
        generateDots(params.dots, params.speedMin, params.speedMax);
        explosions = [];
        scheduledDetonations = new Set();
        pendingExplosions = [];
        chainLines = [];
        floatingTexts = [];
        particles.clear();
        chainCount = 0;
        score = 0;
        lastChainFreqs = [];
        shakeTrauma = 0;
        bgPulse = 0;
        slowMo = 1.0;
        slowMoTarget = 1.0;
        currentMultiplier = 1;
        multiplierPulse = 0;
        feverIntensity = 0;
        lastCelebration = -1;
        gameState = 'playing';
    }

    function detonateDot(dot, dotIndex, generation, parentX, parentY) {
        dot.active = false;
        dot.bloomTimer = 12;
        chainCount++;

        // Multiplier check
        const newMult = getMultiplier(chainCount);
        if (newMult > currentMultiplier) {
            currentMultiplier = newMult;
            multiplierPulse = 1.0;
            spawnFloatingText(W/2, H * 0.25, `x${newMult}!`, 50);
        }

        // Score with multiplier
        const basePoints = 10 * (generation + 1);
        const points = basePoints * currentMultiplier;
        score += points;

        // Ascending scale audio
        audio.playChainNote(chainCount - 1, generation);

        spawnFloatingText(dot.x, dot.y - 15, `+${points}`, dot.getHue());
        emitParticles(dot.x, dot.y, dot.getHue(), generation);

        if (parentX !== undefined && parentY !== undefined) {
            spawnChainLine(parentX, parentY, dot.x, dot.y);
        }

        shakeTrauma = Math.min(1.0, shakeTrauma + SHAKE_TRAUMA_PER_DOT);
        bgPulse = Math.min(0.3, bgPulse + 0.03);

        // Fever intensity
        if (chainCount >= 15) feverIntensity = Math.min(1.0, feverIntensity + 0.15);
        else if (chainCount >= 10) feverIntensity = Math.min(0.6, feverIntensity + 0.1);
        else if (chainCount >= 5) feverIntensity = Math.min(0.3, feverIntensity + 0.05);

        // Slow-mo on big chains
        if (chainCount >= 5 && slowMo > 0.45) {
            slowMoTarget = 0.4;
        }

        // Celebrations
        for (const cel of CELEBRATIONS) {
            if (chainCount === cel.chain && lastCelebration < cel.chain) {
                lastCelebration = cel.chain;
                spawnCelebration(cel.text, cel.hue, cel.size);
                audio.playCelebration(CELEBRATIONS.indexOf(cel));
                break;
            }
        }

        // Schedule child explosion
        const delay = CASCADE_STAGGER_MS + (Math.random() - 0.5) * 2 * CASCADE_JITTER_MS;
        pendingExplosions.push({
            x: dot.x, y: dot.y,
            generation: generation + 1,
            time: performance.now() + delay,
            parentX: dot.x, parentY: dot.y,
        });
    }

    function handleDotCaught(dot, dotIndex, generation, expX, expY) {
        if (scheduledDetonations.has(dotIndex)) return;
        scheduledDetonations.add(dotIndex);
        detonateDot(dot, dotIndex, generation, expX, expY);
    }

    // Simple tap — no charge mechanic
    function handleTap(x, y) {
        if (gameState === 'start') {
            audio.init();
            round = 1;
            totalScore = 0;
            startRound();
            return;
        }

        if (gameState === 'gameover') {
            round = 1;
            totalScore = 0;
            startRound();
            return;
        }

        if (gameState !== 'playing') return;

        audio.init();
        audio.playTap();

        gameState = 'resolving';
        freezeFrames = HIT_FREEZE_FRAMES;

        const exp = new Explosion(x, y, 0, explosionRadius, handleDotCaught);
        explosions.push(exp);

        let hitAny = false;
        for (const dot of dots) {
            if (dot.active && Math.hypot(dot.x - x, dot.y - y) <= explosionRadius) {
                hitAny = true; break;
            }
        }
        if (!hitAny) audio.playMiss();
    }

    function checkRoundEnd() {
        if (explosions.length > 0 || pendingExplosions.length > 0) return;

        const params = getRoundParams(round);
        if (chainCount >= params.target) {
            totalScore += score;
            if (round > bestRound) {
                bestRound = round;
                localStorage.setItem('cr3_bestRound', bestRound);
            }
            if (totalScore > bestScore) {
                bestScore = totalScore;
                localStorage.setItem('cr3_bestScore', bestScore);
            }

            spawnFloatingText(W/2, H/2, `Round ${round} Clear!`, 200);
            audio.playRoundClear();

            round++;
            const nextParams = getRoundParams(round);
            generateDots(nextParams.dots, nextParams.speedMin, nextParams.speedMax);
            explosions = [];
            scheduledDetonations = new Set();
            pendingExplosions = [];
            chainCount = 0;
            score = 0;
            lastChainFreqs = [];
            currentMultiplier = 1;
            multiplierPulse = 0;
            feverIntensity = 0;
            lastCelebration = -1;
            gameState = 'playing';
        } else {
            markNearMissDots();
            gameState = 'gameover';
            gameOverTimer = 0;
            audio.playGameOver();
        }
    }

    function markNearMissDots() {
        const nmRadius = explosionRadius * 1.2;
        for (const dot of dots) {
            if (!dot.active) continue;
            for (let i = 0; i < dots.length; i++) {
                const other = dots[i];
                if (other.active || other === dot) continue;
                if (Math.hypot(dot.x - other.x, dot.y - other.y) <= nmRadius) {
                    dot.nearMiss = 1.0;
                    break;
                }
            }
        }
    }

    // =====================================================================
    // UPDATE
    // =====================================================================
    let lastFrame = performance.now();

    function update() {
        const now = performance.now();
        lastFrame = now;

        if (freezeFrames > 0) { freezeFrames--; return; }

        updateAmbient();
        updateFloatingTexts();
        updateChainLines();
        particles.update();

        // Ambient music
        if (audio.initialized && gameState !== 'resolving' && now >= nextAmbientNote) {
            audio.playAmbientNote();
            nextAmbientNote = now + 2000 + Math.random() * 2000;
        }

        // Drone update
        audio.updateDrone(gameState, feverIntensity);

        // Process pending explosions
        for (let i = pendingExplosions.length - 1; i >= 0; i--) {
            if (now >= pendingExplosions[i].time) {
                const p = pendingExplosions[i];
                explosions.push(new Explosion(p.x, p.y, p.generation, explosionRadius, handleDotCaught, p.parentX, p.parentY));
                pendingExplosions.splice(i, 1);
            }
        }

        for (const d of dots) d.update();
        explosions = explosions.filter(e => e.update(now));

        // Screen shake
        if (shakeTrauma > 0.001) {
            const s = shakeTrauma * shakeTrauma;
            shakeX = SHAKE_MAX_OFFSET * s * (Math.random() * 2 - 1);
            shakeY = SHAKE_MAX_OFFSET * s * (Math.random() * 2 - 1);
            shakeTrauma *= SHAKE_DECAY;
        } else { shakeX = 0; shakeY = 0; shakeTrauma = 0; }

        if (bgPulse > 0.001) bgPulse *= 0.93; else bgPulse = 0;

        // Multiplier pulse decay
        if (multiplierPulse > 0) multiplierPulse = Math.max(0, multiplierPulse - 0.04);

        // Fever decay
        if (gameState !== 'resolving' && feverIntensity > 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }

        // Slow-mo
        if (slowMo !== slowMoTarget) {
            slowMo += (slowMoTarget - slowMo) * 0.15;
            if (Math.abs(slowMo - slowMoTarget) < 0.01) slowMo = slowMoTarget;
        }
        if (slowMoTarget < 1 && explosions.length === 0 && pendingExplosions.length === 0) {
            slowMoTarget = 1.0;
        }

        if (gameState === 'gameover') {
            gameOverTimer = Math.min(1, gameOverTimer + 0.015);
        }

        if (gameState === 'resolving') checkRoundEnd();
    }

    // =====================================================================
    // DRAW
    // =====================================================================
    function draw() {
        ctx.fillStyle = '#020210';
        ctx.fillRect(0, 0, W, H);

        const bgGrad = ctx.createRadialGradient(W/2, H * 0.55, 0, W/2, H * 0.55, Math.max(W, H) * 0.7);
        bgGrad.addColorStop(0, `rgba(${12 + bgPulse * 60|0}, ${8 + bgPulse * 30|0}, ${25 + bgPulse * 80|0}, 1)`);
        bgGrad.addColorStop(0.5, `rgba(${5 + bgPulse * 30|0}, ${4 + bgPulse * 15|0}, ${18 + bgPulse * 40|0}, 1)`);
        bgGrad.addColorStop(1, 'rgba(2, 2, 12, 1)');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, W, H);

        // Vignette
        const vigGrad = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.25, W/2, H/2, Math.max(W,H)*0.75);
        vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
        vigGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
        ctx.fillStyle = vigGrad;
        ctx.fillRect(0, 0, W, H);

        // Fever glow
        if (feverIntensity > 0) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = feverIntensity * 0.04;
            const fh = (performance.now() * 0.05) % 360;
            const fg = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.5);
            fg.addColorStop(0, `hsla(${fh}, 80%, 50%, 1)`);
            fg.addColorStop(1, `hsla(${fh + 30}, 60%, 30%, 0)`);
            ctx.fillStyle = fg;
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        }

        drawAmbient();

        ctx.save();
        ctx.translate(shakeX, shakeY);

        drawChainLines();
        for (const e of explosions) e.draw(ctx);
        particles.draw(ctx);
        for (const d of dots) d.draw(ctx);
        drawFloatingTexts();

        ctx.restore();

        drawUI();
    }

    // =====================================================================
    // UI
    // =====================================================================
    function drawUI() {
        const params = getRoundParams(round);
        const screenMin = Math.min(W, H);
        const s = Math.max(1, screenMin / 600);

        if (gameState === 'start') { drawStartScreen(); return; }

        // Round counter
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        ctx.font = `200 ${13 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.letterSpacing = '2px';
        ctx.fillText('ROUND', W/2, 14 * s);
        ctx.letterSpacing = '0px';

        ctx.font = `200 ${38 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillText(round, W/2, 28 * s);

        // Chain / target
        const infoY = 72 * s;
        if (gameState === 'resolving') {
            const targetMet = chainCount >= params.target;
            ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = targetMet ? 'rgba(255, 220, 100, 0.8)' : 'rgba(255,255,255,0.5)';
            ctx.fillText(`${chainCount} / ${params.target}`, W/2, infoY);

            // Multiplier display
            if (currentMultiplier > 1) {
                const mp = multiplierPulse > 0 ? 1 + easeOutBack(multiplierPulse) * 0.4 : 1;
                const multSize = Math.round(22 * s * mp);
                const multHue = currentMultiplier >= 5 ? 300 : currentMultiplier >= 3 ? 15 : 50;
                ctx.save();
                ctx.shadowColor = `hsla(${multHue}, 90%, 60%, 0.6)`;
                ctx.shadowBlur = 12 * s;
                ctx.font = `900 ${multSize}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${multHue}, 90%, 70%)`;
                ctx.fillText(`x${currentMultiplier}`, W/2, infoY + 22 * s);
                ctx.restore();
            }
        } else if (gameState === 'playing') {
            ctx.font = `300 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fillText(`Target: ${params.target}`, W/2, infoY);
        }

        if (gameState === 'gameover') drawGameOver();

        if (bestRound > 0 && gameState === 'playing') {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = `200 ${12 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillText(`Best: Round ${bestRound}`, W/2, H - 12 * s);
        }
    }

    function drawStartScreen() {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const titleSize = Math.min(52, W * 0.10);
        const subSize = Math.min(16, W * 0.038);

        ctx.save();
        ctx.shadowColor = 'rgba(120, 180, 255, 0.4)';
        ctx.shadowBlur = 40;
        ctx.font = `200 ${titleSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.letterSpacing = `${Math.max(1, titleSize * 0.06)}px`;
        ctx.fillText('CHAIN REACTION', W/2, H/2 - titleSize * 0.8);
        ctx.shadowBlur = 60;
        ctx.shadowColor = 'rgba(100, 160, 255, 0.2)';
        ctx.fillText('CHAIN REACTION', W/2, H/2 - titleSize * 0.8);
        ctx.letterSpacing = '0px';
        ctx.restore();

        ctx.font = `300 ${subSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.45)';
        ctx.fillText('Tap to start a chain reaction.', W/2, H/2 + subSize * 1.2);

        const promptAlpha = 0.2 + 0.12 * Math.sin(performance.now() * 0.003);
        ctx.font = `300 ${Math.min(14, subSize * 0.85)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = `rgba(255,255,255,${promptAlpha})`;
        ctx.fillText('Tap anywhere to begin', W/2, H/2 + subSize * 3.5);

        if (bestRound > 0) {
            ctx.font = `200 ${Math.min(13, subSize * 0.8)}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillText(`Best: Round ${bestRound}`, W/2, H/2 + subSize * 6);
        }
    }

    function drawGameOver() {
        const t = easeOutCubic(gameOverTimer);
        const s = Math.max(1, Math.min(W, H) / 600);

        ctx.fillStyle = `rgba(0, 0, 0, ${t * 0.55})`;
        ctx.fillRect(0, 0, W, H);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const scaleT = easeOutBack(Math.min(t * 1.5, 1));
        ctx.save();
        ctx.shadowColor = 'rgba(255, 140, 60, 0.35)';
        ctx.shadowBlur = 30 * s;
        ctx.font = `200 ${Math.round(48 * s * scaleT)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillText(`Round ${round}`, W/2, H/2 - 50 * s);
        ctx.restore();

        if (t > 0.3) {
            const t2 = easeOutCubic((t - 0.3) / 0.7);
            ctx.globalAlpha = t2;

            ctx.font = `300 ${18 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255, 160, 80, 0.85)';
            const params = getRoundParams(round);
            ctx.fillText(`Chain: ${chainCount} / ${params.target}`, W/2, H/2);

            ctx.font = `300 ${15 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText(`Total Score: ${totalScore + score}`, W/2, H/2 + 30 * s);

            if (round >= bestRound) {
                ctx.font = `600 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.fillText('New Best!', W/2, H/2 + 58 * s);
            }
        }

        if (t > 0.6) {
            const t3 = (t - 0.6) / 0.4;
            const pa = t3 * (0.3 + 0.1 * Math.sin(performance.now() * 0.003));
            ctx.font = `300 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${pa})`;
            ctx.fillText('Tap to play again', W/2, H/2 + 100 * s);
        }

        ctx.globalAlpha = 1;
    }

    // =====================================================================
    // GAME LOOP
    // =====================================================================
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        handleTap(e.clientX, e.clientY);
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    generateDots(10, 0.2, 0.5);
    gameState = 'start';
    lastFrame = performance.now();
    loop();

    </script>
</body>
</html>
