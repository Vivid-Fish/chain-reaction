<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { 
            background: #0a0a1a; 
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            user-select: none;
        }
        #game { display: block; }
        #ui { 
            position: absolute; 
            top: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            text-align: center; 
            color: white; 
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #level { font-size: 14px; opacity: 0.7; }
        #score { font-size: 64px; font-weight: bold; }
        #target { font-size: 12px; opacity: 0.5; margin-top: 2px; }
        #best { font-size: 12px; opacity: 0.4; margin-top: 5px; }
        #start, #gameOver { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            color: white;
            z-index: 20;
        }
        #start h1 { 
            font-size: 48px; 
            margin-bottom: 15px; 
            text-shadow: 0 2px 20px rgba(0,0,0,0.8);
        }
        #start p { 
            font-size: 16px; 
            opacity: 0.8; 
            margin-bottom: 30px; 
            line-height: 1.6;
        }
        #gameOver { display: none; }
        #gameOver h1 { font-size: 36px; margin-bottom: 10px; }
        #gameOver p { font-size: 14px; opacity: 0.7; margin-bottom: 20px; }
        #chainDisplay { font-size: 48px; font-weight: bold; color: #ff6b6b; }
        #nearMiss { font-size: 12px; opacity: 0.6; margin-top: 10px; }
        .btn { 
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%); 
            border: none; 
            padding: 18px 50px; 
            font-size: 20px; 
            color: white; 
            border-radius: 50px; 
            cursor: pointer; 
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.4);
            transition: transform 0.1s;
            margin-top: 20px;
        }
        .btn:active { transform: scale(0.95); }
        #tapHint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.4);
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="ui">
        <div id="level">Level 1</div>
        <div id="score">0</div>
        <div id="target">Target: 3</div>
        <div id="best">Best: 0</div>
    </div>
    <div id="tapHint">Tap anywhere to start chain</div>
    <div id="start">
        <h1>Chain Reaction</h1>
        <p>One tap. One chain.<br>Watch the dots drift.<br>Find the perfect moment.</p>
        <button class="btn" onclick="startGame()">Play</button>
    </div>
    <div id="gameOver">
        <h1 id="endTitle">Chain Complete</h1>
        <div id="chainDisplay">0</div>
        <p id="endDetail">Target was 3</p>
        <p id="nearMiss"></p>
        <button class="btn" onclick="nextLevel()">Continue</button>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        function resize() { 
            canvas.width = window.innerWidth; 
            canvas.height = window.innerHeight; 
        }
        window.addEventListener('resize', resize);
        resize();

        // TUNABLE CONSTANTS
        const EXPLOSION_RADIUS_PCT = 0.13; // 13% of min(screen width, height)
        const EXPLOSION_GROW_MS = 300;
        const EXPLOSION_HOLD_MS = 1200;
        const EXPLOSION_SHRINK_MS = 500;
        const CHAIN_STAGGER_MS = 100;
        const CHAIN_JITTER_MS = 20;
        const MIN_NOTE_SEPARATION_MS = 40;
        const DOT_SPEED_MIN = 0.3;
        const DOT_SPEED_MAX = 0.8;
        const HIT_FREEZE_FRAMES = 3;
        const SCREEN_MARGIN = 15;

        // Level progression (dots, target, required %)
        const LEVELS = [
            { dots: 10, target: 3 },   // 30%
            { dots: 15, target: 6 },   // 40%
            { dots: 20, target: 10 },  // 50%
            { dots: 25, target: 15 },  // 60%
            { dots: 30, target: 20 },  // 67%
            { dots: 35, target: 24 },  // 69%
            { dots: 40, target: 30 },  // 75%
            { dots: 45, target: 36 },  // 80%
            { dots: 50, target: 42 },  // 84%
            { dots: 55, target: 48 },  // 87%
            { dots: 60, target: 54 },  // 90%
            { dots: 60, target: 58 },  // 97%
        ];

        let currentLevel = 0;
        let dots = [];
        let explosions = [];
        let particles = [];
        let score = 0;
        let chainCount = 0;
        let bestScore = localStorage.getItem('chainReactionBest') || 0;
        let gameState = 'start'; // start, playing, resolving, ended
        let freezeFrames = 0;
        let lastTime = 0;
        let generationTiming = {}; // Track when each generation can fire

        document.getElementById('best').textContent = 'Best: ' + bestScore;

        // Easing functions
        const easeOutExpo = t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
        const easeInQuad = t => t * t;

        class Dot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                // Normalize to desired speed range
                const speed = DOT_SPEED_MIN + Math.random() * (DOT_SPEED_MAX - DOT_SPEED_MIN);
                const currentSpeed = Math.hypot(this.vx, this.vy);
                this.vx = (this.vx / currentSpeed) * speed;
                this.vy = (this.vy / currentSpeed) * speed;
                
                this.active = true;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.radius = 6;
                this.generation = -1; // Which explosion generation caught this dot
            }
            
            update() {
                if (!this.active) return;
                
                this.x += this.vx;
                this.y += this.vy;
                this.pulsePhase += 0.05;
                
                // Bounce off walls with margin
                if (this.x < SCREEN_MARGIN || this.x > canvas.width - SCREEN_MARGIN) {
                    this.vx *= -1;
                    this.x = Math.max(SCREEN_MARGIN, Math.min(canvas.width - SCREEN_MARGIN, this.x));
                }
                if (this.y < SCREEN_MARGIN || this.y > canvas.height - SCREEN_MARGIN) {
                    this.vy *= -1;
                    this.y = Math.max(SCREEN_MARGIN, Math.min(canvas.height - SCREEN_MARGIN, this.y));
                }
            }
            
            getHue() {
                // Top = cyan (200), bottom = orange (20)
                return 200 - (this.y / canvas.height) * 180;
            }
            
            draw() {
                if (!this.active) return;
                
                const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
                const hue = this.getHue();
                
                // Outer glow ring
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${pulse * 0.4})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Core dot
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${pulse})`;
                ctx.fill();
            }
        }

        class Explosion {
            constructor(x, y, generation = 0, onDotCaught) {
                this.x = x;
                this.y = y;
                this.generation = generation;
                this.onDotCaught = onDotCaught;
                this.createdAt = performance.now();
                this.phase = 'grow'; // grow, hold, shrink, done
                this.radius = 0;
                this.maxRadius = Math.min(canvas.width, canvas.height) * EXPLOSION_RADIUS_PCT;
                this.caughtDots = new Set(); // Track which dots we've already caught
            }
            
            update(now) {
                const age = now - this.createdAt;
                
                // Phase transitions
                if (this.phase === 'grow' && age >= EXPLOSION_GROW_MS) {
                    this.phase = 'hold';
                } else if (this.phase === 'hold' && age >= EXPLOSION_GROW_MS + EXPLOSION_HOLD_MS) {
                    this.phase = 'shrink';
                } else if (this.phase === 'shrink' && age >= EXPLOSION_GROW_MS + EXPLOSION_HOLD_MS + EXPLOSION_SHRINK_MS) {
                    this.phase = 'done';
                    return false; // Remove from array
                }
                
                // Radius calculation
                if (this.phase === 'grow') {
                    const t = age / EXPLOSION_GROW_MS;
                    this.radius = this.maxRadius * easeOutExpo(t);
                } else if (this.phase === 'hold') {
                    this.radius = this.maxRadius;
                } else if (this.phase === 'shrink') {
                    const t = (age - EXPLOSION_GROW_MS - EXPLOSION_HOLD_MS) / EXPLOSION_SHRINK_MS;
                    this.radius = this.maxRadius * (1 - easeInQuad(t));
                }
                
                // During grow and hold phases, check for dots entering explosion zone EVERY FRAME
                if (this.phase === 'grow' || this.phase === 'hold') {
                    this.checkForDotsInRadius();
                }
                
                return true;
            }
            
            checkForDotsInRadius() {
                dots.forEach(dot => {
                    if (!dot.active || this.caughtDots.has(dot)) return;
                    
                    const dist = Math.hypot(dot.x - this.x, dot.y - this.y);
                    if (dist <= this.radius) {
                        // Dot entered explosion zone!
                        this.caughtDots.add(dot);
                        if (this.onDotCaught) {
                            this.onDotCaught(dot, this.generation);
                        }
                    }
                });
            }
                if (this.phase === 'grow') {
                    const t = age / EXPLOSION_GROW_MS;
                    this.radius = this.maxRadius * easeOutExpo(t);
                } else if (this.phase === 'hold') {
                    this.radius = this.maxRadius;
                } else if (this.phase === 'shrink') {
                    const t = (age - EXPLOSION_GROW_MS - EXPLOSION_HOLD_MS) / EXPLOSION_SHRINK_MS;
                    this.radius = this.maxRadius * (1 - easeInQuad(t));
                }
                
                return true;
            }
            
            draw() {
                const progress = 1 - (this.radius / this.maxRadius);
                const alpha = this.phase === 'shrink' ? 1 - easeInQuad((performance.now() - this.createdAt - EXPLOSION_GROW_MS - EXPLOSION_HOLD_MS) / EXPLOSION_SHRINK_MS) : 1;
                
                // Shockwave ring
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 140, 80, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Core
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 220, 140, ${alpha})`;
                ctx.fill();
            }
        }

        function createParticles(x, y, hue) {
            // Burst particles
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8 + Math.random() * 0.4;
                const speed = 4 + Math.random() * 6;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 20 + Math.random() * 15,
                    maxLife: 35,
                    hue,
                    type: 'burst'
                });
            }
            // Drift particles
            for (let i = 0; i < 4; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: -1 - Math.random() * 2, // Rise
                    life: 40 + Math.random() * 30,
                    maxLife: 70,
                    hue,
                    type: 'drift'
                });
            }
        }

        function generateDots(count) {
            dots = [];
            const minDist = 35;
            let attempts = 0;
            
            while (dots.length < count && attempts < 2000) {
                const x = SCREEN_MARGIN + Math.random() * (canvas.width - SCREEN_MARGIN * 2);
                const y = SCREEN_MARGIN + Math.random() * (canvas.height - SCREEN_MARGIN * 2);
                
                let valid = true;
                for (let dot of dots) {
                    if (Math.hypot(dot.x - x, dot.y - y) < minDist) {
                        valid = false;
                        break;
                    }
                }
                
                if (valid) {
                    dots.push(new Dot(x, y));
                }
                attempts++;
            }
        }

        function startGame() {
            document.getElementById('start').style.display = 'none';
            document.getElementById('tapHint').style.opacity = '1';
            currentLevel = 0;
            startLevel();
        }

        function startLevel() {
            const level = LEVELS[currentLevel];
            generateDots(level.dots);
            explosions = [];
            particles = [];
            score = 0;
            chainCount = 0;
            gameState = 'playing';
            generationTiming = {};
            
            document.getElementById('level').textContent = `Level ${currentLevel + 1}`;
            document.getElementById('target').textContent = `Target: ${level.target}`;
            document.getElementById('score').textContent = '0';
            document.getElementById('tapHint').textContent = 'Tap anywhere to start chain';
            document.getElementById('tapHint').style.opacity = '1';
        }

        function handleTap(e) {
            if (gameState !== 'playing') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
            const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
            
            // ONE TAP PER LEVEL - disable further input
            gameState = 'resolving';
            document.getElementById('tapHint').style.opacity = '0';
            
            // Hit freeze
            freezeFrames = HIT_FREEZE_FRAMES;
            
            // Track which explosions are scheduled to prevent duplicates
            const scheduledExplosions = new Set();
            
            // Create initial explosion with callback
            explosions.push(new Explosion(x, y, 0, (dot, generation) => {
                // This callback fires when a dot enters the explosion radius
                if (scheduledExplosions.has(dot)) return;
                scheduledExplosions.add(dot);
                
                dot.active = false;
                dot.generation = generation;
                chainCount++;
                
                // Stagger the child explosion
                const delay = CHAIN_STAGGER_MS + (Math.random() - 0.5) * 2 * CHAIN_JITTER_MS;
                setTimeout(() => {
                    if (gameState === 'ended') return;
                    explosions.push(new Explosion(dot.x, dot.y, generation + 1, (childDot, childGen) => {
                        if (scheduledExplosions.has(childDot)) return;
                        scheduledExplosions.add(childDot);
                        
                        childDot.active = false;
                        childDot.generation = childGen;
                        chainCount++;
                        
                        // Continue the chain recursively with delay
                        const childDelay = CHAIN_STAGGER_MS + (Math.random() - 0.5) * 2 * CHAIN_JITTER_MS;
                        setTimeout(() => {
                            if (gameState === 'ended') return;
                            explosions.push(new Explosion(childDot.x, childDot.y, childGen + 1, explosions[explosions.length - 1]?.onDotCaught));
                        }, childDelay);
                        
                        createParticles(childDot.x, childDot.y, childDot.getHue());
                    }));
                    createParticles(dot.x, dot.y, dot.getHue());
                }, delay);
                
                createParticles(dot.x, dot.y, dot.getHue());
            }));
            
            // Check for dots already in radius at start
            let hitDot = false;
            dots.forEach(dot => {
                if (!dot.active) return;
                if (Math.hypot(dot.x - x, dot.y - y) <= explosions[0].maxRadius) {
                    explosions[0].caughtDots.add(dot);
                    explosions[0].onDotCaught(dot, 0);
                    hitDot = true;
                }
            });
            
            // Miss sound/visual if no dot hit
            if (!hitDot) {
                createParticles(x, y, 200);
            }
        }

        function checkLevelEnd() {
            // Check if all explosions are done
            const activeExplosions = explosions.filter(e => e.phase !== 'done').length;
            const activeDots = dots.filter(d => d.active).length;
            
            if (activeExplosions === 0 && gameState === 'resolving') {
                gameState = 'ended';
                const level = LEVELS[currentLevel];
                const cleared = chainCount >= level.target;
                
                // Find near-miss dots (within 120% of explosion radius)
                const radius = Math.min(canvas.width, canvas.height) * EXPLOSION_RADIUS_PCT * 1.2;
                let nearMissCount = 0;
                dots.forEach(dot => {
                    if (dot.active) {
                        let minDist = Infinity;
                        explosions.forEach(e => {
                            const d = Math.hypot(dot.x - e.x, dot.y - e.y) - e.maxRadius;
                            minDist = Math.min(minDist, d);
                        });
                        if (minDist < radius * 0.2) nearMissCount++;
                    }
                });
                
                // Show end screen
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('chainDisplay').textContent = chainCount;
                document.getElementById('endDetail').textContent = `Target was ${level.target}`;
                
                if (cleared) {
                    document.getElementById('endTitle').textContent = 'Level Clear!';
                    document.getElementById('endTitle').style.color = '#64b5f6';
                    score = chainCount * 10;
                    if (score > bestScore) {
                        bestScore = score;
                        localStorage.setItem('chainReactionBest', bestScore);
                        document.getElementById('best').textContent = 'Best: ' + bestScore;
                    }
                } else {
                    document.getElementById('endTitle').textContent = 'Chain Complete';
                    document.getElementById('endTitle').style.color = '#ff6b6b';
                    const nearMissText = nearMissCount > 0 
                        ? `${nearMissCount} dot${nearMissCount > 1 ? 's' : ''} were close` 
                        : 'Try a different position';
                    document.getElementById('nearMiss').textContent = nearMissText;
                }
                
                // Update button
                const btn = document.querySelector('#gameOver .btn');
                btn.textContent = cleared ? 'Next Level' : 'Try Again';
                btn.onclick = cleared ? nextLevel : retryLevel;
            }
        }

        function nextLevel() {
            currentLevel++;
            if (currentLevel >= LEVELS.length) {
                currentLevel = 0; // Loop back or show victory
            }
            document.getElementById('gameOver').style.display = 'none';
            startLevel();
        }

        function retryLevel() {
            document.getElementById('gameOver').style.display = 'none';
            startLevel();
        }

        function update() {
            const now = performance.now();
            
            // Hit freeze
            if (freezeFrames > 0) {
                freezeFrames--;
                return;
            }
            
            // Update dots
            dots.forEach(dot => dot.update());
            
            // Update explosions
            explosions = explosions.filter(e => e.update(now));
            
            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (p.type === 'burst') {
                    p.vx *= 0.93;
                    p.vy *= 0.93;
                    p.vy += 0.05;
                } else {
                    p.vy -= 0.02; // Rise
                    p.vx *= 0.97;
                    p.vy *= 0.97;
                }
                p.life--;
                return p.life > 0;
            });
            
            // Check for level end
            if (gameState === 'resolving') {
                checkLevelEnd();
            }
            
            // Update UI
            document.getElementById('score').textContent = chainCount;
        }

        function draw() {
            // Clear with trail effect
            ctx.fillStyle = 'rgba(10, 10, 26, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw particles
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${alpha})`;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            });
            ctx.globalAlpha = 1;
            
            // Draw dots
            dots.forEach(dot => dot.draw());
            
            // Draw explosions
            explosions.forEach(e => e.draw());
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Input
        canvas.addEventListener('mousedown', handleTap);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleTap(e);
        });

        loop();
    </script>
</body>
</html>
