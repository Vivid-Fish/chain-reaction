<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: crosshair;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script src="engine.js"></script>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION — Game Client (uses shared engine.js)
    //
    // Architecture (line ranges):
    //   Game Constants ....... ~35-60    Setback, mercy, supernova, bot config
    //   Game State ........... ~63-108   Round, score, flags, leaderboard cache
    //   API Helpers .......... ~111-172  Session save, checkpoint, leaderboard fetch
    //   Music System ......... ~174-185  Background music via audio engine
    //   Resize ............... ~187-191  Delegates to engine.js
    //   Round Formula ........ ~194-214  getRoundParams(r) — dots, target, speeds, types
    //   Audio Engine ......... ~217-449  Web Audio API synthesis (all sounds)
    //   Dot Generation ....... ~462-497  Scatter dots with random velocities
    //   Game State Mgmt ...... ~500-683  startRound, handleTap, checkRoundEnd
    //   Update ............... ~685-730  Game loop tick (physics + round checks)
    //   Draw ................. ~732-1017 All rendering (HUD, screens, game over)
    //   Spectator Bot ........ ~1019-1110 Auto-play with greedy strategy
    //   Replay Download ...... ~1113-1130 Export replay as JSON
    //   Game Loop ............ ~1133-1143 requestAnimationFrame driver
    //   Input ................ ~1146-1216 Pointer + keyboard handlers
    //   Init ................. ~1218-1229 Boot sequence
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // GAME-SPECIFIC CONSTANTS
    // =====================================================================

    // Progression — setback + mercy
    const SETBACK_ROUNDS = 2;
    const MERCY_RADIUS_BONUS = 0.05;
    const MERCY_RADIUS_CAP = 0.15;

    // Supernova (multi-tap reward round)
    const SUPERNOVA_CHARGE_NEEDED = 3;
    const SUPERNOVA_TAPS = 3;

    // Audio
    const MAX_VOICES = 48;
    const SIXTEENTH_NOTE_SEC = (60 / 80) / 4;

    // Hit freeze
    const HIT_FREEZE_FRAMES = 3;

    // Ascending pentatonic scale
    const SCALE_NOTES = [
        130.81, 146.83, 164.81, 196.00, 220.00,
        261.63, 293.66, 329.63, 392.00, 440.00,
        523.25, 587.33, 659.25, 783.99, 880.00,
        1046.50, 1174.66, 1318.51, 1567.98, 1760.00,
    ];

    // =====================================================================
    // GAME STATE
    // =====================================================================
    // Shape: { round, bestRound, bestScore, gameState, freezeFrames,
    //          gameOverTimer, lastChainFreqs, totalScore }
    let round = 0;
    let bestRound = parseInt(localStorage.getItem('cr3_bestRound') || '0', 10);
    let bestScore = parseInt(localStorage.getItem('cr3_bestScore') || '0', 10);
    let gameState = 'start';  // 'start' | 'playing' | 'resolving' | 'watching' | 'gameover'
    let freezeFrames = 0;
    let gameOverTimer = 0;
    let lastChainFreqs = [];
    let totalScore = 0;

    // Progression: { consecutiveFails, mercyBonus, peakRound }
    let consecutiveFails = 0;
    let mercyBonus = 0;
    let peakRound = 0;

    // Supernova: { charge, active, tapsRemaining }
    let supernovaCharge = 0;
    let supernovaActive = false;
    let supernovaTapsRemaining = 0;

    // Spectator mode (bot autoplay)
    // Shape: { enabled, target, thinkTimer, scanInterval, lastScan, reactionDelay }
    const urlParams = new URLSearchParams(window.location.search);
    let spectatorMode = urlParams.has('watch');
    let botTarget = null;
    let botThinkTimer = 0;
    let botScanInterval = 400;
    let botLastScan = 0;
    let botReactionDelay = 600;

    // Replay recording
    let replayLog = [];
    let replayStartTime = 0;

    // UI buttons (computed in draw, hit-tested in input)
    let uiButtons = [];

    // Persistence
    let deviceId = localStorage.getItem('cr_device_id');
    if (!deviceId) { deviceId = crypto.randomUUID(); localStorage.setItem('cr_device_id', deviceId); }
    let playerName = localStorage.getItem('cr_player_name') || null;
    let resumeCheckpoint = null;
    let leaderboard = null;
    let contLeaderboard = null; // continuous mode leaderboard (by tier)
    let lastSessionId = null;

    // Mode & tier selection
    let gameMode = localStorage.getItem('cr_game_mode') || 'rounds'; // 'rounds' | 'continuous'
    let selectedTier = localStorage.getItem('cr_continuous_tier') || 'FLOW';
    const TIER_ORDER = ['CALM', 'FLOW', 'SURGE', 'TRANSCENDENCE'];
    const TIER_DESCRIPTIONS = {
        CALM: 'Breathe. Watch. Let the chains unfold.',
        FLOW: 'Find your rhythm. Build your melody.',
        SURGE: 'The field is alive. Keep up.',
        TRANSCENDENCE: 'Everything. All at once.',
    };
    let tiersVisited = JSON.parse(localStorage.getItem('cr_tiers_visited') || '{}');
    let modeSwipeOffset = 0;   // current horizontal offset (px)
    let modeSwipeTarget = 0;   // target horizontal offset
    let tierSwipeOffset = 0;   // current vertical offset (px)
    let tierSwipeTarget = 0;
    let sessionCount = parseInt(localStorage.getItem('cr_session_count') || '0', 10);

    // =====================================================================
    // API HELPERS
    // =====================================================================
    const API = {
        async saveSession(events, contData) {
            try {
                const payload = {
                    device_id: deviceId,
                    player_name: playerName,
                    peak_round: contData ? 0 : peakRound,
                    total_score: contData ? contData.score : totalScore + score,
                    is_bot: spectatorMode,
                    viewport_w: W,
                    viewport_h: H,
                    build_ver: BUILD_VERSION,
                    events,
                };
                if (contData) {
                    payload.game_mode = 'continuous';
                    payload.continuous_tier = contData.tier;
                    payload.duration_ms = contData.duration;
                    payload.final_density = contData.finalDensity;
                    payload.mean_density = contData.meanDensity;
                    payload.total_taps = contData.totalTaps;
                }
                const res = await fetch('/api/session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    keepalive: true,
                });
                const data = await res.json();
                if (data.id) lastSessionId = data.id;
                return data;
            } catch (e) { console.warn('saveSession failed:', e); }
        },
        saveCheckpoint() {
            fetch('/api/checkpoint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    device_id: deviceId,
                    round, total_score: totalScore,
                    consecutive_fails: consecutiveFails,
                    mercy_bonus: mercyBonus,
                    supernova_charge: supernovaCharge,
                }),
                keepalive: true,
            }).catch(() => {});
        },
        clearCheckpoint() {
            fetch(`/api/checkpoint/${encodeURIComponent(deviceId)}`, {
                method: 'DELETE', keepalive: true,
            }).catch(() => {});
        },
        async fetchLeaderboard(mode, tier) {
            try {
                let url = '/api/leaderboard';
                if (mode) {
                    url += `?mode=${mode}`;
                    if (tier) url += `&tier=${tier}`;
                }
                const res = await fetch(url);
                const data = await res.json();
                if (mode === 'continuous') {
                    contLeaderboard = data;
                } else {
                    leaderboard = data;
                }
            } catch (e) { console.warn('fetchLeaderboard failed:', e); }
        },
        async fetchCheckpoint() {
            try {
                const res = await fetch(`/api/checkpoint/${encodeURIComponent(deviceId)}`);
                const data = await res.json();
                resumeCheckpoint = data;
            } catch (e) { console.warn('fetchCheckpoint failed:', e); }
        },
    };

    Promise.all([
        API.fetchLeaderboard('rounds'),
        API.fetchLeaderboard('continuous', selectedTier),
        API.fetchCheckpoint(),
    ]).catch(() => {});

    // =====================================================================
    // MUSIC SYSTEM
    // =====================================================================
    const MUSIC_PATTERN = [
        [5,1.0],[7,0.7],[8,0.9],[10,0.6],
        [9,0.8],[8,0.7],[7,0.9],[5,0.6],
        [3,1.0],[4,0.7],[5,0.9],[7,0.6],
        [8,0.8],[7,0.7],[5,0.9],[3,0.5],
    ];
    let musicBeat = 0;
    let nextMusicBeat = 0;
    const MUSIC_BEAT_MS = 750;

    // =====================================================================
    // RESIZE (delegates to engine)
    // =====================================================================
    function resize() { engineResize(canvas); }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // ROUND FORMULA
    // =====================================================================
    function getRoundParams(r) {
        const numDots = Math.min(60, Math.floor(10 + r * 2.5));
        const pct = Math.min(0.80, 0.05 + (r - 1) * 0.028);
        const target = Math.max(1, Math.ceil(numDots * pct));
        const speedMin = 0.7 + Math.min(0.6, (r - 1) * 0.04);
        const speedMax = 1.4 + Math.min(1.2, (r - 1) * 0.07);
        let typeWeights;
        if (r <= 2) {
            typeWeights = { standard: 1.0 };
        } else if (r <= 4) {
            const gw = Math.min(0.25, (r - 2) * 0.12);
            typeWeights = { standard: 1 - gw, gravity: gw };
        } else {
            const gw = Math.min(0.25, 0.12 + (r - 4) * 0.03);
            const vw = Math.min(0.20, (r - 4) * 0.08);
            typeWeights = { standard: Math.max(0.5, 1 - gw - vw), gravity: gw, volatile: vw };
        }
        return { dots: numDots, target, pct, speedMin, speedMax, typeWeights };
    }

    // =====================================================================
    // AUDIO ENGINE
    // =====================================================================
    const audio = {
        ctx: null,
        masterGain: null,
        compressor: null,
        delayNode: null,
        voices: [],
        initialized: false,

        init() {
            if (this.initialized) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.ctx.resume();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.6;
            this.compressor = this.ctx.createDynamicsCompressor();
            this.compressor.threshold.value = -18;
            this.compressor.knee.value = 12;
            this.compressor.ratio.value = 6;
            this.delayNode = this._createDelay(0.18, 0.25, 0.18);
            this.masterGain.connect(this.compressor);
            this.compressor.connect(this.delayNode.input);
            this.delayNode.output.connect(this.ctx.destination);
            setTimeout(() => {
                const reverb = this._createReverb(2.0, 3.0, 0.22);
                this.delayNode.output.disconnect();
                this.delayNode.output.connect(reverb.input);
                reverb.output.connect(this.ctx.destination);
            }, 0);
            this.initialized = true;
            this.gridOrigin = this.ctx.currentTime;
        },

        playChainNote(chainIndex, generation) {
            if (!this.initialized) return;
            const now = this.ctx.currentTime;
            const elapsed = now - this.gridOrigin;
            const gridPos = Math.round(elapsed / SIXTEENTH_NOTE_SEC);
            let at = this.gridOrigin + gridPos * SIXTEENTH_NOTE_SEC;
            if (at < now) at += SIXTEENTH_NOTE_SEC;
            const noteIdx = Math.min(chainIndex, SCALE_NOTES.length - 1);
            const baseFreq = SCALE_NOTES[noteIdx];
            const detune = (Math.random() - 0.5) * 12;
            const freq = baseFreq * Math.pow(2, detune / 1200);
            lastChainFreqs.push(baseFreq);
            const chainBoost = Math.min(1.8, 1 + chainIndex * 0.03);
            let attack, decay, susLvl, susTime, release, vol;
            if (generation === 0) {
                attack = 0.001; decay = 0.04; susLvl = 0.4;
                susTime = 0.12; release = 0.6; vol = 0.24 * chainBoost;
            } else {
                attack = 0.003; decay = 0.03; susLvl = 0.35;
                susTime = 0.08; release = 0.5 + Math.min(0.3, generation * 0.02);
                vol = Math.max(0.08, 0.22 * chainBoost - generation * 0.005);
            }
            this._voicePlay(freq, 'triangle', vol, attack, decay, susLvl, susTime, release, at);
            this._voicePlay(freq, 'sine', vol * 0.5, 0.001, 0.01, 0, 0, 0.03, at);
            if (chainIndex >= 2) this._voicePlay(freq * 2, 'sine', vol * 0.12, 0.003, 0.03, 0.15, 0.03, 0.4, at);
            if (chainIndex < 4) this._voicePlay(freq * 0.5, 'sine', vol * 0.1, 0.01, 0.06, 0.2, 0.06, 0.5, at);
            if (chainIndex >= 6) this._voicePlay(freq * 1.5, 'sine', vol * 0.08, 0.005, 0.04, 0.12, 0.04, 0.4, at);
        },

        playMusicNote(noteIdx, vol) {
            if (!this.initialized) return;
            this._voicePlay(SCALE_NOTES[noteIdx], 'triangle', vol, 0.01, 0.08, 0.5, 0.4, 1.0);
        },

        playMusicBass(noteIdx) {
            if (!this.initialized) return;
            this._voicePlay(SCALE_NOTES[noteIdx], 'sine', 0.12, 0.05, 0.1, 0.3, 0.5, 1.0);
        },

        playMiss() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const buf = c.createBuffer(1, Math.floor(c.sampleRate * 0.08), c.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (c.sampleRate * 0.02));
            const src = c.createBufferSource(); src.buffer = buf;
            const f = c.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 600;
            const g = c.createGain();
            g.gain.setValueAtTime(0.0001, now);
            g.gain.linearRampToValueAtTime(0.06, now + 0.002);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.06);
            src.connect(f); f.connect(g); g.connect(this.ctx.destination);
            src.start(now); src.stop(now + 0.08);
            src.onended = () => { src.disconnect(); f.disconnect(); g.disconnect(); };
        },

        playTap() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const osc = c.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
            const g = c.createGain();
            g.gain.setValueAtTime(0.15, now);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
            osc.connect(g); g.connect(this.masterGain);
            osc.start(now); osc.stop(now + 0.2);
            osc.onended = () => { osc.disconnect(); g.disconnect(); };
        },

        playCelebration(level) {
            if (!this.initialized) return;
            const baseIdx = Math.min(10, level * 2);
            for (let i = 0; i < 4; i++) {
                const idx = Math.min(SCALE_NOTES.length - 1, baseIdx + i);
                setTimeout(() => {
                    this._voicePlay(SCALE_NOTES[idx], 'sine', 0.14, 0.01, 0.08, 0.6, 0.15, 1.2);
                    this._voicePlay(SCALE_NOTES[idx] * 2, 'sine', 0.04, 0.02, 0.05, 0.3, 0.1, 0.8);
                }, i * 80);
            }
        },

        playRoundClear() {
            if (!this.initialized) return;
            const chord = [
                SCALE_NOTES[5], SCALE_NOTES[7], SCALE_NOTES[8],
                SCALE_NOTES[10], SCALE_NOTES[12],
            ];
            chord.forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'sine', 0.12, 0.15, 0.1, 0.7, 1.0, 2.0);
                    this._voicePlay(f * 2, 'sine', 0.03, 0.2, 0.08, 0.4, 0.8, 1.5);
                }, i * 60);
            });
        },

        playGameOver() {
            if (!this.initialized) return;
            [220, 196, 164.81].forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'triangle', 0.10, 0.1, 0.15, 0.5, 0.3, 1.5);
                }, i * 150);
            });
        },

        _voicePlay(freq, type, vol, attack, decay, susLvl, susTime, release, at) {
            while (this.voices.length >= MAX_VOICES) {
                const old = this.voices.shift();
                try {
                    old.gain.gain.setValueAtTime(old.gain.gain.value, this.ctx.currentTime);
                    old.gain.gain.linearRampToValueAtTime(0.0001, this.ctx.currentTime + 0.005);
                    old.osc.stop(this.ctx.currentTime + 0.01);
                } catch(e) {}
            }
            const c = this.ctx; const now = at !== undefined ? at : c.currentTime;
            const osc = c.createOscillator();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, now);
            const env = c.createGain();
            env.gain.setValueAtTime(0.0001, now);
            env.gain.linearRampToValueAtTime(vol, now + attack);
            env.gain.linearRampToValueAtTime(vol * susLvl, now + attack + decay);
            const relStart = now + attack + decay + susTime;
            env.gain.setValueAtTime(vol * susLvl, relStart);
            env.gain.exponentialRampToValueAtTime(0.0001, relStart + release);
            osc.connect(env); env.connect(this.masterGain);
            osc.start(now); osc.stop(relStart + release + 0.05);
            const voice = { osc, gain: env };
            this.voices.push(voice);
            osc.onended = () => {
                osc.disconnect(); env.disconnect();
                const idx = this.voices.indexOf(voice);
                if (idx !== -1) this.voices.splice(idx, 1);
            };
        },

        _createDelay(time, feedback, wet) {
            const c = this.ctx;
            const input = c.createGain(), output = c.createGain();
            const delay = c.createDelay(2.0), fb = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            const filt = c.createBiquadFilter();
            delay.delayTime.value = time; fb.gain.value = feedback;
            wetG.gain.value = wet; dryG.gain.value = 1.0;
            filt.type = 'lowpass'; filt.frequency.value = 2500;
            input.connect(dryG); dryG.connect(output);
            input.connect(delay); delay.connect(filt); filt.connect(fb); fb.connect(delay);
            delay.connect(wetG); wetG.connect(output);
            return { input, output };
        },

        _createReverb(dur, dec, mix) {
            const c = this.ctx;
            const len = Math.floor(c.sampleRate * dur);
            const buf = c.createBuffer(2, len, c.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const d = buf.getChannelData(ch);
                for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-dec * (i / c.sampleRate));
            }
            const conv = c.createConvolver(); conv.buffer = buf;
            const input = c.createGain(), output = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            wetG.gain.value = mix; dryG.gain.value = 1.0;
            input.connect(dryG); dryG.connect(output);
            input.connect(conv); conv.connect(wetG); wetG.connect(output);
            return { input, output };
        },

        activateSupernova() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            this._snFilter = c.createBiquadFilter();
            this._snFilter.type = 'lowpass';
            this._snFilter.frequency.setValueAtTime(20000, now);
            this._snFilter.frequency.exponentialRampToValueAtTime(800, now + 0.5);
            this._snFilter.Q.value = 1.5;
            this.masterGain.disconnect();
            this.masterGain.connect(this._snFilter);
            this._snFilter.connect(this.compressor);
        },

        deactivateSupernova() {
            if (!this.initialized || !this._snFilter) return;
            const c = this.ctx; const now = c.currentTime;
            this._snFilter.frequency.setValueAtTime(this._snFilter.frequency.value, now);
            this._snFilter.frequency.exponentialRampToValueAtTime(20000, now + 0.3);
            const filter = this._snFilter;
            this._snFilter = null;
            setTimeout(() => {
                try {
                    this.masterGain.disconnect();
                    this.masterGain.connect(this.compressor);
                    filter.disconnect();
                } catch(e) {}
            }, 400);
        }
    };

    // =====================================================================
    // AUDIO CALLBACK FOR ENGINE
    // =====================================================================
    onDetonateAudio = function(chainOrEvent, param) {
        if (chainOrEvent === 'celebration') {
            audio.playCelebration(param);
        } else {
            audio.playChainNote(chainOrEvent - 1, param);
        }
    };

    // =====================================================================
    // DOT GENERATION (game-specific — uses random velocities)
    // =====================================================================
    function pickDotType(typeWeights) {
        const r = Math.random();
        let sum = 0;
        for (const [type, weight] of Object.entries(typeWeights)) {
            sum += weight;
            if (r <= sum) return type;
        }
        return 'standard';
    }

    function generateDots(count, speedMin, speedMax, typeWeights) {
        dots = [];
        let attempts = 0;
        const topMargin = SCREEN_MARGIN + 50;
        const tw = typeWeights || { standard: 1.0 };
        while (dots.length < count && attempts < 5000) {
            const x = SCREEN_MARGIN + Math.random() * (W - SCREEN_MARGIN * 2);
            const y = topMargin + Math.random() * (H - topMargin - SCREEN_MARGIN);
            let valid = true;
            for (const d of dots) {
                if (Math.hypot(d.x - x, d.y - y) < MIN_DOT_DISTANCE) { valid = false; break; }
            }
            if (valid) {
                const type = pickDotType(tw);
                const typeDef = DOT_TYPES[type];
                const a = Math.random() * Math.PI * 2;
                const spd = (speedMin + Math.random() * (speedMax - speedMin)) * typeDef.speedMult;
                const vx = Math.cos(a) * spd;
                const vy = Math.sin(a) * spd;
                dots.push(new Dot(x, y, vx, vy, type));
            }
            attempts++;
        }
    }

    // =====================================================================
    // GAME STATE MANAGEMENT
    // =====================================================================
    function startRound() {
        roundRadiusScale = getRoundRadiusScale(round);
        recalcExplosionRadius();
        const params = getRoundParams(round);
        generateDots(params.dots, params.speedMin, params.speedMax, params.typeWeights);
        roundTotalDots = dots.length;  // Tell engine how many dots this round has (for relative celebrations)
        replayLog.push({ t: performance.now() - replayStartTime, type: 'round_start', data: {
            round,
            dots: dots.map(d => ({ x: d.x, y: d.y, vx: d.vx, vy: d.vy, type: d.type })),
        }});
        engineResetRound();
        lastChainFreqs = [];
        shakeTrauma = 0;
        bgPulse = 0;
        slowMo = 1.0;
        slowMoTarget = 1.0;
        gameState = 'playing';
    }

    // =====================================================================
    // CONTINUOUS PLAY STATE
    // =====================================================================
    let continuousActive = false;
    let currentTier = null;
    let spawnAccumulator = 0;
    let lastTapTime = -Infinity;
    let lastTapX = 0, lastTapY = 0;
    let contTotalTaps = 0;
    let contTotalScore = 0;
    let contDuration = 0;
    let contStartTime = 0;
    let overflowTimer = 0;
    let overflowTriggered = false;
    let densityHistory = [];
    let lastDensitySample = 0;
    let peakChainLength = 0;
    let contTotalCaught = 0;
    let contTotalSpawned = 0;
    let contChainCount = 0; // chain within current tap
    let contBestScore = parseInt(localStorage.getItem('cr_cont_bestScore') || '0', 10);

    // Overflow bloom state
    let overflowBloomTime = 0;
    let overflowBloomPhase = null;
    let overflowDots = [];
    let overflowDetonateIdx = 0;
    let overflowWhiteAlpha = 0;

    // =====================================================================
    // EPOCH SYSTEM
    // =====================================================================
    const EPOCHS = [
        { name: 'Dawn',          maxDensity: 0.20, bg: [2, 2, 16],   padChord: [0, 7] },
        { name: 'Gathering',     maxDensity: 0.40, bg: [8, 6, 24],   padChord: [2, 9] },
        { name: 'Flow',          maxDensity: 0.60, bg: [15, 10, 35], padChord: [4, 11] },
        { name: 'Surge',         maxDensity: 0.80, bg: [25, 12, 40], padChord: [5, 12] },
        { name: 'Transcendence', maxDensity: 1.01, bg: [35, 15, 50], padChord: [7, 14] },
    ];
    let currentEpochIdx = 0;
    let epochBlendFrom = EPOCHS[0];
    let epochBlendTo = EPOCHS[0];
    let epochTransition = 1; // 0→1 transition progress
    let peakEpochIdx = 0;

    function detectEpoch() {
        if (!currentTier || densityHistory.length < 2) return;

        // Rolling mean density (last 20 samples = ~10 seconds)
        const recent = densityHistory.slice(-20);
        const meanDensity = recent.reduce((s, h) => s + h.density, 0) / recent.length;

        let newIdx = 0;
        for (let i = 0; i < EPOCHS.length; i++) {
            if (meanDensity < EPOCHS[i].maxDensity) { newIdx = i; break; }
        }

        if (newIdx !== currentEpochIdx) {
            epochBlendFrom = { bg: [...getCurrentBg()] };
            epochBlendTo = EPOCHS[newIdx];
            epochTransition = 0;
            currentEpochIdx = newIdx;
            if (newIdx > peakEpochIdx) peakEpochIdx = newIdx;

            // Show epoch name
            spawnCelebration(EPOCHS[newIdx].name, 220, 0.8);

            // Update audio
            setEpochAudio(newIdx);
        }
    }

    function getCurrentBg() {
        if (epochTransition >= 1) return epochBlendTo.bg || EPOCHS[currentEpochIdx].bg;
        const f = epochBlendFrom.bg || [2, 2, 16];
        const t = epochBlendTo.bg || EPOCHS[currentEpochIdx].bg;
        const p = epochTransition;
        return [
            Math.round(f[0] + (t[0] - f[0]) * p),
            Math.round(f[1] + (t[1] - f[1]) * p),
            Math.round(f[2] + (t[2] - f[2]) * p),
        ];
    }

    function updateEpochVisuals() {
        if (!continuousActive) return;
        if (epochTransition < 1) {
            epochTransition = Math.min(1, epochTransition + 0.006); // ~3s at 60fps
        }
        bgOverride = getCurrentBg();
    }

    // --- Epoch Audio Layers ---
    let epochAudioLayers = { pad: null, melody: null, rhythm: null, bass: null };
    let epochMelodyInterval = null;
    let epochRhythmInterval = null;

    function setEpochAudio(epochIdx) {
        if (!audio.initialized || !audio.ctx) return;
        const c = audio.ctx;
        const now = c.currentTime;
        const fadeTime = 2.5;

        // Pad layer: always present, chord changes per epoch
        stopEpochLayer('pad');
        const epoch = EPOCHS[epochIdx];
        const padGain = c.createGain();
        padGain.gain.setValueAtTime(0, now);
        padGain.gain.linearRampToValueAtTime(0.04, now + fadeTime);
        padGain.connect(audio.masterGain);

        const padOscs = epoch.padChord.map(noteIdx => {
            const osc = c.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = SCALE_NOTES[noteIdx] * 0.5; // octave lower
            osc.connect(padGain);
            osc.start(now);
            return osc;
        });
        epochAudioLayers.pad = { gain: padGain, oscs: padOscs };

        // Melody layer: Gathering+ (epoch >= 1)
        stopEpochLayer('melody');
        if (epochIdx >= 1) {
            const melGain = c.createGain();
            melGain.gain.setValueAtTime(0, now);
            melGain.gain.linearRampToValueAtTime(0.025, now + fadeTime);
            melGain.connect(audio.masterGain);
            epochAudioLayers.melody = { gain: melGain, oscs: [] };

            // Schedule periodic arpeggiated notes
            let melBeat = 0;
            epochMelodyInterval = setInterval(() => {
                if (!audio.ctx || !continuousActive) { clearInterval(epochMelodyInterval); return; }
                const t = audio.ctx.currentTime;
                const noteIdx = epoch.padChord[melBeat % epoch.padChord.length] + (melBeat % 3 === 0 ? 0 : 5);
                const safeIdx = Math.min(noteIdx, SCALE_NOTES.length - 1);
                audio._voicePlay(SCALE_NOTES[safeIdx], 'triangle', 0.03, 0.01, 0.08, 0.3, 0.3, 0.8, t);
                melBeat++;
            }, MUSIC_BEAT_MS * 2);
        }

        // Rhythm layer: Flow+ (epoch >= 2)
        stopEpochLayer('rhythm');
        if (epochIdx >= 2) {
            const rhyGain = c.createGain();
            rhyGain.gain.setValueAtTime(0, now);
            rhyGain.gain.linearRampToValueAtTime(0.02, now + fadeTime);
            rhyGain.connect(audio.masterGain);
            epochAudioLayers.rhythm = { gain: rhyGain };

            epochRhythmInterval = setInterval(() => {
                if (!audio.ctx || !continuousActive) { clearInterval(epochRhythmInterval); return; }
                const t = audio.ctx.currentTime;
                // Noise burst through bandpass
                const buf = audio.ctx.createBuffer(1, Math.floor(audio.ctx.sampleRate * 0.03), audio.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audio.ctx.sampleRate * 0.008));
                const src = audio.ctx.createBufferSource();
                src.buffer = buf;
                const bp = audio.ctx.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.value = 800 + epochIdx * 200;
                bp.Q.value = 3;
                src.connect(bp);
                bp.connect(rhyGain);
                src.start(t);
            }, MUSIC_BEAT_MS / 2);
        }

        // Bass layer: Surge+ (epoch >= 3)
        stopEpochLayer('bass');
        if (epochIdx >= 3) {
            const bassGain = c.createGain();
            bassGain.gain.setValueAtTime(0, now);
            bassGain.gain.linearRampToValueAtTime(0.06, now + fadeTime);
            bassGain.connect(audio.masterGain);

            const bassOsc = c.createOscillator();
            bassOsc.type = 'sine';
            bassOsc.frequency.value = 65.41; // C2
            bassOsc.connect(bassGain);
            bassOsc.start(now);
            epochAudioLayers.bass = { gain: bassGain, oscs: [bassOsc] };
        }
    }

    function stopEpochLayer(name) {
        const layer = epochAudioLayers[name];
        if (!layer) return;
        try {
            if (layer.gain && audio.ctx) {
                layer.gain.gain.linearRampToValueAtTime(0, audio.ctx.currentTime + 0.5);
                setTimeout(() => {
                    try {
                        if (layer.oscs) layer.oscs.forEach(o => { try { o.stop(); } catch(e) {} });
                        layer.gain.disconnect();
                    } catch(e) {}
                }, 600);
            }
        } catch(e) {}
        epochAudioLayers[name] = null;
    }

    function stopAllEpochAudio() {
        stopEpochLayer('pad');
        stopEpochLayer('melody');
        stopEpochLayer('rhythm');
        stopEpochLayer('bass');
        if (epochMelodyInterval) { clearInterval(epochMelodyInterval); epochMelodyInterval = null; }
        if (epochRhythmInterval) { clearInterval(epochRhythmInterval); epochRhythmInterval = null; }
    }

    function startContinuous() {
        tiersVisited[selectedTier] = true;
        localStorage.setItem('cr_tiers_visited', JSON.stringify(tiersVisited));

        currentTier = CONTINUOUS_TIERS[selectedTier];
        continuousActive = true;
        spawnAccumulator = 0;
        lastTapTime = -Infinity;
        contTotalTaps = 0;
        contTotalScore = 0;
        contDuration = 0;
        contStartTime = performance.now();
        overflowTimer = 0;
        overflowTriggered = false;
        densityHistory = [];
        lastDensitySample = 0;
        peakChainLength = 0;
        contTotalCaught = 0;
        contTotalSpawned = 0;
        contChainCount = 0;
        currentEpochIdx = 0;
        epochBlendFrom = EPOCHS[0];
        epochBlendTo = EPOCHS[0];
        epochTransition = 1;
        peakEpochIdx = 0;
        bgOverride = EPOCHS[0].bg;
        stopAllEpochAudio();

        dots = [];
        lastSessionId = null;
        replayLog = [];
        replayStartTime = performance.now();
        engineResetRound();
        lastChainFreqs = [];
        shakeTrauma = 0;
        bgPulse = 0;
        slowMo = 1.0;
        slowMoTarget = 1.0;
        gameState = 'playing';
    }

    function updateOverflowBloom() {
        if (!overflowTriggered || overflowBloomPhase === 'summary') return;
        const dt = 16.67;
        overflowBloomTime += dt;

        if (overflowBloomPhase === 'detonating') {
            // Detonate 3 dots every ~50ms
            const dotsPerTick = 3;
            const tickInterval = 50;
            const dotsToDetonate = Math.min(
                overflowDots.length,
                Math.floor(overflowBloomTime / tickInterval) * dotsPerTick
            );

            while (overflowDetonateIdx < dotsToDetonate && overflowDetonateIdx < overflowDots.length) {
                const { dot } = overflowDots[overflowDetonateIdx];
                if (dot.active) {
                    dot.active = false;
                    dot.bloomTimer = 30;
                    chainCount++;
                    emitParticles(dot.x, dot.y, dot.getHue(), 1);
                    if (audio.initialized) {
                        const noteIdx = Math.min(overflowDetonateIdx % 20, SCALE_NOTES.length - 1);
                        audio.playChainNote(noteIdx, 1);
                    }
                }
                overflowDetonateIdx++;
            }

            // All detonated → hold phase
            if (overflowDetonateIdx >= overflowDots.length) {
                overflowBloomPhase = 'hold';
                overflowBloomTime = 0;
                screenFlash = 0.6;
                // Sustained chord
                if (audio.initialized) {
                    const chordNotes = [0, 4, 7, 9, 12];
                    chordNotes.forEach((n, i) => {
                        const safeIdx = Math.min(n, SCALE_NOTES.length - 1);
                        audio._voicePlay(SCALE_NOTES[safeIdx], 'sine', 0.08, 0.1, 0.3, 0.6, 2.0, 1.5, audio.ctx.currentTime + i * 0.06);
                    });
                }
                // Massive center burst
                emitCelebrationBurst(W / 2, H / 2, 200, 60);
                stopAllEpochAudio();
            }
        } else if (overflowBloomPhase === 'hold') {
            // Hold for 1.5s
            if (overflowBloomTime >= 1500) {
                overflowBloomPhase = 'fade';
                overflowBloomTime = 0;
            }
        } else if (overflowBloomPhase === 'fade') {
            // Fade to white over 1.5s
            overflowWhiteAlpha = Math.min(1, overflowBloomTime / 1500);
            if (overflowBloomTime >= 2000) {
                overflowBloomPhase = 'summary';
                summaryTimer = 0;
                // Save continuous session
                const recent = densityHistory.slice(-20);
                const md = recent.length > 0 ? recent.reduce((s, h) => s + h.density, 0) / recent.length : 0;
                API.saveSession([...replayLog], {
                    score: contTotalScore,
                    tier: selectedTier,
                    duration: contDuration,
                    finalDensity: getDensity(currentTier),
                    meanDensity: md,
                    totalTaps: contTotalTaps,
                });
                API.fetchLeaderboard('continuous', selectedTier);
            }
        }
    }

    function updateContinuous(now) {
        if (!continuousActive) return;

        // Handle overflow bloom animation
        if (overflowTriggered) {
            updateOverflowBloom();
            return;
        }
        const dt = 16.67; // assume ~60fps

        // Spawn tick
        spawnAccumulator += currentTier.spawnRate * (dt / 1000);
        while (spawnAccumulator >= 1 && countActiveDots() < currentTier.maxDots) {
            spawnAccumulator -= 1;
            spawnEdgeDot(currentTier);
            contTotalSpawned++;
        }
        if (spawnAccumulator > 3) spawnAccumulator = 3;

        // Duration
        contDuration = now - contStartTime;

        // Density sampling every 500ms
        if (now - lastDensitySample >= 500) {
            lastDensitySample = now;
            const d = getDensity(currentTier);
            densityHistory.push({ time: contDuration, density: d });
        }

        // Epoch detection + visual update
        detectEpoch();
        updateEpochVisuals();

        // Overflow check
        const density = getDensity(currentTier);
        if (density >= currentTier.overflowDensity) {
            overflowTimer += dt;
            if (overflowTimer >= 10000) {
                overflowTriggered = true;
                summaryTimer = 0;
                gameState = 'overflow';
                overflowBloomTime = 0;
                overflowBloomPhase = 'detonating'; // 'detonating' | 'hold' | 'fade' | 'summary'

                // Sort dots by distance from center for wave detonation
                overflowDots = dots.filter(d => d.active).map(d => ({
                    dot: d,
                    dist: Math.hypot(d.x - W / 2, d.y - H / 2),
                })).sort((a, b) => a.dist - b.dist);
                overflowDetonateIdx = 0;
                overflowWhiteAlpha = 0;
            }
        } else {
            overflowTimer = 0;
        }

        // When chain resolves, go back to playing
        if (gameState === 'resolving' && explosions.length === 0 && pendingExplosions.length === 0) {
            // Record chain length
            if (contChainCount > 0) {
                contTotalCaught += contChainCount;
                if (contChainCount > peakChainLength) peakChainLength = contChainCount;
            }
            contTotalScore += score;
            contChainCount = 0;
            // Reset chain state for next tap but keep dots
            chainCount = 0;
            score = 0;
            currentMultiplier = 1;
            lastCelebration = -1;
            gameState = 'playing';
        }
    }

    function handleContinuousTap(x, y) {
        const now = performance.now();
        const cooldownElapsed = now - lastTapTime;
        if (cooldownElapsed < currentTier.cooldown) {
            // Cooldown not ready — play miss sound as feedback
            return;
        }

        lastTapTime = now;
        lastTapX = x;
        lastTapY = y;
        contTotalTaps++;
        contChainCount = 0;

        // Set totalDots for multiplier calculation
        roundTotalDots = countActiveDots();
        chainCount = 0;
        score = 0;
        currentMultiplier = 1;
        lastCelebration = -1;

        audio.playTap();
        gameState = 'resolving';
        freezeFrames = HIT_FREEZE_FRAMES;

        replayLog.push({ t: now - replayStartTime, type: 'tap', data: { x, y, density: getDensity(currentTier), taps: contTotalTaps } });

        const exp = new Explosion(x, y, 0, explosionRadius, handleDotCaught);
        explosions.push(exp);

        // Check if tap hit anything
        let hitAny = false;
        for (const dot of dots) {
            if (dot.active && Math.hypot(dot.x - x, dot.y - y) <= explosionRadius) {
                hitAny = true;
                break;
            }
        }
        if (!hitAny) audio.playMiss();
    }

    function handleTap(x, y) {
        if (gameState === 'start') {
            audio.init();
            sessionCount++;
            localStorage.setItem('cr_session_count', sessionCount);

            if (gameMode === 'continuous') {
                startContinuous();
                return;
            }

            // Rounds mode
            round = 1;
            totalScore = 0;
            consecutiveFails = 0;
            mercyBonus = 0;
            supernovaCharge = 0;
            supernovaActive = false;
            supernovaTapsRemaining = 0;
            peakRound = 1;
            lastSessionId = null;
            replayLog = [];
            replayStartTime = performance.now();
            API.clearCheckpoint();
            startRound();
            return;
        }

        // Continuous mode: tap on summary → restart or go to start
        if (continuousActive && (gameState === 'overflow' || gameState === 'summary')) {
            continuousActive = false;
            overflowTriggered = false;
            bgOverride = null;
            stopAllEpochAudio();
            gameState = 'start';
            dots = [];
            generateDots(10, 0.5, 1.0);
            return;
        }

        if (gameState === 'gameover') {
            round = Math.max(1, round - SETBACK_ROUNDS);
            totalScore = Math.max(0, totalScore - score);
            consecutiveFails++;
            mercyBonus = Math.min(MERCY_RADIUS_CAP, consecutiveFails * MERCY_RADIUS_BONUS);
            startRound();
            return;
        }

        // Supernova: allow additional taps during chain resolution
        if (gameState === 'resolving' && supernovaActive && supernovaTapsRemaining > 0) {
            audio.playTap();
            supernovaTapsRemaining--;
            freezeFrames = HIT_FREEZE_FRAMES;
            replayLog.push({ t: performance.now() - replayStartTime, type: 'tap', data: { x, y, round, chainCount, supernova: true } });
            const effectiveRadius = explosionRadius * (1 + mercyBonus);
            const exp = new Explosion(x, y, 0, effectiveRadius, handleDotCaught);
            explosions.push(exp);
            let hitAny = false;
            for (const dot of dots) {
                if (dot.active && Math.hypot(dot.x - x, dot.y - y) <= explosionRadius) {
                    hitAny = true; break;
                }
            }
            if (!hitAny) audio.playMiss();
            return;
        }

        if (continuousActive && (gameState === 'playing' || gameState === 'resolving')) {
            handleContinuousTap(x, y);
            return;
        }

        if (gameState !== 'playing') return;

        audio.init();
        audio.playTap();

        replayLog.push({ t: performance.now() - replayStartTime, type: 'tap', data: { x, y, round, chainCount } });

        gameState = 'resolving';
        freezeFrames = HIT_FREEZE_FRAMES;
        if (supernovaActive) supernovaTapsRemaining--;

        const effectiveRadius = explosionRadius * (1 + mercyBonus);
        const exp = new Explosion(x, y, 0, effectiveRadius, handleDotCaught);
        explosions.push(exp);

        let hitAny = false;
        for (const dot of dots) {
            if (dot.active && Math.hypot(dot.x - x, dot.y - y) <= explosionRadius) {
                hitAny = true; break;
            }
        }
        if (!hitAny) audio.playMiss();
    }

    function checkRoundEnd() {
        if (explosions.length > 0 || pendingExplosions.length > 0) return;

        if (supernovaActive && supernovaTapsRemaining > 0) {
            gameState = 'playing';
            return;
        }

        const params = getRoundParams(round);
        if (chainCount >= params.target) {
            totalScore += score;
            if (round > bestRound) {
                bestRound = round;
                localStorage.setItem('cr3_bestRound', bestRound);
            }
            if (totalScore > bestScore) {
                bestScore = totalScore;
                localStorage.setItem('cr3_bestScore', bestScore);
            }

            consecutiveFails = 0;
            mercyBonus = 0;

            if (supernovaActive) {
                supernovaActive = false;
                audio.deactivateSupernova();
            } else {
                supernovaCharge++;
            }

            replayLog.push({ t: performance.now() - replayStartTime, type: 'clear', data: { round, chainCount, score, target: params.target } });

            spawnCelebration(`Round ${round} Clear!`, 200, 1.4);
            audio.playRoundClear();
            slowMoTarget = 0.6;

            round++;
            if (round > peakRound) peakRound = round;
            roundRadiusScale = getRoundRadiusScale(round);
            recalcExplosionRadius();
            API.saveCheckpoint();
            const nextParams = getRoundParams(round);
            generateDots(nextParams.dots, nextParams.speedMin, nextParams.speedMax, nextParams.typeWeights);
            roundTotalDots = dots.length;  // Update for relative celebrations

            // Record round_start for the new round (fixes replay multi-round bug)
            replayLog.push({ t: performance.now() - replayStartTime, type: 'round_start', data: {
                round,
                dots: dots.map(d => ({ x: d.x, y: d.y, vx: d.vx, vy: d.vy, type: d.type })),
            }});

            engineResetRound();
            lastChainFreqs = [];
            gameState = 'playing';

            if (supernovaCharge >= SUPERNOVA_CHARGE_NEEDED) {
                supernovaActive = true;
                supernovaTapsRemaining = SUPERNOVA_TAPS;
                supernovaCharge = 0;
                audio.activateSupernova();
                spawnCelebration('SUPERNOVA!', 45, 2.2);
                screenFlash = 0.5;
            }
        } else {
            supernovaCharge = 0;
            if (supernovaActive) {
                supernovaActive = false;
                audio.deactivateSupernova();
            }
            markNearMissDots();
            gameState = 'gameover';
            gameOverTimer = 0;
            audio.playGameOver();
            const frustration = params.target > 0 ? chainCount / params.target : 0;
            replayLog.push({ t: performance.now() - replayStartTime, type: 'fail', data: { round, chainCount, target: params.target, frustration: +frustration.toFixed(2) } });
            API.saveSession([...replayLog]);
        }
    }

    function markNearMissDots() {
        const nmRadius = explosionRadius * 1.2;
        for (const dot of dots) {
            if (!dot.active) continue;
            for (let i = 0; i < dots.length; i++) {
                const other = dots[i];
                if (other.active || other === dot) continue;
                if (Math.hypot(dot.x - other.x, dot.y - other.y) <= nmRadius) {
                    dot.nearMiss = 1.0;
                    break;
                }
            }
        }
    }

    // =====================================================================
    // UPDATE
    // =====================================================================
    let lastFrame = performance.now();

    function update() {
        const now = performance.now();
        lastFrame = now;

        if (freezeFrames > 0) { freezeFrames--; return; }

        // Music system
        if (audio.initialized && gameState !== 'start' && now >= nextMusicBeat) {
            nextMusicBeat = now + MUSIC_BEAT_MS;
            const idx = musicBeat % MUSIC_PATTERN.length;
            const [noteIdx, volMult] = MUSIC_PATTERN[idx];
            const musicVol = gameState === 'resolving' ? 0.08 : 0.20;
            audio.playMusicNote(noteIdx, musicVol * volMult);
            if (idx % 4 === 0) audio.playMusicBass(0);
            beatPulse = Math.max(beatPulse, idx % 4 === 0 ? 0.08 : 0.04);
            musicBeat++;
        }

        // Engine physics update
        engineUpdatePhysics();

        // Fever decay (game-specific: only when not resolving)
        if (gameState !== 'resolving' && feverIntensity > 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }

        // Slow-mo
        if (slowMo !== slowMoTarget) {
            slowMo += (slowMoTarget - slowMo) * 0.15;
            if (Math.abs(slowMo - slowMoTarget) < 0.01) slowMo = slowMoTarget;
        }
        if (slowMoTarget < 1 && explosions.length === 0 && pendingExplosions.length === 0) {
            slowMoTarget = 1.0;
        }

        if (gameState === 'gameover') {
            gameOverTimer = Math.min(1, gameOverTimer + 0.015);
        }

        // Continuous play update (spawning, overflow, chain resolution)
        if (continuousActive) {
            // Track chain count for current tap
            contChainCount = chainCount;
            updateContinuous(performance.now());
        } else if (gameState === 'resolving') {
            checkRoundEnd();
        }
    }

    // =====================================================================
    // DRAW
    // =====================================================================
    function draw() {
        engineDrawScene(ctx, gameState, supernovaActive);
        drawUI();
        drawSettingsIcon();
        // Settings panel slide animation
        if (settingsOpen && settingsSlideProgress < 1) {
            settingsSlideProgress = Math.min(1, settingsSlideProgress + 0.12);
        } else if (!settingsOpen && settingsSlideProgress > 0) {
            settingsSlideProgress = Math.max(0, settingsSlideProgress - 0.12);
        }
        drawSettingsPanel();
    }

    // =====================================================================
    // UI
    // =====================================================================
    function drawUI() {
        const params = getRoundParams(round);
        const screenMin = Math.min(W, H);
        const s = Math.max(1, screenMin / 600);

        if (gameState === 'start') { drawStartScreen(); return; }

        // Continuous mode
        if (continuousActive) {
            if (overflowTriggered) {
                // During bloom detonation/hold: show HUD + white fade overlay
                if (overflowBloomPhase !== 'summary') {
                    drawContinuousHUD(s);
                    if (overflowWhiteAlpha > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${overflowWhiteAlpha})`;
                        ctx.fillRect(0, 0, W, H);
                    }
                } else {
                    drawContinuousSummary(s);
                }
            } else {
                drawContinuousHUD(s);
            }
            return;
        }

        // Round counter
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.letterSpacing = '2px';
        ctx.fillText('ROUND', W/2, 14 * s);
        ctx.letterSpacing = '0px';

        ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillText(round, W/2, 28 * s);

        // Chain / target
        const infoY = 72 * s;
        if (gameState === 'resolving') {
            const targetMet = chainCount >= params.target;
            ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.save();
            ctx.shadowColor = targetMet ? 'rgba(255, 200, 60, 0.4)' : 'rgba(255,255,255,0.2)';
            ctx.shadowBlur = 6;
            ctx.fillStyle = targetMet ? 'rgba(255, 220, 100, 0.95)' : 'rgba(255,255,255,0.7)';
            ctx.fillText(`${chainCount} / ${params.target}`, W/2, infoY);
            ctx.restore();

            if (currentMultiplier > 1) {
                const mp = multiplierPulse > 0 ? 1 + easeOutBack(multiplierPulse) * 0.4 : 1;
                const multSize = Math.round(22 * s * mp);
                const multHue = currentMultiplier >= 5 ? 300 : currentMultiplier >= 3 ? 15 : 50;
                ctx.save();
                ctx.shadowColor = `hsla(${multHue}, 90%, 60%, 0.6)`;
                ctx.shadowBlur = 12 * s;
                ctx.font = `900 ${multSize}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${multHue}, 90%, 70%)`;
                ctx.fillText(`x${currentMultiplier}`, W/2, infoY + 22 * s);
                ctx.restore();
            }

            if (supernovaActive) {
                const tapY = infoY + (currentMultiplier > 1 ? 48 : 22) * s;
                ctx.font = `600 ${13 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 200, 60, 0.85)';
                if (supernovaTapsRemaining > 0) {
                    ctx.fillText(`${supernovaTapsRemaining} tap${supernovaTapsRemaining !== 1 ? 's' : ''} left`, W/2, tapY);
                }
                ctx.restore();
            }
        } else if (gameState === 'playing') {
            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillText(`Target: ${params.target}`, W/2, infoY);

            if (supernovaActive) {
                ctx.font = `600 ${13 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 200, 60, 0.85)';
                ctx.fillText(`SUPERNOVA — ${supernovaTapsRemaining} taps`, W/2, infoY + 18 * s);
                ctx.restore();
            } else if (mercyBonus > 0) {
                ctx.font = `300 ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.fillText(`+${Math.round(mercyBonus * 100)}% reach`, W/2, infoY + 18 * s);
            }
        }

        // Supernova charge meter
        if (!supernovaActive && supernovaCharge > 0 && (gameState === 'playing' || gameState === 'resolving')) {
            const meterY = 68 * s;
            const segW = 8 * s;
            const segH = 3 * s;
            const gap = 3 * s;
            const totalW = SUPERNOVA_CHARGE_NEEDED * segW + (SUPERNOVA_CHARGE_NEEDED - 1) * gap;
            const mx = W / 2 - totalW / 2;
            for (let i = 0; i < SUPERNOVA_CHARGE_NEEDED; i++) {
                const filled = i < supernovaCharge;
                ctx.fillStyle = filled ? 'rgba(255, 200, 60, 0.6)' : 'rgba(255, 255, 255, 0.08)';
                ctx.beginPath();
                ctx.roundRect(mx + i * (segW + gap), meterY, segW, segH, segH / 2);
                ctx.fill();
            }
        }

        if (gameState === 'gameover') drawGameOver();

        if (bestRound > 0 && gameState === 'playing') {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fillText(`Best: Round ${bestRound}`, W/2, H - 12 * s);
        }

        // Build info
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    function drawStartScreen() {
        uiButtons = [];

        // Animate swipe offsets
        if (Math.abs(modeSwipeOffset - modeSwipeTarget) > 1) {
            modeSwipeOffset += (modeSwipeTarget - modeSwipeOffset) * 0.15;
        } else {
            modeSwipeOffset = modeSwipeTarget;
        }
        if (Math.abs(tierSwipeOffset - tierSwipeTarget) > 1) {
            tierSwipeOffset += (tierSwipeTarget - tierSwipeOffset) * 0.15;
        } else {
            tierSwipeOffset = tierSwipeTarget;
        }

        // Draw both mode pages (one may be off-screen)
        const roundsX = gameMode === 'rounds' ? modeSwipeOffset : modeSwipeOffset - W;
        const contX = gameMode === 'rounds' ? modeSwipeOffset + W : modeSwipeOffset;

        ctx.save();
        // Clip to avoid overflow
        if (Math.abs(roundsX) < W) drawRoundsStartPage(roundsX);
        if (Math.abs(contX) < W) drawContinuousStartPage(contX);
        ctx.restore();

        // Page indicator dots
        const s = Math.max(1, Math.min(W, H) / 600);
        const indicatorY = H - 20 * s;
        const dotR = 3 * s;
        const dotGap = 14 * s;
        const pulseAlpha = sessionCount < 3 ? 0.15 + 0.15 * Math.sin(performance.now() * 0.004) : 0;
        for (let i = 0; i < 2; i++) {
            const dx = W / 2 + (i - 0.5) * dotGap;
            const isActive = (i === 0 && gameMode === 'rounds') || (i === 1 && gameMode === 'continuous');
            ctx.beginPath();
            ctx.arc(dx, indicatorY, dotR, 0, Math.PI * 2);
            ctx.fillStyle = isActive
                ? `rgba(255, 255, 255, ${0.6 + pulseAlpha})`
                : `rgba(255, 255, 255, ${0.15 + pulseAlpha})`;
            ctx.fill();
        }
    }

    function drawTitle(cx, titleY) {
        const titleSize = Math.min(52, W * 0.10);
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(120, 180, 255, 0.4)';
        ctx.shadowBlur = 40;
        ctx.font = `300 ${titleSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.98)';
        ctx.letterSpacing = `${Math.max(1, titleSize * 0.06)}px`;
        ctx.fillText('CHAIN REACTION', cx, titleY);
        ctx.shadowBlur = 60;
        ctx.shadowColor = 'rgba(100, 160, 255, 0.2)';
        ctx.fillText('CHAIN REACTION', cx, titleY);
        ctx.letterSpacing = '0px';
        ctx.restore();
    }

    function drawRoundsStartPage(offsetX) {
        const cx = W / 2 + offsetX;
        const titleSize = Math.min(52, W * 0.10);
        const subSize = Math.min(16, W * 0.038);
        const s = Math.max(1, Math.min(W, H) / 600);
        const titleY = H * 0.22;

        drawTitle(cx, titleY);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        ctx.font = `400 ${subSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText('Tap to start a chain reaction.', cx, titleY + titleSize * 0.8);

        // Mode label
        ctx.font = `200 ${Math.min(11, subSize * 0.7)}px Inter, system-ui, sans-serif`;
        ctx.letterSpacing = '3px';
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillText('ROUNDS', cx, titleY + titleSize * 0.8 + subSize * 1.2);
        ctx.letterSpacing = '0px';

        let resumeBtnBottom = titleY + titleSize * 0.8 + subSize * 2.5;
        if (resumeCheckpoint && resumeCheckpoint.round > 1) {
            const resumeRect = drawPill(ctx, cx, resumeBtnBottom, `Resume Round ${resumeCheckpoint.round}`, true, 120);
            uiButtons.push({ id: 'resume', ...resumeRect });
            resumeBtnBottom += 36 * s;
        }

        const promptAlpha = 0.2 + 0.12 * Math.sin(performance.now() * 0.003);
        ctx.font = `400 ${Math.min(14, subSize * 0.85)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = `rgba(255,255,255,${promptAlpha + 0.1})`;
        ctx.fillText(resumeCheckpoint && resumeCheckpoint.round > 1 ? 'Tap anywhere for new game' : 'Tap anywhere to begin', cx, resumeBtnBottom);

        if (bestRound > 0) {
            ctx.font = `200 ${Math.min(13, subSize * 0.8)}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillText(`Best: Round ${bestRound}`, cx, resumeBtnBottom + subSize * 2);
        }

        // Leaderboard — only draw when page is mostly visible
        if (Math.abs(offsetX) < W * 0.5 && leaderboard && leaderboard.byScore && leaderboard.byScore.length > 0) {
            const lbY = H * 0.56;
            const rowH = 18 * s;
            ctx.font = `600 ${11 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.letterSpacing = '2px';
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fillText('LEADERBOARD', cx, lbY);
            ctx.letterSpacing = '0px';

            const entries = leaderboard.byScore.slice(0, 5);
            for (let i = 0; i < entries.length; i++) {
                const e = entries[i];
                const ey = lbY + (i + 1) * rowH + 6 * s;
                const isMe = e.device_id === deviceId;
                ctx.font = `${isMe ? 600 : 300} ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = isMe ? 'rgba(255, 215, 0, 0.7)' : 'rgba(255,255,255,0.3)';
                const name = e.player_name || (e.is_bot ? 'Bot' : 'Anon');
                const label = `${i + 1}. ${name} — R${e.peak_round} — ${Number(e.total_score).toLocaleString()}`;
                ctx.fillText(label, cx, ey);

                const tw = ctx.measureText(label).width;
                ctx.fillStyle = isMe ? 'rgba(255, 215, 0, 0.15)' : 'rgba(255,255,255,0.08)';
                ctx.fillRect(cx - tw/2, ey + 6 * s, tw, 1);
                uiButtons.push({ id: `leaderboard_${i}`, sessionId: e.id, x: cx - tw/2 - 10, y: ey - rowH/2, w: tw + 20, h: rowH });
            }
        }

        // Bottom buttons
        const btnY = H - 50 * s;
        const watchRect = drawPill(ctx, cx, btnY, spectatorMode ? 'Bot: ON' : 'Watch Bot', spectatorMode, 55);
        uiButtons.push({ id: 'watch', ...watchRect });
    }

    function drawContinuousStartPage(offsetX) {
        const cx = W / 2 + offsetX;
        const titleSize = Math.min(52, W * 0.10);
        const subSize = Math.min(16, W * 0.038);
        const s = Math.max(1, Math.min(W, H) / 600);
        const titleY = H * 0.22;

        drawTitle(cx, titleY);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Mode label
        ctx.font = `200 ${Math.min(11, subSize * 0.7)}px Inter, system-ui, sans-serif`;
        ctx.letterSpacing = '3px';
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillText('CONTINUOUS', cx, titleY + titleSize * 0.8);
        ctx.letterSpacing = '0px';

        // Tier name
        const tierNameY = titleY + titleSize * 0.8 + subSize * 1.8;
        ctx.font = `300 ${Math.min(28, W * 0.06)}px Inter, system-ui, sans-serif`;
        ctx.letterSpacing = '4px';
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillText(selectedTier, cx, tierNameY);
        ctx.letterSpacing = '0px';

        // First-encounter description
        if (!tiersVisited[selectedTier]) {
            ctx.font = `300 ${Math.min(13, subSize * 0.8)}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fillText(TIER_DESCRIPTIONS[selectedTier], cx, tierNameY + 28 * s);
        }

        // Tier navigation hint
        const tierIdx = TIER_ORDER.indexOf(selectedTier);
        ctx.font = `200 ${9 * s}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        if (tierIdx > 0) {
            ctx.fillText('\u25B2 ' + TIER_ORDER[tierIdx - 1], cx, tierNameY - 32 * s);
        }
        if (tierIdx < TIER_ORDER.length - 1) {
            ctx.fillText(TIER_ORDER[tierIdx + 1] + ' \u25BC', cx, tierNameY + (tiersVisited[selectedTier] ? 28 : 48) * s);
        }

        // Tap prompt
        const promptAlpha = 0.2 + 0.12 * Math.sin(performance.now() * 0.003);
        ctx.font = `400 ${Math.min(14, subSize * 0.85)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = `rgba(255,255,255,${promptAlpha + 0.1})`;
        ctx.fillText('Tap anywhere to begin', cx, H * 0.55);

        // Best score
        if (contBestScore > 0) {
            ctx.font = `200 ${Math.min(13, subSize * 0.8)}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillText(`Best: ${contBestScore.toLocaleString()}`, cx, H * 0.55 + subSize * 2);
        }

        // Continuous leaderboard
        if (Math.abs(offsetX) < W * 0.5 && contLeaderboard && contLeaderboard.byScore && contLeaderboard.byScore.length > 0) {
            const lbY = H * 0.64;
            const rowH = 18 * s;
            ctx.font = `600 ${11 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.letterSpacing = '2px';
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fillText('LEADERBOARD', cx, lbY);
            ctx.letterSpacing = '0px';

            const entries = contLeaderboard.byScore.slice(0, 5);
            for (let i = 0; i < entries.length; i++) {
                const e = entries[i];
                const ey = lbY + (i + 1) * rowH + 6 * s;
                const isMe = e.device_id === deviceId;
                ctx.font = `${isMe ? 600 : 300} ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = isMe ? 'rgba(255, 215, 0, 0.7)' : 'rgba(255,255,255,0.3)';
                const name = e.player_name || (e.is_bot ? 'Bot' : 'Anon');
                const dur = e.duration_ms ? `${Math.floor(e.duration_ms / 60000)}:${String(Math.floor((e.duration_ms % 60000) / 1000)).padStart(2, '0')}` : '--';
                const label = `${i + 1}. ${name} — ${dur} — ${Number(e.total_score).toLocaleString()}`;
                ctx.fillText(label, cx, ey);

                const tw = ctx.measureText(label).width;
                ctx.fillStyle = isMe ? 'rgba(255, 215, 0, 0.15)' : 'rgba(255,255,255,0.08)';
                ctx.fillRect(cx - tw/2, ey + 6 * s, tw, 1);
                uiButtons.push({ id: `cont_leaderboard_${i}`, sessionId: e.id, x: cx - tw/2 - 10, y: ey - rowH/2, w: tw + 20, h: rowH });
            }
        }

        // Bottom buttons
        const btnY = H - 50 * s;
        const watchRect = drawPill(ctx, cx, btnY, spectatorMode ? 'Bot: ON' : 'Watch Bot', spectatorMode, 55);
        uiButtons.push({ id: 'watch', ...watchRect });
    }

    function drawContinuousHUD(s) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        // Score (large, centered)
        ctx.font = `700 ${32 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillText(contTotalScore.toLocaleString(), W / 2, 16 * s);

        // Duration (below score)
        const mins = Math.floor(contDuration / 60000);
        const secs = Math.floor((contDuration % 60000) / 1000);
        ctx.font = `200 ${12 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, W / 2, 50 * s);

        // Tier label (top right, subtle)
        ctx.textAlign = 'right';
        ctx.font = `200 ${10 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.letterSpacing = '2px';
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillText(selectedTier, W - 12 * s, 16 * s);
        ctx.letterSpacing = '0px';

        // Density bar (left side, vertical)
        if (currentTier) {
            const density = getDensity(currentTier);
            const barH = H * 0.3;
            const barW = 4 * s;
            const barX = 12 * s;
            const barY = H * 0.35;

            // Track
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.fillRect(barX, barY, barW, barH);

            // Fill (bottom up)
            const fillH = barH * Math.min(1, density);
            const densityHue = density >= 0.8 ? 0 : density >= 0.6 ? 30 : 200;
            ctx.fillStyle = `hsla(${densityHue}, 70%, 60%, 0.5)`;
            ctx.fillRect(barX, barY + barH - fillH, barW, fillH);

            // Critical line at 80%
            const critY = barY + barH * 0.2;
            ctx.strokeStyle = 'rgba(255, 80, 80, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(barX - 2, critY);
            ctx.lineTo(barX + barW + 6, critY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Density text
            ctx.textAlign = 'left';
            ctx.font = `200 ${8 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillText(`${(density * 100) | 0}%`, barX, barY + barH + 6 * s);
        }

        // Cooldown ring at last tap position
        if (lastTapTime > 0 && currentTier) {
            const now = performance.now();
            const elapsed = now - lastTapTime;
            const progress = Math.min(1, elapsed / currentTier.cooldown);
            if (progress < 1) {
                ctx.beginPath();
                ctx.arc(lastTapX, lastTapY, explosionRadius * 0.4, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress);
                ctx.strokeStyle = `rgba(120, 180, 255, ${0.4 * (1 - progress)})`;
                ctx.lineWidth = 2 * s;
                ctx.stroke();
            }
        }

        // Multiplier display (during chain)
        if (gameState === 'resolving' && currentMultiplier > 1) {
            const mHue = currentMultiplier >= 5 ? 45 : currentMultiplier >= 3 ? 200 : 180;
            const mScale = 1 + multiplierPulse * 0.3;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `700 ${20 * s * mScale | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `hsla(${mHue}, 80%, 65%, 0.8)`;
            ctx.fillText(`x${currentMultiplier}`, W / 2, 72 * s);
        }

        // Overflow warning
        if (overflowTimer > 2000) {
            const warningAlpha = 0.2 + 0.3 * Math.sin(performance.now() * 0.01);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `600 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255, 80, 80, ${warningAlpha})`;
            ctx.fillText('OVERFLOW', W / 2, H - 40 * s);
        }

        // Build info
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    let summaryTimer = 0;

    function drawContinuousSummary(s) {
        summaryTimer = Math.min(1, summaryTimer + 0.012);
        const t = easeOutCubic(summaryTimer);

        // Overlay
        ctx.fillStyle = `rgba(0, 0, 0, ${t * 0.6})`;
        ctx.fillRect(0, 0, W, H);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Title
        const scaleT = easeOutBack(Math.min(t * 1.5, 1));
        ctx.font = `600 ${24 * s * scaleT | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = `rgba(255,255,255,${t * 0.9})`;
        ctx.fillText('SESSION COMPLETE', W / 2, H * 0.22);

        // Tier
        ctx.font = `200 ${11 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.letterSpacing = '3px';
        ctx.fillStyle = `rgba(255,255,255,${t * 0.3})`;
        ctx.fillText(selectedTier, W / 2, H * 0.28);
        ctx.letterSpacing = '0px';

        if (t > 0.3) {
            const a = Math.min(1, (t - 0.3) * 3);
            // Score
            ctx.font = `700 ${36 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${a * 0.95})`;
            ctx.fillText(contTotalScore.toLocaleString(), W / 2, H * 0.38);

            // Duration
            const mins = Math.floor(contDuration / 60000);
            const secs = Math.floor((contDuration % 60000) / 1000);
            ctx.font = `300 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${a * 0.5})`;
            ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, W / 2, H * 0.44);
        }

        if (t > 0.5) {
            const a = Math.min(1, (t - 0.5) * 3);
            const statY = H * 0.54;
            const gap = 22 * s;
            ctx.font = `300 ${11 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${a * 0.4})`;
            ctx.fillText(`Peak Epoch: ${EPOCHS[peakEpochIdx].name}`, W / 2, statY);
            ctx.fillText(`Longest Chain: ${peakChainLength}`, W / 2, statY + gap);
            ctx.fillText(`Total Taps: ${contTotalTaps}`, W / 2, statY + gap * 2);
            ctx.fillText(`Dots Caught: ${contTotalCaught}`, W / 2, statY + gap * 3);

            // Best score
            if (contTotalScore > contBestScore) {
                contBestScore = contTotalScore;
                localStorage.setItem('cr_cont_bestScore', contBestScore);
                ctx.font = `600 ${13 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `rgba(255, 215, 0, ${a * 0.7})`;
                ctx.fillText('New Best!', W / 2, statY + gap * 4);
            }
        }

        if (t > 0.7) {
            const a = 0.2 + 0.15 * Math.sin(performance.now() * 0.003);
            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${a + 0.1})`;
            ctx.fillText('Tap to continue', W / 2, H * 0.82);
        }
    }

    function drawGameOver() {
        const t = easeOutCubic(gameOverTimer);
        const s = Math.max(1, Math.min(W, H) / 600);

        ctx.fillStyle = `rgba(0, 0, 0, ${t * 0.55})`;
        ctx.fillRect(0, 0, W, H);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const scaleT = easeOutBack(Math.min(t * 1.5, 1));
        ctx.save();
        ctx.shadowColor = 'rgba(255, 140, 60, 0.35)';
        ctx.shadowBlur = 30 * s;
        ctx.font = `300 ${Math.round(48 * s * scaleT)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fillText(`Round ${round}`, W/2, H/2 - 50 * s);
        ctx.restore();

        if (t > 0.3) {
            const t2 = easeOutCubic((t - 0.3) / 0.7);
            ctx.globalAlpha = t2;

            ctx.font = `300 ${18 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255, 160, 80, 0.85)';
            const params = getRoundParams(round);
            ctx.fillText(`Chain: ${chainCount} / ${params.target}`, W/2, H/2);

            if (chainCount < params.target && params.target > 0) {
                const ratio = chainCount / params.target;
                if (ratio >= 0.6) {
                    const needed = params.target - chainCount;
                    ctx.font = `400 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                    ctx.fillStyle = 'rgba(255, 210, 120, 0.65)';
                    ctx.fillText(`${needed} more ${needed === 1 ? 'dot' : 'dots'} to clear — So close!`, W/2, H/2 + 16 * s);
                }
            }

            ctx.font = `300 ${15 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText(`Total Score: ${totalScore + score}`, W/2, H/2 + 34 * s);

            if (round >= bestRound) {
                ctx.font = `600 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.fillText('New Best!', W/2, H/2 + 58 * s);
            }

            const restartRound = Math.max(1, round - SETBACK_ROUNDS);
            if (restartRound > 1) {
                ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Restart from Round ${restartRound}`, W/2, H/2 + 72 * s);
            }
        }

        if (t > 0.6) {
            const t3 = (t - 0.6) / 0.4;
            const pa = t3 * (0.3 + 0.1 * Math.sin(performance.now() * 0.003));
            ctx.font = `300 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${pa})`;
            ctx.fillText('Tap to try again', W/2, H/2 + 100 * s);

            const btnY = H - 50 * s;
            const nameLabel = playerName ? `Name: ${playerName}` : 'Set Name';
            const nameRect = drawPill(ctx, W / 2 - 90 * s, btnY, nameLabel, !!playerName, 180);
            uiButtons.push({ id: 'setname', ...nameRect });

            const watchRect = drawPill(ctx, W / 2, btnY, spectatorMode ? 'Bot: ON' : 'Watch Bot', spectatorMode, 55);
            uiButtons.push({ id: 'watch', ...watchRect });

            if (lastSessionId) {
                const replayRect = drawPill(ctx, W / 2 + 90 * s, btnY, 'Watch Replay', false, 200);
                uiButtons.push({ id: 'viewreplay', ...replayRect });
            }
        }

        ctx.globalAlpha = 1;
    }

    // =====================================================================
    // SPECTATOR BOT
    // =====================================================================
    function botFindBestTap() {
        const gridSize = 20;
        let bestX = W / 2, bestY = H / 2, bestCount = 0;
        const r = explosionRadius * (1 + mercyBonus);
        for (let gx = 0; gx < gridSize; gx++) {
            for (let gy = 0; gy < gridSize; gy++) {
                const x = (gx + 0.5) * W / gridSize;
                const y = (gy + 0.5) * H / gridSize;
                let count = 0;
                for (const d of dots) {
                    if (d.active && Math.hypot(d.x - x, d.y - y) <= r) count++;
                }
                if (count > bestCount) { bestCount = count; bestX = x; bestY = y; }
            }
        }
        return { x: bestX, y: bestY, count: bestCount };
    }

    function updateBot(now) {
        if (!spectatorMode) return;
        if (gameState === 'start') { handleTap(W / 2, H / 2); return; }
        if (gameState === 'gameover' && gameOverTimer > 0.8) { handleTap(W / 2, H / 2); return; }
        if (gameState !== 'playing') return;

        if (!botTarget && now - botLastScan > botScanInterval) {
            botLastScan = now;
            const best = botFindBestTap();
            if (best.count >= 1) {
                botTarget = {
                    x: best.x + (Math.random() - 0.5) * 20,
                    y: best.y + (Math.random() - 0.5) * 20,
                    count: best.count,
                };
                botThinkTimer = botReactionDelay + Math.random() * 200;
            }
        }

        if (botTarget) {
            botThinkTimer -= 16.67;
            if (botThinkTimer <= 0) {
                const fresh = botFindBestTap();
                if (fresh.count >= 1) {
                    handleTap(fresh.x + (Math.random() - 0.5) * 10, fresh.y + (Math.random() - 0.5) * 10);
                }
                botTarget = null;
                botLastScan = now;
            }
        }
    }

    function drawBotOverlay() {
        const s = Math.max(1, Math.min(W, H) / 600);

        if (spectatorMode && botTarget && gameState === 'playing') {
            const pulse = Math.sin(performance.now() * 0.008) * 0.3 + 0.7;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.4 * pulse;
            ctx.strokeStyle = 'rgba(255, 255, 100, 1)';
            ctx.lineWidth = 1.5;
            const cr = 15 * s;
            ctx.beginPath(); ctx.moveTo(botTarget.x - cr, botTarget.y); ctx.lineTo(botTarget.x + cr, botTarget.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(botTarget.x, botTarget.y - cr); ctx.lineTo(botTarget.x, botTarget.y + cr); ctx.stroke();
            ctx.globalAlpha = 0.15 * pulse;
            ctx.beginPath(); ctx.arc(botTarget.x, botTarget.y, explosionRadius * (1 + mercyBonus), 0, Math.PI * 2); ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }

        if (gameState === 'playing' || gameState === 'resolving') {
            const bx = 8 * s, by = 8 * s;
            const bw = spectatorMode ? 52 * s : 36 * s;
            const bh = 22 * s;
            const br = bh / 2;
            ctx.beginPath(); ctx.roundRect(bx, by, bw, bh, br);
            ctx.fillStyle = spectatorMode ? 'rgba(255, 255, 100, 0.12)' : 'rgba(255, 255, 255, 0.04)';
            ctx.fill();
            ctx.strokeStyle = spectatorMode ? 'rgba(255, 255, 100, 0.25)' : 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 0.5; ctx.stroke();
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `600 ${8 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = spectatorMode ? 'rgba(255, 255, 100, 0.5)' : 'rgba(255, 255, 255, 0.15)';
            ctx.fillText('BOT', bx + bw / 2, by + bh / 2);
            if (spectatorMode) {
                ctx.beginPath(); ctx.arc(bx + bw - 8 * s, by + bh / 2, 3 * s, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 255, 100, 0.6)'; ctx.fill();
            }
            uiButtons.push({ id: 'watch', x: bx, y: by, w: bw, h: bh });
        }
    }

    // =====================================================================
    // REPLAY DOWNLOAD
    // =====================================================================
    function downloadReplay() {
        if (replayLog.length === 0) return;
        const data = JSON.stringify({
            version: BUILD_VERSION, date: BUILD_DATE,
            viewport: { w: W, h: H },
            peakRound, bestRound, totalScore,
            events: replayLog,
        }, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `replay-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // =====================================================================
    // GAME LOOP
    // =====================================================================
    function loop() {
        const now = performance.now();
        uiButtons = [];
        updateBot(now);
        update();
        draw();
        drawBotOverlay();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // SETTINGS
    // =====================================================================
    let settingsOpen = false;
    let settingsSlideProgress = 0; // 0 = closed, 1 = open
    let settingsDragging = false;  // volume slider drag state
    const settings = {
        volume: parseFloat(localStorage.getItem('cr_volume') || '0.6'),
        shake: localStorage.getItem('cr_shake') || 'FULL',
        particles: localStorage.getItem('cr_particles') || 'FULL',
        reducedMotion: localStorage.getItem('cr_reduced_motion') === 'true',
        highContrast: localStorage.getItem('cr_high_contrast') === 'true',
    };

    function applySettings() {
        // Volume
        if (audio.masterGain) audio.masterGain.gain.value = settings.volume;
        // Shake
        if (settings.reducedMotion || settings.shake === 'OFF') {
            shakeEnabled = false;
        } else {
            shakeEnabled = true;
            shakeMultiplier = settings.shake === 'GENTLE' ? 0.4 : 1.0;
        }
        // Particles
        particleMultiplier = (settings.reducedMotion || settings.particles === 'REDUCED') ? 0.3 : 1.0;
        // Persist
        localStorage.setItem('cr_volume', settings.volume);
        localStorage.setItem('cr_shake', settings.shake);
        localStorage.setItem('cr_particles', settings.particles);
        localStorage.setItem('cr_reduced_motion', settings.reducedMotion);
        localStorage.setItem('cr_high_contrast', settings.highContrast);
    }
    applySettings(); // apply on boot

    function drawSettingsIcon() {
        if (gameState !== 'start' || settingsOpen) return;
        const s = Math.max(1, Math.min(W, H) / 600);
        const iconSize = 22 * s;
        const ix = W - 30 * s;
        const iy = 28 * s;
        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        // Circle
        ctx.beginPath();
        ctx.arc(ix, iy, iconSize * 0.45, 0, Math.PI * 2);
        ctx.stroke();
        // Three horizontal lines
        const lw = iconSize * 0.3;
        for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(ix - lw, iy + i * iconSize * 0.2);
            ctx.lineTo(ix + lw, iy + i * iconSize * 0.2);
            ctx.stroke();
        }
        ctx.restore();
        uiButtons.push({ id: 'settings', x: ix - iconSize/2, y: iy - iconSize/2, w: iconSize, h: iconSize });
    }

    function drawSettingsPanel() {
        if (settingsSlideProgress <= 0) return;
        const s = Math.max(1, Math.min(W, H) / 600);
        const panelW = Math.min(320 * s, W * 0.85);
        const slideX = W - panelW * settingsSlideProgress;

        // Backdrop
        ctx.fillStyle = `rgba(0, 0, 0, ${0.5 * settingsSlideProgress})`;
        ctx.fillRect(0, 0, W, H);

        // Panel
        ctx.fillStyle = 'rgba(8, 8, 24, 0.95)';
        ctx.fillRect(slideX, 0, panelW, H);

        // Panel border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(slideX, 0);
        ctx.lineTo(slideX, H);
        ctx.stroke();

        const px = slideX + 24 * s;
        const pw = panelW - 48 * s;
        let py = 40 * s;
        const rowH = 52 * s;

        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';

        // Close button
        const closeSize = 20 * s;
        const closeX = slideX + panelW - 30 * s;
        const closeY = 28 * s;
        ctx.font = `300 ${16 * s}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.textAlign = 'center';
        ctx.fillText('\u00D7', closeX, closeY);
        uiButtons.push({ id: 'settings_close', x: closeX - closeSize/2, y: closeY - closeSize/2, w: closeSize, h: closeSize });

        // Title
        ctx.textAlign = 'left';
        ctx.font = `600 ${13 * s}px Inter, system-ui, sans-serif`;
        ctx.letterSpacing = '2px';
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText('SETTINGS', px, py);
        ctx.letterSpacing = '0px';
        py += rowH * 0.8;

        // --- Volume ---
        ctx.font = `400 ${11 * s}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText('Volume', px, py);
        py += 20 * s;
        // Slider track
        const trackX = px;
        const trackW = pw;
        const trackY = py;
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(trackX, trackY - 2, trackW, 4);
        // Filled portion
        const fillW = trackW * settings.volume;
        ctx.fillStyle = 'rgba(120, 180, 255, 0.5)';
        ctx.fillRect(trackX, trackY - 2, fillW, 4);
        // Handle
        const handleX = trackX + fillW;
        ctx.beginPath();
        ctx.arc(handleX, trackY, 8 * s, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(120, 180, 255, 0.9)';
        ctx.fill();
        // Hit area for drag
        uiButtons.push({ id: 'volume_slider', x: trackX - 10, y: trackY - 20 * s, w: trackW + 20, h: 40 * s, trackX, trackW });
        py += rowH * 0.6;

        // --- Screen Shake ---
        py += 8 * s;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText('Screen Shake', px, py);
        py += 22 * s;
        const shakeOpts = ['OFF', 'GENTLE', 'FULL'];
        const segW = Math.floor(pw / 3);
        for (let i = 0; i < 3; i++) {
            const sx = px + i * segW;
            const active = settings.shake === shakeOpts[i];
            ctx.fillStyle = active ? 'rgba(120, 180, 255, 0.25)' : 'rgba(255,255,255,0.05)';
            ctx.fillRect(sx, py - 12 * s, segW - 2, 24 * s);
            ctx.fillStyle = active ? 'rgba(120, 180, 255, 0.9)' : 'rgba(255,255,255,0.35)';
            ctx.font = `${active ? 600 : 400} ${9 * s}px Inter, system-ui, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(shakeOpts[i], sx + segW / 2, py);
            uiButtons.push({ id: `shake_${shakeOpts[i]}`, x: sx, y: py - 12 * s, w: segW - 2, h: 24 * s });
        }
        ctx.textAlign = 'left';
        py += rowH * 0.7;

        // --- Particles ---
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = `400 ${11 * s}px Inter, system-ui, sans-serif`;
        ctx.fillText('Particles', px, py);
        py += 22 * s;
        const partOpts = ['REDUCED', 'FULL'];
        const partW = Math.floor(pw / 2);
        for (let i = 0; i < 2; i++) {
            const sx = px + i * partW;
            const active = settings.particles === partOpts[i];
            ctx.fillStyle = active ? 'rgba(120, 180, 255, 0.25)' : 'rgba(255,255,255,0.05)';
            ctx.fillRect(sx, py - 12 * s, partW - 2, 24 * s);
            ctx.fillStyle = active ? 'rgba(120, 180, 255, 0.9)' : 'rgba(255,255,255,0.35)';
            ctx.font = `${active ? 600 : 400} ${9 * s}px Inter, system-ui, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(partOpts[i], sx + partW / 2, py);
            uiButtons.push({ id: `particles_${partOpts[i]}`, x: sx, y: py - 12 * s, w: partW - 2, h: 24 * s });
        }
        ctx.textAlign = 'left';
        py += rowH * 0.8;

        // --- Divider ---
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(px, py, pw, 1);
        py += 16 * s;
        ctx.font = `600 ${10 * s}px Inter, system-ui, sans-serif`;
        ctx.letterSpacing = '1px';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillText('ACCESSIBILITY', px, py);
        ctx.letterSpacing = '0px';
        py += 24 * s;

        // --- Reduced Motion toggle ---
        drawToggle(px, py, pw, s, 'Reduced Motion', settings.reducedMotion, 'reduced_motion');
        py += rowH * 0.7;

        // --- High Contrast toggle ---
        drawToggle(px, py, pw, s, 'High Contrast', settings.highContrast, 'high_contrast');
    }

    function drawToggle(px, py, pw, s, label, active, id) {
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = `400 ${11 * s}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'left';
        ctx.fillText(label, px, py);
        // Toggle track
        const tw = 36 * s, th = 18 * s;
        const tx = px + pw - tw;
        const ty = py - th / 2;
        ctx.fillStyle = active ? 'rgba(120, 180, 255, 0.4)' : 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.roundRect(tx, ty, tw, th, th / 2);
        ctx.fill();
        // Toggle knob
        const knobX = active ? tx + tw - th / 2 : tx + th / 2;
        ctx.beginPath();
        ctx.arc(knobX, py, th * 0.35, 0, Math.PI * 2);
        ctx.fillStyle = active ? 'rgba(120, 180, 255, 0.95)' : 'rgba(255,255,255,0.4)';
        ctx.fill();
        uiButtons.push({ id: `toggle_${id}`, x: tx - 10, y: ty - 5, w: tw + 20, h: th + 10 });
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    function hitTestButtons(x, y) {
        for (const btn of uiButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                return btn;
            }
        }
        return null;
    }

    // --- Gesture state machine ---
    let pointerStartX = 0, pointerStartY = 0, pointerStartTime = 0;
    let pointerState = 'idle'; // 'idle' | 'pending' | 'swiping'
    let swipeDirection = null;
    const SWIPE_THRESHOLD_PX = 15;
    const TAP_MAX_DISPLACEMENT = 15;

    function handleButtonHit(x, y) {
        const hitBtn = hitTestButtons(x, y);
        const hit = hitBtn ? hitBtn.id : null;
        if (!hit) return false;

        if (hit === 'settings') { settingsOpen = true; return true; }
        if (hit === 'settings_close') { settingsOpen = false; return true; }

        // Settings controls
        if (hit === 'volume_slider') { return true; } // handled by drag
        if (hit.startsWith('shake_')) {
            settings.shake = hit.split('_')[1];
            applySettings();
            return true;
        }
        if (hit.startsWith('particles_')) {
            settings.particles = hit.split('_')[1];
            applySettings();
            return true;
        }
        if (hit === 'toggle_reduced_motion') {
            settings.reducedMotion = !settings.reducedMotion;
            if (settings.reducedMotion) {
                settings.shake = 'OFF';
                settings.particles = 'REDUCED';
            }
            applySettings();
            return true;
        }
        if (hit === 'toggle_high_contrast') {
            settings.highContrast = !settings.highContrast;
            applySettings();
            return true;
        }

        if (hit === 'watch') {
            spectatorMode = !spectatorMode;
            if (spectatorMode) { botTarget = null; botLastScan = 0; }
            return true;
        }
        if (hit === 'replay') { downloadReplay(); return true; }
        if (hit === 'resume' && resumeCheckpoint) {
            audio.init();
            round = resumeCheckpoint.round;
            totalScore = Number(resumeCheckpoint.total_score) || 0;
            consecutiveFails = resumeCheckpoint.consecutive_fails || 0;
            mercyBonus = resumeCheckpoint.mercy_bonus || 0;
            supernovaCharge = resumeCheckpoint.supernova_charge || 0;
            supernovaActive = false;
            supernovaTapsRemaining = 0;
            peakRound = round;
            lastSessionId = null;
            replayLog = [];
            replayStartTime = performance.now();
            startRound();
            return true;
        }
        if (hit === 'setname') {
            const name = prompt('Enter your name:', playerName || '');
            if (name !== null) {
                playerName = name.trim().slice(0, 20) || null;
                if (playerName) localStorage.setItem('cr_player_name', playerName);
                else localStorage.removeItem('cr_player_name');
            }
            return true;
        }
        if (hit === 'viewreplay' && lastSessionId) {
            window.open(`/replay/${lastSessionId}`, '_blank');
            return true;
        }
        if (hit && hit.startsWith('leaderboard_') && hitBtn.sessionId) {
            window.open(`/replay/${hitBtn.sessionId}`, '_blank');
            return true;
        }

        return false;
    }

    function dispatchSwipe(dir) {
        if (gameState !== 'start') return;

        // Horizontal: mode switch
        if (dir === 'left' && gameMode === 'rounds') {
            gameMode = 'continuous';
            modeSwipeTarget = 0;
            modeSwipeOffset = W; // animate from right
            localStorage.setItem('cr_game_mode', gameMode);
        } else if (dir === 'right' && gameMode === 'continuous') {
            gameMode = 'rounds';
            modeSwipeTarget = 0;
            modeSwipeOffset = -W; // animate from left
            localStorage.setItem('cr_game_mode', gameMode);
        }

        // Vertical: tier switch (only in continuous mode)
        if (gameMode === 'continuous') {
            const idx = TIER_ORDER.indexOf(selectedTier);
            if (dir === 'up' && idx < TIER_ORDER.length - 1) {
                selectedTier = TIER_ORDER[idx + 1];
                localStorage.setItem('cr_continuous_tier', selectedTier);
                API.fetchLeaderboard('continuous', selectedTier);
            } else if (dir === 'down' && idx > 0) {
                selectedTier = TIER_ORDER[idx - 1];
                localStorage.setItem('cr_continuous_tier', selectedTier);
                API.fetchLeaderboard('continuous', selectedTier);
            }
        }
    }

    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        const x = e.clientX, y = e.clientY;

        // Settings panel: handle interactions within panel
        if (settingsOpen) {
            // Check for volume slider drag start
            const volBtn = uiButtons.find(b => b.id === 'volume_slider');
            if (volBtn && x >= volBtn.x && x <= volBtn.x + volBtn.w && y >= volBtn.y && y <= volBtn.y + volBtn.h) {
                settingsDragging = true;
                settings.volume = Math.max(0, Math.min(1, (x - volBtn.trackX) / volBtn.trackW));
                applySettings();
                return;
            }
            // Check for button hits in settings
            if (handleButtonHit(x, y)) return;
            // Tap outside panel = close
            const panelW = Math.min(320 * Math.max(1, Math.min(W, H) / 600), W * 0.85);
            if (x < W - panelW) { settingsOpen = false; return; }
            return;
        }

        // During gameplay, skip gesture detection — immediate tap
        if (gameState !== 'start') {
            if (handleButtonHit(x, y)) return;
            if (!spectatorMode) handleTap(x, y);
            return;
        }

        // On start screen: begin gesture detection
        pointerStartX = x;
        pointerStartY = y;
        pointerStartTime = performance.now();
        pointerState = 'pending';
        swipeDirection = null;
    });

    canvas.addEventListener('pointermove', e => {
        if (settingsDragging) {
            const volBtn = uiButtons.find(b => b.id === 'volume_slider');
            if (volBtn) {
                settings.volume = Math.max(0, Math.min(1, (e.clientX - volBtn.trackX) / volBtn.trackW));
                applySettings();
            }
            return;
        }
        if (pointerState !== 'pending') return;
        const dx = e.clientX - pointerStartX;
        const dy = e.clientY - pointerStartY;
        const dist = Math.hypot(dx, dy);
        if (dist > SWIPE_THRESHOLD_PX) {
            pointerState = 'swiping';
            if (Math.abs(dx) > Math.abs(dy)) {
                swipeDirection = dx > 0 ? 'right' : 'left';
            } else {
                swipeDirection = dy > 0 ? 'down' : 'up';
            }
        }
    });

    canvas.addEventListener('pointerup', e => {
        if (settingsDragging) { settingsDragging = false; return; }
        const x = e.clientX, y = e.clientY;

        if (pointerState === 'swiping') {
            dispatchSwipe(swipeDirection);
            pointerState = 'idle';
            return;
        }

        if (pointerState === 'pending') {
            pointerState = 'idle';
            // Treat as tap on start screen
            if (handleButtonHit(x, y)) return;
            if (!spectatorMode) handleTap(x, y);
            return;
        }

        pointerState = 'idle';
    });

    canvas.addEventListener('pointercancel', () => { pointerState = 'idle'; settingsDragging = false; });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    document.addEventListener('keydown', e => {
        if (e.key === 'w' || e.key === 'W') {
            spectatorMode = !spectatorMode;
            if (spectatorMode) { botTarget = null; botLastScan = 0; }
        }
        if (e.key === 'r' || e.key === 'R') downloadReplay();
        if (e.key === 'Escape' && settingsOpen) settingsOpen = false;
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    generateDots(10, 0.5, 1.0);
    gameState = 'start';
    lastFrame = performance.now();
    if (spectatorMode) audio.init();
    loop();

    </script>
</body>
</html>
