<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: crosshair;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script src="engine.js"></script>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION — Game Client (uses shared engine.js)
    //
    // Architecture (line ranges):
    //   Game Constants ....... ~35-60    Setback, mercy, supernova, bot config
    //   Game State ........... ~63-108   Round, score, flags, leaderboard cache
    //   API Helpers .......... ~111-172  Session save, checkpoint, leaderboard fetch
    //   Music System ......... ~174-185  Background music via audio engine
    //   Resize ............... ~187-191  Delegates to engine.js
    //   Round Formula ........ ~194-214  getRoundParams(r) — dots, target, speeds, types
    //   Audio Engine ......... ~217-449  Web Audio API synthesis (all sounds)
    //   Dot Generation ....... ~462-497  Scatter dots with random velocities
    //   Game State Mgmt ...... ~500-683  startRound, handleTap, checkRoundEnd
    //   Update ............... ~685-730  Game loop tick (physics + round checks)
    //   Draw ................. ~732-1017 All rendering (HUD, screens, game over)
    //   Spectator Bot ........ ~1019-1110 Auto-play with greedy strategy
    //   Replay Download ...... ~1113-1130 Export replay as JSON
    //   Game Loop ............ ~1133-1143 requestAnimationFrame driver
    //   Input ................ ~1146-1216 Pointer + keyboard handlers
    //   Init ................. ~1218-1229 Boot sequence
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // GAME-SPECIFIC CONSTANTS
    // =====================================================================

    // Progression — setback + mercy
    const SETBACK_ROUNDS = 2;
    const MERCY_RADIUS_BONUS = 0.05;
    const MERCY_RADIUS_CAP = 0.15;

    // Supernova (multi-tap reward round)
    const SUPERNOVA_CHARGE_NEEDED = 3;
    const SUPERNOVA_TAPS = 3;

    // Audio
    const MAX_VOICES = 48;
    const SIXTEENTH_NOTE_SEC = (60 / 80) / 4;

    // Hit freeze
    const HIT_FREEZE_FRAMES = 3;

    // Ascending pentatonic scale
    const SCALE_NOTES = [
        130.81, 146.83, 164.81, 196.00, 220.00,
        261.63, 293.66, 329.63, 392.00, 440.00,
        523.25, 587.33, 659.25, 783.99, 880.00,
        1046.50, 1174.66, 1318.51, 1567.98, 1760.00,
    ];

    // =====================================================================
    // GAME STATE
    // =====================================================================
    let round = 0;
    let bestRound = parseInt(localStorage.getItem('cr3_bestRound') || '0', 10);
    let bestScore = parseInt(localStorage.getItem('cr3_bestScore') || '0', 10);
    let gameState = 'start';
    let freezeFrames = 0;
    let gameOverTimer = 0;
    let lastChainFreqs = [];
    let totalScore = 0;

    // Slow-mo (game-specific — engine has slowMo/slowMoTarget)

    // Progression state
    let consecutiveFails = 0;
    let mercyBonus = 0;
    let peakRound = 0;

    // Supernova state
    let supernovaCharge = 0;
    let supernovaActive = false;
    let supernovaTapsRemaining = 0;

    // Spectator mode (bot autoplay)
    const urlParams = new URLSearchParams(window.location.search);
    let spectatorMode = urlParams.has('watch');
    let botTarget = null;
    let botThinkTimer = 0;
    let botScanInterval = 400;
    let botLastScan = 0;
    let botReactionDelay = 600;

    // Replay recording
    let replayLog = [];
    let replayStartTime = 0;

    // UI buttons (computed in draw, hit-tested in input)
    let uiButtons = [];

    // Persistence
    let deviceId = localStorage.getItem('cr_device_id');
    if (!deviceId) { deviceId = crypto.randomUUID(); localStorage.setItem('cr_device_id', deviceId); }
    let playerName = localStorage.getItem('cr_player_name') || null;
    let resumeCheckpoint = null;
    let leaderboard = null;
    let lastSessionId = null;

    // =====================================================================
    // API HELPERS
    // =====================================================================
    const API = {
        async saveSession(events) {
            try {
                const res = await fetch('/api/session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device_id: deviceId,
                        player_name: playerName,
                        peak_round: peakRound,
                        total_score: totalScore + score,
                        is_bot: spectatorMode,
                        viewport_w: W,
                        viewport_h: H,
                        build_ver: BUILD_VERSION,
                        events,
                    }),
                    keepalive: true,
                });
                const data = await res.json();
                if (data.id) lastSessionId = data.id;
                return data;
            } catch (e) { console.warn('saveSession failed:', e); }
        },
        saveCheckpoint() {
            fetch('/api/checkpoint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    device_id: deviceId,
                    round, total_score: totalScore,
                    consecutive_fails: consecutiveFails,
                    mercy_bonus: mercyBonus,
                    supernova_charge: supernovaCharge,
                }),
                keepalive: true,
            }).catch(() => {});
        },
        clearCheckpoint() {
            fetch(`/api/checkpoint/${encodeURIComponent(deviceId)}`, {
                method: 'DELETE', keepalive: true,
            }).catch(() => {});
        },
        async fetchLeaderboard() {
            try {
                const res = await fetch('/api/leaderboard');
                leaderboard = await res.json();
            } catch (e) { console.warn('fetchLeaderboard failed:', e); }
        },
        async fetchCheckpoint() {
            try {
                const res = await fetch(`/api/checkpoint/${encodeURIComponent(deviceId)}`);
                const data = await res.json();
                resumeCheckpoint = data;
            } catch (e) { console.warn('fetchCheckpoint failed:', e); }
        },
    };

    Promise.all([API.fetchLeaderboard(), API.fetchCheckpoint()]).catch(() => {});

    // =====================================================================
    // MUSIC SYSTEM
    // =====================================================================
    const MUSIC_PATTERN = [
        [5,1.0],[7,0.7],[8,0.9],[10,0.6],
        [9,0.8],[8,0.7],[7,0.9],[5,0.6],
        [3,1.0],[4,0.7],[5,0.9],[7,0.6],
        [8,0.8],[7,0.7],[5,0.9],[3,0.5],
    ];
    let musicBeat = 0;
    let nextMusicBeat = 0;
    const MUSIC_BEAT_MS = 750;

    // =====================================================================
    // RESIZE (delegates to engine)
    // =====================================================================
    function resize() { engineResize(canvas); }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // ROUND FORMULA
    // =====================================================================
    function getRoundParams(r) {
        const numDots = Math.min(60, Math.floor(10 + r * 2.5));
        const pct = Math.min(0.80, 0.05 + (r - 1) * 0.028);
        const target = Math.max(1, Math.ceil(numDots * pct));
        const speedMin = 0.7 + Math.min(0.6, (r - 1) * 0.04);
        const speedMax = 1.4 + Math.min(1.2, (r - 1) * 0.07);
        let typeWeights;
        if (r <= 2) {
            typeWeights = { standard: 1.0 };
        } else if (r <= 4) {
            const gw = Math.min(0.25, (r - 2) * 0.12);
            typeWeights = { standard: 1 - gw, gravity: gw };
        } else {
            const gw = Math.min(0.25, 0.12 + (r - 4) * 0.03);
            const vw = Math.min(0.20, (r - 4) * 0.08);
            typeWeights = { standard: Math.max(0.5, 1 - gw - vw), gravity: gw, volatile: vw };
        }
        return { dots: numDots, target, pct, speedMin, speedMax, typeWeights };
    }

    // =====================================================================
    // AUDIO ENGINE
    // =====================================================================
    const audio = {
        ctx: null,
        masterGain: null,
        compressor: null,
        delayNode: null,
        voices: [],
        initialized: false,

        init() {
            if (this.initialized) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.ctx.resume();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.6;
            this.compressor = this.ctx.createDynamicsCompressor();
            this.compressor.threshold.value = -18;
            this.compressor.knee.value = 12;
            this.compressor.ratio.value = 6;
            this.delayNode = this._createDelay(0.18, 0.25, 0.18);
            this.masterGain.connect(this.compressor);
            this.compressor.connect(this.delayNode.input);
            this.delayNode.output.connect(this.ctx.destination);
            setTimeout(() => {
                const reverb = this._createReverb(2.0, 3.0, 0.22);
                this.delayNode.output.disconnect();
                this.delayNode.output.connect(reverb.input);
                reverb.output.connect(this.ctx.destination);
            }, 0);
            this.initialized = true;
            this.gridOrigin = this.ctx.currentTime;
        },

        playChainNote(chainIndex, generation) {
            if (!this.initialized) return;
            const now = this.ctx.currentTime;
            const elapsed = now - this.gridOrigin;
            const gridPos = Math.round(elapsed / SIXTEENTH_NOTE_SEC);
            let at = this.gridOrigin + gridPos * SIXTEENTH_NOTE_SEC;
            if (at < now) at += SIXTEENTH_NOTE_SEC;
            const noteIdx = Math.min(chainIndex, SCALE_NOTES.length - 1);
            const baseFreq = SCALE_NOTES[noteIdx];
            const detune = (Math.random() - 0.5) * 12;
            const freq = baseFreq * Math.pow(2, detune / 1200);
            lastChainFreqs.push(baseFreq);
            const chainBoost = Math.min(1.8, 1 + chainIndex * 0.03);
            let attack, decay, susLvl, susTime, release, vol;
            if (generation === 0) {
                attack = 0.001; decay = 0.04; susLvl = 0.4;
                susTime = 0.12; release = 0.6; vol = 0.24 * chainBoost;
            } else {
                attack = 0.003; decay = 0.03; susLvl = 0.35;
                susTime = 0.08; release = 0.5 + Math.min(0.3, generation * 0.02);
                vol = Math.max(0.08, 0.22 * chainBoost - generation * 0.005);
            }
            this._voicePlay(freq, 'triangle', vol, attack, decay, susLvl, susTime, release, at);
            this._voicePlay(freq, 'sine', vol * 0.5, 0.001, 0.01, 0, 0, 0.03, at);
            if (chainIndex >= 2) this._voicePlay(freq * 2, 'sine', vol * 0.12, 0.003, 0.03, 0.15, 0.03, 0.4, at);
            if (chainIndex < 4) this._voicePlay(freq * 0.5, 'sine', vol * 0.1, 0.01, 0.06, 0.2, 0.06, 0.5, at);
            if (chainIndex >= 6) this._voicePlay(freq * 1.5, 'sine', vol * 0.08, 0.005, 0.04, 0.12, 0.04, 0.4, at);
        },

        playMusicNote(noteIdx, vol) {
            if (!this.initialized) return;
            this._voicePlay(SCALE_NOTES[noteIdx], 'triangle', vol, 0.01, 0.08, 0.5, 0.4, 1.0);
        },

        playMusicBass(noteIdx) {
            if (!this.initialized) return;
            this._voicePlay(SCALE_NOTES[noteIdx], 'sine', 0.12, 0.05, 0.1, 0.3, 0.5, 1.0);
        },

        playMiss() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const buf = c.createBuffer(1, Math.floor(c.sampleRate * 0.08), c.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (c.sampleRate * 0.02));
            const src = c.createBufferSource(); src.buffer = buf;
            const f = c.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 600;
            const g = c.createGain();
            g.gain.setValueAtTime(0.0001, now);
            g.gain.linearRampToValueAtTime(0.06, now + 0.002);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.06);
            src.connect(f); f.connect(g); g.connect(this.ctx.destination);
            src.start(now); src.stop(now + 0.08);
            src.onended = () => { src.disconnect(); f.disconnect(); g.disconnect(); };
        },

        playTap() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const osc = c.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
            const g = c.createGain();
            g.gain.setValueAtTime(0.15, now);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
            osc.connect(g); g.connect(this.masterGain);
            osc.start(now); osc.stop(now + 0.2);
            osc.onended = () => { osc.disconnect(); g.disconnect(); };
        },

        playCelebration(level) {
            if (!this.initialized) return;
            const baseIdx = Math.min(10, level * 2);
            for (let i = 0; i < 4; i++) {
                const idx = Math.min(SCALE_NOTES.length - 1, baseIdx + i);
                setTimeout(() => {
                    this._voicePlay(SCALE_NOTES[idx], 'sine', 0.14, 0.01, 0.08, 0.6, 0.15, 1.2);
                    this._voicePlay(SCALE_NOTES[idx] * 2, 'sine', 0.04, 0.02, 0.05, 0.3, 0.1, 0.8);
                }, i * 80);
            }
        },

        playRoundClear() {
            if (!this.initialized) return;
            const chord = [
                SCALE_NOTES[5], SCALE_NOTES[7], SCALE_NOTES[8],
                SCALE_NOTES[10], SCALE_NOTES[12],
            ];
            chord.forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'sine', 0.12, 0.15, 0.1, 0.7, 1.0, 2.0);
                    this._voicePlay(f * 2, 'sine', 0.03, 0.2, 0.08, 0.4, 0.8, 1.5);
                }, i * 60);
            });
        },

        playGameOver() {
            if (!this.initialized) return;
            [220, 196, 164.81].forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'triangle', 0.10, 0.1, 0.15, 0.5, 0.3, 1.5);
                }, i * 150);
            });
        },

        _voicePlay(freq, type, vol, attack, decay, susLvl, susTime, release, at) {
            while (this.voices.length >= MAX_VOICES) {
                const old = this.voices.shift();
                try {
                    old.gain.gain.setValueAtTime(old.gain.gain.value, this.ctx.currentTime);
                    old.gain.gain.linearRampToValueAtTime(0.0001, this.ctx.currentTime + 0.005);
                    old.osc.stop(this.ctx.currentTime + 0.01);
                } catch(e) {}
            }
            const c = this.ctx; const now = at !== undefined ? at : c.currentTime;
            const osc = c.createOscillator();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, now);
            const env = c.createGain();
            env.gain.setValueAtTime(0.0001, now);
            env.gain.linearRampToValueAtTime(vol, now + attack);
            env.gain.linearRampToValueAtTime(vol * susLvl, now + attack + decay);
            const relStart = now + attack + decay + susTime;
            env.gain.setValueAtTime(vol * susLvl, relStart);
            env.gain.exponentialRampToValueAtTime(0.0001, relStart + release);
            osc.connect(env); env.connect(this.masterGain);
            osc.start(now); osc.stop(relStart + release + 0.05);
            const voice = { osc, gain: env };
            this.voices.push(voice);
            osc.onended = () => {
                osc.disconnect(); env.disconnect();
                const idx = this.voices.indexOf(voice);
                if (idx !== -1) this.voices.splice(idx, 1);
            };
        },

        _createDelay(time, feedback, wet) {
            const c = this.ctx;
            const input = c.createGain(), output = c.createGain();
            const delay = c.createDelay(2.0), fb = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            const filt = c.createBiquadFilter();
            delay.delayTime.value = time; fb.gain.value = feedback;
            wetG.gain.value = wet; dryG.gain.value = 1.0;
            filt.type = 'lowpass'; filt.frequency.value = 2500;
            input.connect(dryG); dryG.connect(output);
            input.connect(delay); delay.connect(filt); filt.connect(fb); fb.connect(delay);
            delay.connect(wetG); wetG.connect(output);
            return { input, output };
        },

        _createReverb(dur, dec, mix) {
            const c = this.ctx;
            const len = Math.floor(c.sampleRate * dur);
            const buf = c.createBuffer(2, len, c.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const d = buf.getChannelData(ch);
                for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-dec * (i / c.sampleRate));
            }
            const conv = c.createConvolver(); conv.buffer = buf;
            const input = c.createGain(), output = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            wetG.gain.value = mix; dryG.gain.value = 1.0;
            input.connect(dryG); dryG.connect(output);
            input.connect(conv); conv.connect(wetG); wetG.connect(output);
            return { input, output };
        },

        activateSupernova() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            this._snFilter = c.createBiquadFilter();
            this._snFilter.type = 'lowpass';
            this._snFilter.frequency.setValueAtTime(20000, now);
            this._snFilter.frequency.exponentialRampToValueAtTime(800, now + 0.5);
            this._snFilter.Q.value = 1.5;
            this.masterGain.disconnect();
            this.masterGain.connect(this._snFilter);
            this._snFilter.connect(this.compressor);
        },

        deactivateSupernova() {
            if (!this.initialized || !this._snFilter) return;
            const c = this.ctx; const now = c.currentTime;
            this._snFilter.frequency.setValueAtTime(this._snFilter.frequency.value, now);
            this._snFilter.frequency.exponentialRampToValueAtTime(20000, now + 0.3);
            const filter = this._snFilter;
            this._snFilter = null;
            setTimeout(() => {
                try {
                    this.masterGain.disconnect();
                    this.masterGain.connect(this.compressor);
                    filter.disconnect();
                } catch(e) {}
            }, 400);
        }
    };

    // =====================================================================
    // AUDIO CALLBACK FOR ENGINE
    // =====================================================================
    onDetonateAudio = function(chainOrEvent, param) {
        if (chainOrEvent === 'celebration') {
            audio.playCelebration(param);
        } else {
            audio.playChainNote(chainOrEvent - 1, param);
        }
    };

    // =====================================================================
    // DOT GENERATION (game-specific — uses random velocities)
    // =====================================================================
    function pickDotType(typeWeights) {
        const r = Math.random();
        let sum = 0;
        for (const [type, weight] of Object.entries(typeWeights)) {
            sum += weight;
            if (r <= sum) return type;
        }
        return 'standard';
    }

    function generateDots(count, speedMin, speedMax, typeWeights) {
        dots = [];
        let attempts = 0;
        const topMargin = SCREEN_MARGIN + 50;
        const tw = typeWeights || { standard: 1.0 };
        while (dots.length < count && attempts < 5000) {
            const x = SCREEN_MARGIN + Math.random() * (W - SCREEN_MARGIN * 2);
            const y = topMargin + Math.random() * (H - topMargin - SCREEN_MARGIN);
            let valid = true;
            for (const d of dots) {
                if (Math.hypot(d.x - x, d.y - y) < MIN_DOT_DISTANCE) { valid = false; break; }
            }
            if (valid) {
                const type = pickDotType(tw);
                const typeDef = DOT_TYPES[type];
                const a = Math.random() * Math.PI * 2;
                const spd = (speedMin + Math.random() * (speedMax - speedMin)) * typeDef.speedMult;
                const vx = Math.cos(a) * spd;
                const vy = Math.sin(a) * spd;
                dots.push(new Dot(x, y, vx, vy, type));
            }
            attempts++;
        }
    }

    // =====================================================================
    // GAME STATE MANAGEMENT
    // =====================================================================
    function startRound() {
        roundRadiusScale = getRoundRadiusScale(round);
        recalcExplosionRadius();
        const params = getRoundParams(round);
        generateDots(params.dots, params.speedMin, params.speedMax, params.typeWeights);
        replayLog.push({ t: performance.now() - replayStartTime, type: 'round_start', data: {
            round,
            dots: dots.map(d => ({ x: d.x, y: d.y, vx: d.vx, vy: d.vy, type: d.type })),
        }});
        engineResetRound();
        lastChainFreqs = [];
        shakeTrauma = 0;
        bgPulse = 0;
        slowMo = 1.0;
        slowMoTarget = 1.0;
        gameState = 'playing';
    }

    function handleTap(x, y) {
        if (gameState === 'start') {
            audio.init();
            round = 1;
            totalScore = 0;
            consecutiveFails = 0;
            mercyBonus = 0;
            supernovaCharge = 0;
            supernovaActive = false;
            supernovaTapsRemaining = 0;
            peakRound = 1;
            lastSessionId = null;
            replayLog = [];
            replayStartTime = performance.now();
            API.clearCheckpoint();
            startRound();
            return;
        }

        if (gameState === 'gameover') {
            round = Math.max(1, round - SETBACK_ROUNDS);
            totalScore = Math.max(0, totalScore - score);
            consecutiveFails++;
            mercyBonus = Math.min(MERCY_RADIUS_CAP, consecutiveFails * MERCY_RADIUS_BONUS);
            startRound();
            return;
        }

        // Supernova: allow additional taps during chain resolution
        if (gameState === 'resolving' && supernovaActive && supernovaTapsRemaining > 0) {
            audio.playTap();
            supernovaTapsRemaining--;
            freezeFrames = HIT_FREEZE_FRAMES;
            replayLog.push({ t: performance.now() - replayStartTime, type: 'tap', data: { x, y, round, chainCount, supernova: true } });
            const effectiveRadius = explosionRadius * (1 + mercyBonus);
            const exp = new Explosion(x, y, 0, effectiveRadius, handleDotCaught);
            explosions.push(exp);
            let hitAny = false;
            for (const dot of dots) {
                if (dot.active && Math.hypot(dot.x - x, dot.y - y) <= explosionRadius) {
                    hitAny = true; break;
                }
            }
            if (!hitAny) audio.playMiss();
            return;
        }

        if (gameState !== 'playing') return;

        audio.init();
        audio.playTap();

        replayLog.push({ t: performance.now() - replayStartTime, type: 'tap', data: { x, y, round, chainCount } });

        gameState = 'resolving';
        freezeFrames = HIT_FREEZE_FRAMES;
        if (supernovaActive) supernovaTapsRemaining--;

        const effectiveRadius = explosionRadius * (1 + mercyBonus);
        const exp = new Explosion(x, y, 0, effectiveRadius, handleDotCaught);
        explosions.push(exp);

        let hitAny = false;
        for (const dot of dots) {
            if (dot.active && Math.hypot(dot.x - x, dot.y - y) <= explosionRadius) {
                hitAny = true; break;
            }
        }
        if (!hitAny) audio.playMiss();
    }

    function checkRoundEnd() {
        if (explosions.length > 0 || pendingExplosions.length > 0) return;

        if (supernovaActive && supernovaTapsRemaining > 0) {
            gameState = 'playing';
            return;
        }

        const params = getRoundParams(round);
        if (chainCount >= params.target) {
            totalScore += score;
            if (round > bestRound) {
                bestRound = round;
                localStorage.setItem('cr3_bestRound', bestRound);
            }
            if (totalScore > bestScore) {
                bestScore = totalScore;
                localStorage.setItem('cr3_bestScore', bestScore);
            }

            consecutiveFails = 0;
            mercyBonus = 0;

            if (supernovaActive) {
                supernovaActive = false;
                audio.deactivateSupernova();
            } else {
                supernovaCharge++;
            }

            replayLog.push({ t: performance.now() - replayStartTime, type: 'clear', data: { round, chainCount, score, target: params.target } });

            spawnCelebration(`Round ${round} Clear!`, 200, 1.4);
            audio.playRoundClear();
            slowMoTarget = 0.6;

            round++;
            if (round > peakRound) peakRound = round;
            roundRadiusScale = getRoundRadiusScale(round);
            recalcExplosionRadius();
            API.saveCheckpoint();
            const nextParams = getRoundParams(round);
            generateDots(nextParams.dots, nextParams.speedMin, nextParams.speedMax, nextParams.typeWeights);

            // Record round_start for the new round (fixes replay multi-round bug)
            replayLog.push({ t: performance.now() - replayStartTime, type: 'round_start', data: {
                round,
                dots: dots.map(d => ({ x: d.x, y: d.y, vx: d.vx, vy: d.vy, type: d.type })),
            }});

            engineResetRound();
            lastChainFreqs = [];
            gameState = 'playing';

            if (supernovaCharge >= SUPERNOVA_CHARGE_NEEDED) {
                supernovaActive = true;
                supernovaTapsRemaining = SUPERNOVA_TAPS;
                supernovaCharge = 0;
                audio.activateSupernova();
                spawnCelebration('SUPERNOVA!', 45, 2.2);
                screenFlash = 0.5;
            }
        } else {
            supernovaCharge = 0;
            if (supernovaActive) {
                supernovaActive = false;
                audio.deactivateSupernova();
            }
            markNearMissDots();
            gameState = 'gameover';
            gameOverTimer = 0;
            audio.playGameOver();
            const frustration = params.target > 0 ? chainCount / params.target : 0;
            replayLog.push({ t: performance.now() - replayStartTime, type: 'fail', data: { round, chainCount, target: params.target, frustration: +frustration.toFixed(2) } });
            API.saveSession([...replayLog]);
        }
    }

    function markNearMissDots() {
        const nmRadius = explosionRadius * 1.2;
        for (const dot of dots) {
            if (!dot.active) continue;
            for (let i = 0; i < dots.length; i++) {
                const other = dots[i];
                if (other.active || other === dot) continue;
                if (Math.hypot(dot.x - other.x, dot.y - other.y) <= nmRadius) {
                    dot.nearMiss = 1.0;
                    break;
                }
            }
        }
    }

    // =====================================================================
    // UPDATE
    // =====================================================================
    let lastFrame = performance.now();

    function update() {
        const now = performance.now();
        lastFrame = now;

        if (freezeFrames > 0) { freezeFrames--; return; }

        // Music system
        if (audio.initialized && gameState !== 'start' && now >= nextMusicBeat) {
            nextMusicBeat = now + MUSIC_BEAT_MS;
            const idx = musicBeat % MUSIC_PATTERN.length;
            const [noteIdx, volMult] = MUSIC_PATTERN[idx];
            const musicVol = gameState === 'resolving' ? 0.08 : 0.20;
            audio.playMusicNote(noteIdx, musicVol * volMult);
            if (idx % 4 === 0) audio.playMusicBass(0);
            beatPulse = Math.max(beatPulse, idx % 4 === 0 ? 0.08 : 0.04);
            musicBeat++;
        }

        // Engine physics update
        engineUpdatePhysics();

        // Fever decay (game-specific: only when not resolving)
        if (gameState !== 'resolving' && feverIntensity > 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }

        // Slow-mo
        if (slowMo !== slowMoTarget) {
            slowMo += (slowMoTarget - slowMo) * 0.15;
            if (Math.abs(slowMo - slowMoTarget) < 0.01) slowMo = slowMoTarget;
        }
        if (slowMoTarget < 1 && explosions.length === 0 && pendingExplosions.length === 0) {
            slowMoTarget = 1.0;
        }

        if (gameState === 'gameover') {
            gameOverTimer = Math.min(1, gameOverTimer + 0.015);
        }

        if (gameState === 'resolving') checkRoundEnd();
    }

    // =====================================================================
    // DRAW
    // =====================================================================
    function draw() {
        engineDrawScene(ctx, gameState, supernovaActive);
        drawUI();
    }

    // =====================================================================
    // UI
    // =====================================================================
    function drawUI() {
        const params = getRoundParams(round);
        const screenMin = Math.min(W, H);
        const s = Math.max(1, screenMin / 600);

        if (gameState === 'start') { drawStartScreen(); return; }

        // Round counter
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.letterSpacing = '2px';
        ctx.fillText('ROUND', W/2, 14 * s);
        ctx.letterSpacing = '0px';

        ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillText(round, W/2, 28 * s);

        // Chain / target
        const infoY = 72 * s;
        if (gameState === 'resolving') {
            const targetMet = chainCount >= params.target;
            ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.save();
            ctx.shadowColor = targetMet ? 'rgba(255, 200, 60, 0.4)' : 'rgba(255,255,255,0.2)';
            ctx.shadowBlur = 6;
            ctx.fillStyle = targetMet ? 'rgba(255, 220, 100, 0.95)' : 'rgba(255,255,255,0.7)';
            ctx.fillText(`${chainCount} / ${params.target}`, W/2, infoY);
            ctx.restore();

            if (currentMultiplier > 1) {
                const mp = multiplierPulse > 0 ? 1 + easeOutBack(multiplierPulse) * 0.4 : 1;
                const multSize = Math.round(22 * s * mp);
                const multHue = currentMultiplier >= 5 ? 300 : currentMultiplier >= 3 ? 15 : 50;
                ctx.save();
                ctx.shadowColor = `hsla(${multHue}, 90%, 60%, 0.6)`;
                ctx.shadowBlur = 12 * s;
                ctx.font = `900 ${multSize}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${multHue}, 90%, 70%)`;
                ctx.fillText(`x${currentMultiplier}`, W/2, infoY + 22 * s);
                ctx.restore();
            }

            if (supernovaActive) {
                const tapY = infoY + (currentMultiplier > 1 ? 48 : 22) * s;
                ctx.font = `600 ${13 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 200, 60, 0.85)';
                if (supernovaTapsRemaining > 0) {
                    ctx.fillText(`${supernovaTapsRemaining} tap${supernovaTapsRemaining !== 1 ? 's' : ''} left`, W/2, tapY);
                }
                ctx.restore();
            }
        } else if (gameState === 'playing') {
            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillText(`Target: ${params.target}`, W/2, infoY);

            if (supernovaActive) {
                ctx.font = `600 ${13 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 200, 60, 0.4)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 200, 60, 0.85)';
                ctx.fillText(`SUPERNOVA — ${supernovaTapsRemaining} taps`, W/2, infoY + 18 * s);
                ctx.restore();
            } else if (mercyBonus > 0) {
                ctx.font = `300 ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.fillText(`+${Math.round(mercyBonus * 100)}% reach`, W/2, infoY + 18 * s);
            }
        }

        // Supernova charge meter
        if (!supernovaActive && supernovaCharge > 0 && (gameState === 'playing' || gameState === 'resolving')) {
            const meterY = 68 * s;
            const segW = 8 * s;
            const segH = 3 * s;
            const gap = 3 * s;
            const totalW = SUPERNOVA_CHARGE_NEEDED * segW + (SUPERNOVA_CHARGE_NEEDED - 1) * gap;
            const mx = W / 2 - totalW / 2;
            for (let i = 0; i < SUPERNOVA_CHARGE_NEEDED; i++) {
                const filled = i < supernovaCharge;
                ctx.fillStyle = filled ? 'rgba(255, 200, 60, 0.6)' : 'rgba(255, 255, 255, 0.08)';
                ctx.beginPath();
                ctx.roundRect(mx + i * (segW + gap), meterY, segW, segH, segH / 2);
                ctx.fill();
            }
        }

        if (gameState === 'gameover') drawGameOver();

        if (bestRound > 0 && gameState === 'playing') {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fillText(`Best: Round ${bestRound}`, W/2, H - 12 * s);
        }

        // Build info
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    function drawStartScreen() {
        uiButtons = [];
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const titleSize = Math.min(52, W * 0.10);
        const subSize = Math.min(16, W * 0.038);
        const s = Math.max(1, Math.min(W, H) / 600);

        const titleY = H * 0.22;

        ctx.save();
        ctx.shadowColor = 'rgba(120, 180, 255, 0.4)';
        ctx.shadowBlur = 40;
        ctx.font = `300 ${titleSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.98)';
        ctx.letterSpacing = `${Math.max(1, titleSize * 0.06)}px`;
        ctx.fillText('CHAIN REACTION', W/2, titleY);
        ctx.shadowBlur = 60;
        ctx.shadowColor = 'rgba(100, 160, 255, 0.2)';
        ctx.fillText('CHAIN REACTION', W/2, titleY);
        ctx.letterSpacing = '0px';
        ctx.restore();

        ctx.font = `400 ${subSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText('Tap to start a chain reaction.', W/2, titleY + titleSize * 0.8);

        let resumeBtnBottom = titleY + titleSize * 0.8 + subSize * 2;
        if (resumeCheckpoint && resumeCheckpoint.round > 1) {
            const resumeRect = drawPill(ctx, W/2, resumeBtnBottom, `Resume Round ${resumeCheckpoint.round}`, true, 120);
            uiButtons.push({ id: 'resume', ...resumeRect });
            resumeBtnBottom += 36 * s;
        }

        const promptAlpha = 0.2 + 0.12 * Math.sin(performance.now() * 0.003);
        ctx.font = `400 ${Math.min(14, subSize * 0.85)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = `rgba(255,255,255,${promptAlpha + 0.1})`;
        ctx.fillText(resumeCheckpoint && resumeCheckpoint.round > 1 ? 'Tap anywhere for new game' : 'Tap anywhere to begin', W/2, resumeBtnBottom);

        if (bestRound > 0) {
            ctx.font = `200 ${Math.min(13, subSize * 0.8)}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillText(`Best: Round ${bestRound}`, W/2, resumeBtnBottom + subSize * 2);
        }

        // Leaderboard — top 5 by score (tappable → opens replay)
        if (leaderboard && leaderboard.byScore && leaderboard.byScore.length > 0) {
            const lbY = H * 0.56;
            const rowH = 18 * s;
            ctx.font = `600 ${11 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.letterSpacing = '2px';
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fillText('LEADERBOARD', W/2, lbY);
            ctx.letterSpacing = '0px';

            const entries = leaderboard.byScore.slice(0, 5);
            for (let i = 0; i < entries.length; i++) {
                const e = entries[i];
                const ey = lbY + (i + 1) * rowH + 6 * s;
                const isMe = e.device_id === deviceId;
                ctx.font = `${isMe ? 600 : 300} ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = isMe ? 'rgba(255, 215, 0, 0.7)' : 'rgba(255,255,255,0.3)';
                const name = e.player_name || (e.is_bot ? 'Bot' : 'Anon');
                const label = `${i + 1}. ${name} — R${e.peak_round} — ${Number(e.total_score).toLocaleString()}`;
                ctx.fillText(label, W/2, ey);

                // Subtle underline hint
                const tw = ctx.measureText(label).width;
                ctx.fillStyle = isMe ? 'rgba(255, 215, 0, 0.15)' : 'rgba(255,255,255,0.08)';
                ctx.fillRect(W/2 - tw/2, ey + 6 * s, tw, 1);

                // Register hit area for tap → replay
                uiButtons.push({ id: `leaderboard_${i}`, sessionId: e.id, x: W/2 - tw/2 - 10, y: ey - rowH/2, w: tw + 20, h: rowH });
            }
        }

        // Bottom buttons
        const btnY = H - 50 * s;
        const watchRect = drawPill(ctx, W / 2, btnY, spectatorMode ? 'Bot: ON' : 'Watch Bot', spectatorMode, 55);
        uiButtons.push({ id: 'watch', ...watchRect });
    }

    function drawGameOver() {
        const t = easeOutCubic(gameOverTimer);
        const s = Math.max(1, Math.min(W, H) / 600);

        ctx.fillStyle = `rgba(0, 0, 0, ${t * 0.55})`;
        ctx.fillRect(0, 0, W, H);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const scaleT = easeOutBack(Math.min(t * 1.5, 1));
        ctx.save();
        ctx.shadowColor = 'rgba(255, 140, 60, 0.35)';
        ctx.shadowBlur = 30 * s;
        ctx.font = `300 ${Math.round(48 * s * scaleT)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fillText(`Round ${round}`, W/2, H/2 - 50 * s);
        ctx.restore();

        if (t > 0.3) {
            const t2 = easeOutCubic((t - 0.3) / 0.7);
            ctx.globalAlpha = t2;

            ctx.font = `300 ${18 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255, 160, 80, 0.85)';
            const params = getRoundParams(round);
            ctx.fillText(`Chain: ${chainCount} / ${params.target}`, W/2, H/2);

            if (chainCount < params.target && params.target > 0) {
                const ratio = chainCount / params.target;
                if (ratio >= 0.6) {
                    const needed = params.target - chainCount;
                    ctx.font = `400 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                    ctx.fillStyle = 'rgba(255, 210, 120, 0.65)';
                    ctx.fillText(`${needed} more ${needed === 1 ? 'dot' : 'dots'} to clear — So close!`, W/2, H/2 + 16 * s);
                }
            }

            ctx.font = `300 ${15 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText(`Total Score: ${totalScore + score}`, W/2, H/2 + 34 * s);

            if (round >= bestRound) {
                ctx.font = `600 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.fillText('New Best!', W/2, H/2 + 58 * s);
            }

            const restartRound = Math.max(1, round - SETBACK_ROUNDS);
            if (restartRound > 1) {
                ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Restart from Round ${restartRound}`, W/2, H/2 + 72 * s);
            }
        }

        if (t > 0.6) {
            const t3 = (t - 0.6) / 0.4;
            const pa = t3 * (0.3 + 0.1 * Math.sin(performance.now() * 0.003));
            ctx.font = `300 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${pa})`;
            ctx.fillText('Tap to try again', W/2, H/2 + 100 * s);

            const btnY = H - 50 * s;
            const nameLabel = playerName ? `Name: ${playerName}` : 'Set Name';
            const nameRect = drawPill(ctx, W / 2 - 90 * s, btnY, nameLabel, !!playerName, 180);
            uiButtons.push({ id: 'setname', ...nameRect });

            const watchRect = drawPill(ctx, W / 2, btnY, spectatorMode ? 'Bot: ON' : 'Watch Bot', spectatorMode, 55);
            uiButtons.push({ id: 'watch', ...watchRect });

            if (lastSessionId) {
                const replayRect = drawPill(ctx, W / 2 + 90 * s, btnY, 'Watch Replay', false, 200);
                uiButtons.push({ id: 'viewreplay', ...replayRect });
            }
        }

        ctx.globalAlpha = 1;
    }

    // =====================================================================
    // SPECTATOR BOT
    // =====================================================================
    function botFindBestTap() {
        const gridSize = 20;
        let bestX = W / 2, bestY = H / 2, bestCount = 0;
        const r = explosionRadius * (1 + mercyBonus);
        for (let gx = 0; gx < gridSize; gx++) {
            for (let gy = 0; gy < gridSize; gy++) {
                const x = (gx + 0.5) * W / gridSize;
                const y = (gy + 0.5) * H / gridSize;
                let count = 0;
                for (const d of dots) {
                    if (d.active && Math.hypot(d.x - x, d.y - y) <= r) count++;
                }
                if (count > bestCount) { bestCount = count; bestX = x; bestY = y; }
            }
        }
        return { x: bestX, y: bestY, count: bestCount };
    }

    function updateBot(now) {
        if (!spectatorMode) return;
        if (gameState === 'start') { handleTap(W / 2, H / 2); return; }
        if (gameState === 'gameover' && gameOverTimer > 0.8) { handleTap(W / 2, H / 2); return; }
        if (gameState !== 'playing') return;

        if (!botTarget && now - botLastScan > botScanInterval) {
            botLastScan = now;
            const best = botFindBestTap();
            if (best.count >= 1) {
                botTarget = {
                    x: best.x + (Math.random() - 0.5) * 20,
                    y: best.y + (Math.random() - 0.5) * 20,
                    count: best.count,
                };
                botThinkTimer = botReactionDelay + Math.random() * 200;
            }
        }

        if (botTarget) {
            botThinkTimer -= 16.67;
            if (botThinkTimer <= 0) {
                const fresh = botFindBestTap();
                if (fresh.count >= 1) {
                    handleTap(fresh.x + (Math.random() - 0.5) * 10, fresh.y + (Math.random() - 0.5) * 10);
                }
                botTarget = null;
                botLastScan = now;
            }
        }
    }

    function drawBotOverlay() {
        const s = Math.max(1, Math.min(W, H) / 600);

        if (spectatorMode && botTarget && gameState === 'playing') {
            const pulse = Math.sin(performance.now() * 0.008) * 0.3 + 0.7;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.4 * pulse;
            ctx.strokeStyle = 'rgba(255, 255, 100, 1)';
            ctx.lineWidth = 1.5;
            const cr = 15 * s;
            ctx.beginPath(); ctx.moveTo(botTarget.x - cr, botTarget.y); ctx.lineTo(botTarget.x + cr, botTarget.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(botTarget.x, botTarget.y - cr); ctx.lineTo(botTarget.x, botTarget.y + cr); ctx.stroke();
            ctx.globalAlpha = 0.15 * pulse;
            ctx.beginPath(); ctx.arc(botTarget.x, botTarget.y, explosionRadius * (1 + mercyBonus), 0, Math.PI * 2); ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }

        if (gameState === 'playing' || gameState === 'resolving') {
            const bx = 8 * s, by = 8 * s;
            const bw = spectatorMode ? 52 * s : 36 * s;
            const bh = 22 * s;
            const br = bh / 2;
            ctx.beginPath(); ctx.roundRect(bx, by, bw, bh, br);
            ctx.fillStyle = spectatorMode ? 'rgba(255, 255, 100, 0.12)' : 'rgba(255, 255, 255, 0.04)';
            ctx.fill();
            ctx.strokeStyle = spectatorMode ? 'rgba(255, 255, 100, 0.25)' : 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 0.5; ctx.stroke();
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `600 ${8 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = spectatorMode ? 'rgba(255, 255, 100, 0.5)' : 'rgba(255, 255, 255, 0.15)';
            ctx.fillText('BOT', bx + bw / 2, by + bh / 2);
            if (spectatorMode) {
                ctx.beginPath(); ctx.arc(bx + bw - 8 * s, by + bh / 2, 3 * s, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 255, 100, 0.6)'; ctx.fill();
            }
            uiButtons.push({ id: 'watch', x: bx, y: by, w: bw, h: bh });
        }
    }

    // =====================================================================
    // REPLAY DOWNLOAD
    // =====================================================================
    function downloadReplay() {
        if (replayLog.length === 0) return;
        const data = JSON.stringify({
            version: BUILD_VERSION, date: BUILD_DATE,
            viewport: { w: W, h: H },
            peakRound, bestRound, totalScore,
            events: replayLog,
        }, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `replay-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // =====================================================================
    // GAME LOOP
    // =====================================================================
    function loop() {
        const now = performance.now();
        uiButtons = [];
        updateBot(now);
        update();
        draw();
        drawBotOverlay();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    function hitTestButtons(x, y) {
        for (const btn of uiButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                return btn;
            }
        }
        return null;
    }

    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        const x = e.clientX, y = e.clientY;

        const hitBtn = hitTestButtons(x, y);
        const hit = hitBtn ? hitBtn.id : null;

        if (hit === 'watch') {
            spectatorMode = !spectatorMode;
            if (spectatorMode) { botTarget = null; botLastScan = 0; }
            return;
        }
        if (hit === 'replay') { downloadReplay(); return; }
        if (hit === 'resume' && resumeCheckpoint) {
            audio.init();
            round = resumeCheckpoint.round;
            totalScore = Number(resumeCheckpoint.total_score) || 0;
            consecutiveFails = resumeCheckpoint.consecutive_fails || 0;
            mercyBonus = resumeCheckpoint.mercy_bonus || 0;
            supernovaCharge = resumeCheckpoint.supernova_charge || 0;
            supernovaActive = false;
            supernovaTapsRemaining = 0;
            peakRound = round;
            lastSessionId = null;
            replayLog = [];
            replayStartTime = performance.now();
            startRound();
            return;
        }
        if (hit === 'setname') {
            const name = prompt('Enter your name:', playerName || '');
            if (name !== null) {
                playerName = name.trim().slice(0, 20) || null;
                if (playerName) localStorage.setItem('cr_player_name', playerName);
                else localStorage.removeItem('cr_player_name');
            }
            return;
        }
        if (hit === 'viewreplay' && lastSessionId) {
            window.open(`/replay/${lastSessionId}`, '_blank');
            return;
        }
        // Leaderboard entry tapped → open replay
        if (hit && hit.startsWith('leaderboard_') && hitBtn.sessionId) {
            window.open(`/replay/${hitBtn.sessionId}`, '_blank');
            return;
        }

        if (!spectatorMode) handleTap(x, y);
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    document.addEventListener('keydown', e => {
        if (e.key === 'w' || e.key === 'W') {
            spectatorMode = !spectatorMode;
            if (spectatorMode) { botTarget = null; botLastScan = 0; }
        }
        if (e.key === 'r' || e.key === 'R') downloadReplay();
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    generateDots(10, 0.5, 1.0);
    gameState = 'start';
    lastFrame = performance.now();
    if (spectatorMode) audio.init();
    loop();

    </script>
</body>
</html>
