<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chain Reaction</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: #04040f;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            cursor: crosshair;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
    'use strict';

    // =========================================================================
    // CHAIN REACTION v3 — Dopamine Edition
    // Simple tap, ascending scale, multiplier, celebrations, bigger radius
    // =========================================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // =====================================================================
    // CONSTANTS
    // =====================================================================

    // Build info
    const BUILD_VERSION = 'v7';
    const BUILD_DATE = '2026-02-20';

    // Progression — setback + mercy
    const SETBACK_ROUNDS = 2;          // on death, go back 2 rounds (not to R1)
    const MERCY_RADIUS_BONUS = 0.05;   // +5% explosion radius per consecutive fail
    const MERCY_RADIUS_CAP = 0.15;     // max +15% mercy radius

    // Dot types — physics modifiers, not scripted combos
    const DOT_TYPES = {
        standard: { label: 'standard', radiusMult: 1.0, speedMult: 1.0 },
        gravity:  { label: 'gravity',  radiusMult: 1.0, speedMult: 0.7, pullRange: 2.5, pullForce: 0.012 },
        volatile: { label: 'volatile', radiusMult: 1.5, speedMult: 1.3 },
    };

    // Explosion radius — generous! Fun moments should be frequent
    const EXPLOSION_RADIUS_PCT = 0.11;
    const EXPLOSION_RADIUS_MIN_PX = 35;

    // Explosion lifecycle (ms)
    const EXPLOSION_GROW_MS = 200;
    const EXPLOSION_HOLD_MS = 1000;
    const EXPLOSION_SHRINK_MS = 500;
    const TOTAL_EXPLOSION_MS = EXPLOSION_GROW_MS + EXPLOSION_HOLD_MS + EXPLOSION_SHRINK_MS;

    // Cascade timing
    const CASCADE_STAGGER_MS = 80;
    const CASCADE_JITTER_MS = 25;

    // Dots
    let DOT_RADIUS = 5;
    let DOT_GLOW_SIZE = 18;
    const MIN_DOT_DISTANCE = 25;
    const SCREEN_MARGIN = 16;
    const DOT_TRAIL_LENGTH = 8;

    // Particles
    const PARTICLE_POOL_SIZE = 4000;
    const AMBIENT_PARTICLE_COUNT = 120;

    // Screen shake
    const SHAKE_MAX_OFFSET = 14;
    const SHAKE_DECAY = 0.90;
    const SHAKE_TRAUMA_PER_DOT = 0.06;

    // Audio
    const MAX_VOICES = 48;

    // Hit freeze
    const HIT_FREEZE_FRAMES = 3;

    // Ascending pentatonic scale (C3 to A6) — each chain hit goes UP
    const SCALE_NOTES = [
        130.81, 146.83, 164.81, 196.00, 220.00,
        261.63, 293.66, 329.63, 392.00, 440.00,
        523.25, 587.33, 659.25, 783.99, 880.00,
        1046.50, 1174.66, 1318.51, 1567.98, 1760.00,
    ];

    // Multiplier thresholds
    const MULT_THRESHOLDS = [
        { chain: 0, mult: 1 }, { chain: 5, mult: 2 },
        { chain: 10, mult: 3 }, { chain: 15, mult: 4 },
        { chain: 20, mult: 5 }, { chain: 30, mult: 8 },
    ];

    // Celebration milestones
    const CELEBRATIONS = [
        { chain: 5, text: 'NICE!', hue: 50, size: 1.0 },
        { chain: 10, text: 'AMAZING!', hue: 35, size: 1.3 },
        { chain: 15, text: 'INCREDIBLE!', hue: 15, size: 1.6 },
        { chain: 20, text: 'LEGENDARY!', hue: 300, size: 2.0 },
        { chain: 30, text: 'GODLIKE!', hue: 280, size: 2.5 },
    ];

    // =====================================================================
    // EASING
    // =====================================================================
    const easeOutExpo = t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    const easeInQuad = t => t * t;
    const easeOutQuad = t => 1 - (1 - t) * (1 - t);
    const easeOutBack = t => 1 + 2.70158 * Math.pow(t - 1, 3) + 1.70158 * Math.pow(t - 1, 2);
    const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
    const easeInOutCubic = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3) / 2;

    // =====================================================================
    // GLOBALS
    // =====================================================================
    let W, H, refDim;
    let explosionRadius;
    let round = 0;
    let chainCount = 0;
    let score = 0;
    let bestRound = parseInt(localStorage.getItem('cr3_bestRound') || '0', 10);
    let bestScore = parseInt(localStorage.getItem('cr3_bestScore') || '0', 10);
    let gameState = 'start';
    let freezeFrames = 0;
    let bgPulse = 0;
    let shakeTrauma = 0;
    let shakeX = 0, shakeY = 0;
    let floatingTexts = [];
    let chainLines = [];
    let pendingExplosions = [];
    let scheduledDetonations = new Set();
    let gameOverTimer = 0;
    let lastChainFreqs = [];
    let totalScore = 0;

    // Multiplier
    let currentMultiplier = 1;
    let multiplierPulse = 0;

    // Fever (visual intensity during big chains)
    let feverIntensity = 0;
    let lastCelebration = -1;

    // Slow-mo
    let slowMo = 1.0;
    let slowMoTarget = 1.0;

    // Screen effects
    let screenFlash = 0;
    let beatPulse = 0;

    // Progression state
    let consecutiveFails = 0;       // how many times failed current round
    let mercyBonus = 0;             // current mercy radius multiplier (0 to MERCY_RADIUS_CAP)
    let peakRound = 0;              // highest round reached this session

    // Spectator mode (bot autoplay)
    const urlParams = new URLSearchParams(window.location.search);
    let spectatorMode = urlParams.has('watch');
    let botTarget = null;           // {x, y} where bot wants to tap
    let botThinkTimer = 0;          // countdown before bot taps
    let botScanInterval = 400;      // ms between bot scans
    let botLastScan = 0;
    let botReactionDelay = 600;     // ms from decision to tap

    // Replay recording
    let replayLog = [];             // [{t, type, data}, ...]
    let replayStartTime = 0;

    // UI buttons (computed in draw, hit-tested in input)
    let uiButtons = [];             // [{id, x, y, w, h}]

    // Music system
    const MUSIC_PATTERN = [
        [5,1.0],[7,0.7],[8,0.9],[10,0.6],
        [9,0.8],[8,0.7],[7,0.9],[5,0.6],
        [3,1.0],[4,0.7],[5,0.9],[7,0.6],
        [8,0.8],[7,0.7],[5,0.9],[3,0.5],
    ];
    let musicBeat = 0;
    let nextMusicBeat = 0;
    const MUSIC_BEAT_MS = 750; // 80 BPM

    // =====================================================================
    // RESIZE
    // =====================================================================
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        refDim = Math.min(W, H, 800);
        const screenMin = Math.min(W, H);
        explosionRadius = Math.max(EXPLOSION_RADIUS_MIN_PX, refDim * EXPLOSION_RADIUS_PCT);
        DOT_RADIUS = Math.max(6, screenMin * 0.014);
        DOT_GLOW_SIZE = Math.max(28, screenMin * 0.06);
    }
    window.addEventListener('resize', resize);
    resize();

    // =====================================================================
    // ROUND FORMULA — easier early, generous throughout
    // =====================================================================
    function getRoundParams(r) {
        const dots = Math.min(60, Math.floor(10 + r * 2.5));
        const pct = Math.min(0.80, 0.05 + (r - 1) * 0.028);
        const target = Math.max(1, Math.ceil(dots * pct));
        const speedMin = 0.6 + Math.min(0.4, (r - 1) * 0.03);
        const speedMax = 1.2 + Math.min(0.8, (r - 1) * 0.05);
        // Dot types introduced gradually: R1-2 all standard, R3+ gravity, R5+ volatile
        let typeWeights;
        if (r <= 2) {
            typeWeights = { standard: 1.0 };
        } else if (r <= 4) {
            const gw = Math.min(0.25, (r - 2) * 0.12);
            typeWeights = { standard: 1 - gw, gravity: gw };
        } else {
            const gw = Math.min(0.25, 0.12 + (r - 4) * 0.03);
            const vw = Math.min(0.20, (r - 4) * 0.08);
            typeWeights = { standard: Math.max(0.5, 1 - gw - vw), gravity: gw, volatile: vw };
        }
        return { dots, target, pct, speedMin, speedMax, typeWeights };
    }

    function getMultiplier(chain) {
        let m = 1;
        for (const t of MULT_THRESHOLDS) { if (chain >= t.chain) m = t.mult; }
        return m;
    }

    // =====================================================================
    // AUDIO ENGINE
    // =====================================================================
    const audio = {
        ctx: null,
        masterGain: null,
        compressor: null,
        delayNode: null,
        voices: [],
        initialized: false,

        init() {
            if (this.initialized) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.ctx.resume();

            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.6;

            this.compressor = this.ctx.createDynamicsCompressor();
            this.compressor.threshold.value = -18;
            this.compressor.knee.value = 12;
            this.compressor.ratio.value = 6;

            this.delayNode = this._createDelay(0.18, 0.25, 0.18);

            this.masterGain.connect(this.compressor);
            this.compressor.connect(this.delayNode.input);
            this.delayNode.output.connect(this.ctx.destination);

            setTimeout(() => {
                const reverb = this._createReverb(2.0, 3.0, 0.22);
                this.delayNode.output.disconnect();
                this.delayNode.output.connect(reverb.input);
                reverb.output.connect(this.ctx.destination);
            }, 0);

            this.initialized = true;
        },

        // Ascending scale — chain position determines pitch
        playChainNote(chainIndex, generation) {
            if (!this.initialized) return;
            const noteIdx = Math.min(chainIndex, SCALE_NOTES.length - 1);
            const baseFreq = SCALE_NOTES[noteIdx];
            const detune = (Math.random() - 0.5) * 12;
            const freq = baseFreq * Math.pow(2, detune / 1200);
            lastChainFreqs.push(baseFreq);

            const chainBoost = Math.min(1.8, 1 + chainIndex * 0.03);
            let attack, decay, susLvl, susTime, release, vol;
            if (generation === 0) {
                attack = 0.001; decay = 0.04; susLvl = 0.4;
                susTime = 0.12; release = 0.6; vol = 0.24 * chainBoost;
            } else {
                attack = 0.003; decay = 0.03; susLvl = 0.35;
                susTime = 0.08; release = 0.5 + Math.min(0.3, generation * 0.02);
                vol = Math.max(0.08, 0.22 * chainBoost - generation * 0.005);
            }

            // Main voice — triangle for warmth
            this._voicePlay(freq, 'triangle', vol, attack, decay, susLvl, susTime, release);
            // Attack transient — short sine pop for punch
            this._voicePlay(freq, 'sine', vol * 0.5, 0.001, 0.01, 0, 0, 0.03);

            // Shimmer octave up (builds brightness as chain grows)
            if (chainIndex >= 2) {
                this._voicePlay(freq * 2, 'sine', vol * 0.12, 0.003, 0.03, 0.15, 0.03, 0.4);
            }
            // Sub bass for grounding
            if (chainIndex < 4) {
                this._voicePlay(freq * 0.5, 'sine', vol * 0.1, 0.01, 0.06, 0.2, 0.06, 0.5);
            }
            // Fifth harmony for richness at high chains
            if (chainIndex >= 6) {
                this._voicePlay(freq * 1.5, 'sine', vol * 0.08, 0.005, 0.04, 0.12, 0.04, 0.4);
            }
        },

        playMusicNote(noteIdx, vol) {
            if (!this.initialized) return;
            this._voicePlay(SCALE_NOTES[noteIdx], 'triangle', vol, 0.01, 0.08, 0.5, 0.4, 1.0);
        },

        playMusicBass(noteIdx) {
            if (!this.initialized) return;
            this._voicePlay(SCALE_NOTES[noteIdx], 'sine', 0.12, 0.05, 0.1, 0.3, 0.5, 1.0);
        },

        playMiss() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const buf = c.createBuffer(1, Math.floor(c.sampleRate * 0.08), c.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (c.sampleRate * 0.02));
            const src = c.createBufferSource(); src.buffer = buf;
            const f = c.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 600;
            const g = c.createGain();
            g.gain.setValueAtTime(0.0001, now);
            g.gain.linearRampToValueAtTime(0.06, now + 0.002);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.06);
            src.connect(f); f.connect(g); g.connect(this.ctx.destination);
            src.start(now); src.stop(now + 0.08);
            src.onended = () => { src.disconnect(); f.disconnect(); g.disconnect(); };
        },

        playTap() {
            if (!this.initialized) return;
            const c = this.ctx; const now = c.currentTime;
            const osc = c.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
            const g = c.createGain();
            g.gain.setValueAtTime(0.15, now);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
            osc.connect(g); g.connect(this.masterGain);
            osc.start(now); osc.stop(now + 0.2);
            osc.onended = () => { osc.disconnect(); g.disconnect(); };
        },

        playCelebration(level) {
            if (!this.initialized) return;
            const baseIdx = Math.min(10, level * 2);
            for (let i = 0; i < 4; i++) {
                const idx = Math.min(SCALE_NOTES.length - 1, baseIdx + i);
                setTimeout(() => {
                    this._voicePlay(SCALE_NOTES[idx], 'sine', 0.14, 0.01, 0.08, 0.6, 0.15, 1.2);
                    this._voicePlay(SCALE_NOTES[idx] * 2, 'sine', 0.04, 0.02, 0.05, 0.3, 0.1, 0.8);
                }, i * 80);
            }
        },

        playRoundClear() {
            if (!this.initialized) return;
            const chord = [
                SCALE_NOTES[5], SCALE_NOTES[7], SCALE_NOTES[8],
                SCALE_NOTES[10], SCALE_NOTES[12],
            ];
            chord.forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'sine', 0.12, 0.15, 0.1, 0.7, 1.0, 2.0);
                    this._voicePlay(f * 2, 'sine', 0.03, 0.2, 0.08, 0.4, 0.8, 1.5);
                }, i * 60);
            });
        },

        playGameOver() {
            if (!this.initialized) return;
            [220, 196, 164.81].forEach((f, i) => {
                setTimeout(() => {
                    this._voicePlay(f, 'triangle', 0.10, 0.1, 0.15, 0.5, 0.3, 1.5);
                }, i * 150);
            });
        },

        _voicePlay(freq, type, vol, attack, decay, susLvl, susTime, release) {
            while (this.voices.length >= MAX_VOICES) {
                const old = this.voices.shift();
                try {
                    old.gain.gain.setValueAtTime(old.gain.gain.value, this.ctx.currentTime);
                    old.gain.gain.linearRampToValueAtTime(0.0001, this.ctx.currentTime + 0.005);
                    old.osc.stop(this.ctx.currentTime + 0.01);
                } catch(e) {}
            }
            const c = this.ctx; const now = c.currentTime;
            const osc = c.createOscillator();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, now);
            const env = c.createGain();
            env.gain.setValueAtTime(0.0001, now);
            env.gain.linearRampToValueAtTime(vol, now + attack);
            env.gain.linearRampToValueAtTime(vol * susLvl, now + attack + decay);
            const relStart = now + attack + decay + susTime;
            env.gain.setValueAtTime(vol * susLvl, relStart);
            env.gain.exponentialRampToValueAtTime(0.0001, relStart + release);
            osc.connect(env); env.connect(this.masterGain);
            osc.start(now); osc.stop(relStart + release + 0.05);
            const voice = { osc, gain: env };
            this.voices.push(voice);
            osc.onended = () => {
                osc.disconnect(); env.disconnect();
                const idx = this.voices.indexOf(voice);
                if (idx !== -1) this.voices.splice(idx, 1);
            };
        },

        _createDelay(time, feedback, wet) {
            const c = this.ctx;
            const input = c.createGain(), output = c.createGain();
            const delay = c.createDelay(2.0), fb = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            const filt = c.createBiquadFilter();
            delay.delayTime.value = time; fb.gain.value = feedback;
            wetG.gain.value = wet; dryG.gain.value = 1.0;
            filt.type = 'lowpass'; filt.frequency.value = 2500;
            input.connect(dryG); dryG.connect(output);
            input.connect(delay); delay.connect(filt); filt.connect(fb); fb.connect(delay);
            delay.connect(wetG); wetG.connect(output);
            return { input, output };
        },

        _createReverb(dur, dec, mix) {
            const c = this.ctx;
            const len = Math.floor(c.sampleRate * dur);
            const buf = c.createBuffer(2, len, c.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const d = buf.getChannelData(ch);
                for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-dec * (i / c.sampleRate));
            }
            const conv = c.createConvolver(); conv.buffer = buf;
            const input = c.createGain(), output = c.createGain();
            const wetG = c.createGain(), dryG = c.createGain();
            wetG.gain.value = mix; dryG.gain.value = 1.0;
            input.connect(dryG); dryG.connect(output);
            input.connect(conv); conv.connect(wetG); wetG.connect(output);
            return { input, output };
        }
    };

    // =====================================================================
    // PARTICLE POOL
    // =====================================================================
    const particles = {
        x: new Float32Array(PARTICLE_POOL_SIZE),
        y: new Float32Array(PARTICLE_POOL_SIZE),
        vx: new Float32Array(PARTICLE_POOL_SIZE),
        vy: new Float32Array(PARTICLE_POOL_SIZE),
        life: new Float32Array(PARTICLE_POOL_SIZE),
        maxLife: new Float32Array(PARTICLE_POOL_SIZE),
        hue: new Float32Array(PARTICLE_POOL_SIZE),
        size: new Float32Array(PARTICLE_POOL_SIZE),
        friction: new Float32Array(PARTICLE_POOL_SIZE),
        gravity: new Float32Array(PARTICLE_POOL_SIZE),
        count: 0,

        spawn(x, y, vx, vy, life, hue, size, friction, gravity) {
            if (this.count >= PARTICLE_POOL_SIZE) return;
            const i = this.count;
            this.x[i] = x; this.y[i] = y;
            this.vx[i] = vx; this.vy[i] = vy;
            this.life[i] = life; this.maxLife[i] = life;
            this.hue[i] = hue; this.size[i] = size;
            this.friction[i] = friction; this.gravity[i] = gravity;
            this.count++;
        },

        update() {
            let i = 0;
            while (i < this.count) {
                this.vx[i] *= this.friction[i];
                this.vy[i] *= this.friction[i];
                this.vy[i] += this.gravity[i];
                this.x[i] += this.vx[i];
                this.y[i] += this.vy[i];
                this.life[i]--;
                if (this.life[i] <= 0) {
                    this.count--;
                    if (i < this.count) {
                        this.x[i] = this.x[this.count]; this.y[i] = this.y[this.count];
                        this.vx[i] = this.vx[this.count]; this.vy[i] = this.vy[this.count];
                        this.life[i] = this.life[this.count]; this.maxLife[i] = this.maxLife[this.count];
                        this.hue[i] = this.hue[this.count]; this.size[i] = this.size[this.count];
                        this.friction[i] = this.friction[this.count]; this.gravity[i] = this.gravity[this.count];
                    }
                } else { i++; }
            }
        },

        draw(ctx) {
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < this.count; i++) {
                const a = this.life[i] / this.maxLife[i];
                const s = this.size[i] * (0.4 + a * 0.6);
                const alpha = a * a;
                if (alpha < 0.01) continue;
                ctx.globalAlpha = alpha;
                const h = this.hue[i];
                if (s > 3) {
                    const gr = s * 2;
                    const grd = ctx.createRadialGradient(this.x[i], this.y[i], 0, this.x[i], this.y[i], gr);
                    grd.addColorStop(0, `hsla(${h}, 100%, ${70 + a * 20}%, 0.7)`);
                    grd.addColorStop(0.5, `hsla(${h}, 90%, ${55 + a * 15}%, 0.15)`);
                    grd.addColorStop(1, `hsla(${h}, 80%, 50%, 0)`);
                    ctx.fillStyle = grd;
                    ctx.fillRect(this.x[i] - gr, this.y[i] - gr, gr * 2, gr * 2);
                } else {
                    ctx.fillStyle = `hsl(${h}, 100%, ${60 + a * 25}%)`;
                    ctx.fillRect(this.x[i] - s * 0.5, this.y[i] - s * 0.5, s, s);
                }
            }
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        },

        clear() { this.count = 0; }
    };

    function emitParticles(x, y, hue, gen) {
        // Particles ESCALATE with chain depth — deeper chains = bigger fireworks
        const depth = Math.min(8, gen);
        const burstN = 8 + depth * 2;
        const driftN = 4 + depth;
        const sparkN = 2 + Math.min(8, depth * 2);
        const emberN = 2 + Math.min(4, Math.floor(depth / 2));

        for (let i = 0; i < burstN; i++) {
            const a = (Math.PI * 2 * i) / burstN + (Math.random() - 0.5) * 0.5;
            const spd = 3.5 + Math.random() * 5;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                22 + Math.random()*18, hue + (Math.random()-0.5)*30, 2 + Math.random()*3, 0.92, 0.04);
        }
        for (let i = 0; i < driftN; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 0.8 + Math.random() * 1.5;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                50 + Math.random()*35, hue + (Math.random()-0.5)*20, 3.5 + Math.random()*4, 0.97, -0.025);
        }
        for (let i = 0; i < sparkN; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 7 + Math.random() * 9;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                8 + Math.random()*8, hue + 30, 1 + Math.random()*0.8, 0.88, 0.12);
        }
        for (let i = 0; i < emberN; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 0.3 + Math.random() * 0.6;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                100 + Math.random()*60, hue, 1.5 + Math.random(), 0.99, -0.008);
        }
    }

    function emitCelebrationBurst(x, y, hue, count) {
        for (let i = 0; i < count; i++) {
            const a = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.4;
            const spd = 5 + Math.random() * 10;
            const h = hue + (Math.random() - 0.5) * 60;
            particles.spawn(x, y, Math.cos(a)*spd, Math.sin(a)*spd,
                35 + Math.random()*25, h, 3 + Math.random()*5, 0.94, 0.03);
        }
    }

    // =====================================================================
    // AMBIENT BACKGROUND
    // =====================================================================
    const ambientStars = [];
    function initAmbient() {
        ambientStars.length = 0;
        for (let i = 0; i < AMBIENT_PARTICLE_COUNT; i++) {
            const isBright = Math.random() < 0.15;
            ambientStars.push({
                x: Math.random() * W, y: Math.random() * H,
                vx: (Math.random() - 0.5) * 0.12,
                vy: (Math.random() - 0.5) * 0.12,
                size: isBright ? (1.5 + Math.random() * 2) : (0.5 + Math.random() * 1.8),
                alpha: isBright ? (0.15 + Math.random() * 0.2) : (0.04 + Math.random() * 0.12),
                phase: Math.random() * Math.PI * 2,
                hue: isBright ? (180 + Math.random() * 60) : 220,
            });
        }
    }

    function updateAmbient() {
        for (const s of ambientStars) {
            s.x += s.vx; s.y += s.vy; s.phase += 0.008;
            if (s.x < 0) s.x = W; if (s.x > W) s.x = 0;
            if (s.y < 0) s.y = H; if (s.y > H) s.y = 0;
        }
    }

    function drawAmbient() {
        ctx.globalCompositeOperation = 'lighter';
        for (const s of ambientStars) {
            const a = s.alpha * (0.5 + 0.5 * Math.sin(s.phase));
            if (a < 0.01) continue;
            ctx.globalAlpha = a;
            if (s.size > 2) {
                const gr = s.size * 3;
                const grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, gr);
                grd.addColorStop(0, `hsla(${s.hue}, 40%, 80%, 0.6)`);
                grd.addColorStop(0.3, `hsla(${s.hue}, 30%, 70%, 0.15)`);
                grd.addColorStop(1, `hsla(${s.hue}, 30%, 60%, 0)`);
                ctx.fillStyle = grd;
                ctx.fillRect(s.x - gr, s.y - gr, gr * 2, gr * 2);
            }
            ctx.fillStyle = `hsla(${s.hue}, 30%, 85%, 1)`;
            ctx.fillRect(s.x - s.size * 0.5, s.y - s.size * 0.5, s.size, s.size);
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    // =====================================================================
    // FLOATING TEXT
    // =====================================================================
    function spawnFloatingText(x, y, text, hue) {
        floatingTexts.push({ x, y, text, hue, age: 0, maxAge: 50 });
    }

    function spawnCelebration(text, hue, scale) {
        floatingTexts.push({
            x: W/2, y: H * 0.35, text, hue,
            age: 0, maxAge: 120, scale: scale || 1, celebration: true
        });
        emitCelebrationBurst(W/2, H/2, hue, Math.floor(40 * (scale || 1)));
        shakeTrauma = Math.min(1.0, shakeTrauma + 0.3 * (scale || 1));
        bgPulse = Math.min(0.4, bgPulse + 0.12 * (scale || 1));
        screenFlash = Math.min(0.6, 0.40 * (scale || 1));
    }

    function updateFloatingTexts() {
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            const ft = floatingTexts[i];
            ft.age++;
            const drift = ft.celebration ? 0.5 : 1.5;
            ft.y -= drift * (1 - ft.age / ft.maxAge);
            if (ft.age >= ft.maxAge) floatingTexts.splice(i, 1);
        }
    }

    function drawFloatingTexts() {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const baseSize = Math.max(14, Math.min(W, H) * 0.022);
        for (const ft of floatingTexts) {
            const a = 1 - easeInQuad(ft.age / ft.maxAge);

            if (ft.celebration) {
                const entryScale = easeOutBack(Math.min(1, ft.age / 12));
                const sz = Math.round(baseSize * 3 * (ft.scale || 1) * entryScale);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.shadowColor = `hsla(${ft.hue}, 90%, 60%, 0.8)`;
                ctx.shadowBlur = 20;
                ctx.font = `900 ${sz}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${ft.hue}, 90%, 75%)`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.shadowBlur = 40;
                ctx.globalAlpha = a * 0.5;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            } else {
                const scale = 0.8 + 0.4 * easeOutBack(Math.min(1, ft.age / 8));
                const sz = Math.round(baseSize * scale);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.shadowColor = `hsla(${ft.hue}, 80%, 60%, 0.5)`;
                ctx.shadowBlur = 8;
                ctx.font = `600 ${sz}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${ft.hue}, 80%, 78%)`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            }
        }
        ctx.globalAlpha = 1;
    }

    // =====================================================================
    // CHAIN LINES
    // =====================================================================
    function spawnChainLine(x1, y1, x2, y2) {
        chainLines.push({ x1, y1, x2, y2, age: 0, maxAge: 40 });
    }
    function updateChainLines() {
        for (let i = chainLines.length - 1; i >= 0; i--) {
            chainLines[i].age++;
            if (chainLines[i].age >= chainLines[i].maxAge) chainLines.splice(i, 1);
        }
    }
    function drawChainLines() {
        ctx.globalCompositeOperation = 'lighter';
        for (const cl of chainLines) {
            const a = 0.15 * (1 - cl.age / cl.maxAge);
            ctx.globalAlpha = a;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(cl.x1, cl.y1);
            ctx.lineTo(cl.x2, cl.y2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    // =====================================================================
    // DOT
    // =====================================================================
    class Dot {
        constructor(x, y, speedMin, speedMax, type) {
            this.type = type || 'standard';
            const typeDef = DOT_TYPES[this.type];
            this.x = x; this.y = y;
            const a = Math.random() * Math.PI * 2;
            const spd = (speedMin + Math.random() * (speedMax - speedMin)) * typeDef.speedMult;
            this.vx = Math.cos(a) * spd;
            this.vy = Math.sin(a) * spd;
            this.active = true;
            this.alpha = 0;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.trail = [];
            this.bloomTimer = 0;
            this.nearMiss = 0;
            this._neighbors = 0;
        }

        getHue() {
            // Type-based hue: standard = position-based, gravity = purple, volatile = orange-red
            if (this.type === 'gravity') return 270;
            if (this.type === 'volatile') return 15;
            return 195 - (this.y / H) * 180;
        }

        update() {
            if (!this.active && this.bloomTimer <= 0) return;
            if (this.bloomTimer > 0) { this.bloomTimer--; return; }
            if (this.alpha < 1) this.alpha = Math.min(1, this.alpha + 0.025);

            this.x += this.vx * slowMo;
            this.y += this.vy * slowMo;
            this.pulsePhase += 0.05;

            // Gravity dots pull nearby dots toward themselves
            if (this.type === 'gravity' && this.active) {
                const td = DOT_TYPES.gravity;
                const pullR = explosionRadius * td.pullRange;
                for (const o of dots) {
                    if (o === this || !o.active) continue;
                    const dist = Math.hypot(o.x - this.x, o.y - this.y);
                    if (dist < pullR && dist > 5) {
                        const f = td.pullForce * slowMo / (dist / explosionRadius);
                        o.vx += (this.x - o.x) / dist * f;
                        o.vy += (this.y - o.y) / dist * f;
                    }
                }
            }

            if (this.x < SCREEN_MARGIN) { this.vx = Math.abs(this.vx); this.x = SCREEN_MARGIN; }
            if (this.x > W - SCREEN_MARGIN) { this.vx = -Math.abs(this.vx); this.x = W - SCREEN_MARGIN; }
            if (this.y < SCREEN_MARGIN) { this.vy = Math.abs(this.vy); this.y = SCREEN_MARGIN; }
            if (this.y > H - SCREEN_MARGIN) { this.vy = -Math.abs(this.vy); this.y = H - SCREEN_MARGIN; }

            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > DOT_TRAIL_LENGTH) this.trail.shift();

            if (this.nearMiss > 0) this.nearMiss = Math.max(0, this.nearMiss - 0.012);
        }

        draw(ctx) {
            if (!this.active && this.bloomTimer <= 0) return;
            const hue = this.getHue();
            const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;
            const r = DOT_RADIUS * pulse;
            const a = this.alpha;

            if (this.bloomTimer > 0) {
                const bt = 1 - this.bloomTimer / 12;
                const br = r * (1 + bt * 5);
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = (1 - bt) * 0.9;
                const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, br);
                g.addColorStop(0, `hsla(${hue}, 70%, 95%, 1)`);
                g.addColorStop(0.3, `hsla(${hue}, 80%, 70%, 0.6)`);
                g.addColorStop(1, `hsla(${hue}, 80%, 60%, 0)`);
                ctx.fillStyle = g;
                ctx.fillRect(this.x - br, this.y - br, br * 2, br * 2);
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                return;
            }

            // Trail
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < this.trail.length - 1; i++) {
                const t = this.trail[i];
                const tp = (i + 1) / this.trail.length;
                ctx.globalAlpha = a * tp * 0.12;
                const ts = r * tp * 0.8;
                const tg = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, ts * 2);
                tg.addColorStop(0, `hsla(${hue}, 70%, 60%, 0.5)`);
                tg.addColorStop(1, `hsla(${hue}, 70%, 60%, 0)`);
                ctx.fillStyle = tg;
                ctx.fillRect(t.x - ts * 2, t.y - ts * 2, ts * 4, ts * 4);
            }

            // Outer glow — brighter when near other dots (shows clusters)
            const connectBoost = Math.min(1, (this._neighbors || 0) * 0.12);
            const glowR = DOT_GLOW_SIZE * (1 + connectBoost * 0.3);
            const glowA = a * (0.14 + pulse * 0.08 + connectBoost * 0.15);
            const gg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowR);
            gg.addColorStop(0, `hsla(${hue}, 85%, 70%, ${glowA})`);
            gg.addColorStop(0.4, `hsla(${hue}, 80%, 55%, ${glowA * 0.4})`);
            gg.addColorStop(1, `hsla(${hue}, 80%, 50%, 0)`);
            ctx.globalAlpha = 1;
            ctx.fillStyle = gg;
            ctx.fillRect(this.x - glowR, this.y - glowR, glowR * 2, glowR * 2);
            ctx.globalCompositeOperation = 'source-over';

            // Core
            ctx.globalAlpha = a;
            const cg = ctx.createRadialGradient(this.x - r * 0.2, this.y - r * 0.2, 0, this.x, this.y, r);
            cg.addColorStop(0, `hsla(${hue}, 60%, 95%, 1)`);
            cg.addColorStop(0.4, `hsla(${hue}, 85%, ${65 + pulse * 10}%, 1)`);
            cg.addColorStop(1, `hsla(${hue}, 90%, ${45 + pulse * 10}%, 0.9)`);
            ctx.beginPath();
            ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
            ctx.fillStyle = cg;
            ctx.fill();

            // Gravity dot: inward spiral lines (shows it pulls things in)
            if (this.type === 'gravity') {
                ctx.globalCompositeOperation = 'lighter';
                const spiralT = performance.now() * 0.002;
                const pullR = DOT_GLOW_SIZE * 1.8;
                for (let i = 0; i < 3; i++) {
                    const angle = spiralT + i * (Math.PI * 2 / 3);
                    const outerR = pullR * (0.6 + 0.4 * Math.sin(spiralT * 1.5 + i));
                    const innerR = r * 1.5;
                    ctx.globalAlpha = a * 0.2;
                    ctx.strokeStyle = 'hsla(270, 60%, 75%, 1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x + Math.cos(angle) * outerR, this.y + Math.sin(angle) * outerR);
                    ctx.lineTo(this.x + Math.cos(angle + 0.3) * innerR, this.y + Math.sin(angle + 0.3) * innerR);
                    ctx.stroke();
                }
                ctx.globalCompositeOperation = 'source-over';
            }

            // Volatile dot: jittery outer sparks
            if (this.type === 'volatile') {
                ctx.globalCompositeOperation = 'lighter';
                const sparkT = performance.now() * 0.004;
                for (let i = 0; i < 4; i++) {
                    const sa = sparkT + i * (Math.PI / 2) + Math.sin(sparkT * 3 + i) * 0.5;
                    const sr = r * (1.5 + 0.8 * Math.sin(sparkT * 5 + i * 2));
                    const ss = 1.5;
                    ctx.globalAlpha = a * (0.3 + 0.2 * Math.sin(sparkT * 6 + i));
                    ctx.fillStyle = 'hsla(15, 100%, 70%, 1)';
                    ctx.fillRect(this.x + Math.cos(sa) * sr - ss/2, this.y + Math.sin(sa) * sr - ss/2, ss, ss);
                }
                ctx.globalCompositeOperation = 'source-over';
            }

            // Near-miss red pulse
            if (this.nearMiss > 0) {
                const nmP = Math.sin(performance.now() * 0.012) * 0.3 + 0.7;
                const nmR = DOT_GLOW_SIZE * 1.2;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.nearMiss * nmP * 0.25;
                const ng = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, nmR);
                ng.addColorStop(0, 'hsla(0, 90%, 60%, 0.6)');
                ng.addColorStop(0.5, 'hsla(0, 80%, 50%, 0.15)');
                ng.addColorStop(1, 'hsla(0, 70%, 40%, 0)');
                ctx.fillStyle = ng;
                ctx.fillRect(this.x - nmR, this.y - nmR, nmR * 2, nmR * 2);
                ctx.globalCompositeOperation = 'source-over';
            }
            ctx.globalAlpha = 1;
        }
    }

    // =====================================================================
    // EXPLOSION
    // =====================================================================
    class Explosion {
        constructor(x, y, generation, radius, onCaught, parentX, parentY, dotType) {
            this.x = x; this.y = y;
            this.generation = generation;
            this.dotType = dotType || 'standard';
            // Volatile explosions have bigger radius (property transmission!)
            const typeDef = DOT_TYPES[this.dotType] || DOT_TYPES.standard;
            this.explosionRadius = radius * typeDef.radiusMult;
            this.onCaught = onCaught;
            this.createdAt = performance.now();
            this.phase = 'grow';
            this.radius = 0;
            this.caught = new Set();
            // Gravity explosions = purple, volatile = orange, standard = position-based
            this.hue = this.dotType === 'gravity' ? 270
                     : this.dotType === 'volatile' ? 15
                     : 195 - (y / H) * 180;
            this.parentX = parentX;
            this.parentY = parentY;
            this.shockwaveRadius = 0;
            this.flashAlpha = 1;
        }

        update(now) {
            if (!this._virtualAge) this._virtualAge = 0;
            const realDelta = now - (this._lastNow || this.createdAt);
            this._lastNow = now;
            this._virtualAge += realDelta * slowMo;
            const age = this._virtualAge;

            this.flashAlpha = Math.max(0, 1 - age / 80);
            this.shockwaveRadius = Math.min(this.explosionRadius * 1.6, age * 0.8);

            if (this.phase === 'grow') {
                if (age >= EXPLOSION_GROW_MS) this.phase = 'hold';
                this.radius = this.explosionRadius * easeOutExpo(Math.min(age / EXPLOSION_GROW_MS, 1));
            } else if (this.phase === 'hold') {
                if (age >= EXPLOSION_GROW_MS + EXPLOSION_HOLD_MS) this.phase = 'shrink';
                this.radius = this.explosionRadius;
            } else if (this.phase === 'shrink') {
                const t = (age - EXPLOSION_GROW_MS - EXPLOSION_HOLD_MS) / EXPLOSION_SHRINK_MS;
                if (t >= 1) { this.phase = 'done'; return false; }
                this.radius = this.explosionRadius * (1 - easeInQuad(t));
            }

            if (this.phase === 'grow' || this.phase === 'hold') {
                // Gravity-type explosions pull nearby dots inward (property transmission)
                if (this.dotType === 'gravity') {
                    const pullR = this.explosionRadius * 2.5;
                    for (let i = 0; i < dots.length; i++) {
                        const dot = dots[i];
                        if (!dot.active || this.caught.has(i)) continue;
                        const dist = Math.hypot(dot.x - this.x, dot.y - this.y);
                        if (dist < pullR && dist > 5) {
                            const f = 0.025 * slowMo / (dist / this.explosionRadius);
                            dot.vx += (this.x - dot.x) / dist * f;
                            dot.vy += (this.y - dot.y) / dist * f;
                        }
                    }
                }

                for (let i = 0; i < dots.length; i++) {
                    const dot = dots[i];
                    if (!dot.active || this.caught.has(i)) continue;
                    if (Math.hypot(dot.x - this.x, dot.y - this.y) <= this.radius) {
                        this.caught.add(i);
                        if (this.onCaught) this.onCaught(dot, i, this.generation, this.x, this.y);
                    }
                }
            }
            return true;
        }

        draw(ctx) {
            if (this.phase === 'done') return;
            const r = Math.max(0.1, this.radius);
            const age = this._virtualAge || 0;
            let alpha = 1;
            if (this.phase === 'shrink') {
                const t = (age - EXPLOSION_GROW_MS - EXPLOSION_HOLD_MS) / EXPLOSION_SHRINK_MS;
                alpha = 1 - easeInQuad(Math.min(t, 1));
            }

            ctx.globalCompositeOperation = 'lighter';

            // Gen-0 (player tap) = ripple only. Dot detonations = full glow.
            if (this.generation === 0) {
                // Outer ripple
                if (age < 500 && this.shockwaveRadius > 0) {
                    ctx.globalAlpha = 0.5 * (1 - age / 500) * alpha;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, Math.max(0.1, this.shockwaveRadius), 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(0, 0%, 90%, 1)`;
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                }
                // Inner ripple
                if (age < 350) {
                    ctx.globalAlpha = 0.35 * (1 - age / 350) * alpha;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, Math.max(0.1, this.shockwaveRadius * 0.65), 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(0, 0%, 80%, 1)`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                // Tiny flash at center
                if (this.flashAlpha > 0) {
                    ctx.globalAlpha = this.flashAlpha * 0.4;
                    const fr = 8;
                    const fg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, fr);
                    fg.addColorStop(0, 'rgba(255,255,255,0.8)');
                    fg.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = fg;
                    ctx.fillRect(this.x - fr, this.y - fr, fr * 2, fr * 2);
                }
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                return;
            }

            // --- Dot detonation (gen 1+) — escalating with chain depth ---
            const genBoost = Math.min(0.5, this.generation * 0.08);
            const hue = this.hue + this.generation * 3;

            // Ambient glow (bigger for deeper chains)
            const ambR = r * (2.5 + genBoost);
            ctx.globalAlpha = alpha * (0.12 + genBoost * 0.15);
            const ag = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, ambR);
            ag.addColorStop(0, `hsla(${hue + 10}, 60%, 70%, 1)`);
            ag.addColorStop(0.5, `hsla(${hue}, 50%, 50%, 0.3)`);
            ag.addColorStop(1, `hsla(${hue}, 50%, 40%, 0)`);
            ctx.fillStyle = ag;
            ctx.fillRect(this.x - ambR, this.y - ambR, ambR * 2, ambR * 2);

            // Flash
            if (this.flashAlpha > 0) {
                ctx.globalAlpha = this.flashAlpha * (0.7 + genBoost);
                const fr = r * 0.6 * (1 + (1 - this.flashAlpha) * 0.8);
                const fg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, fr);
                fg.addColorStop(0, '#ffffffee');
                fg.addColorStop(0.5, `hsla(50, 100%, 90%, 0.5)`);
                fg.addColorStop(1, `hsla(50, 100%, 80%, 0)`);
                ctx.fillStyle = fg;
                ctx.fillRect(this.x - fr, this.y - fr, fr * 2, fr * 2);
            }

            // Shockwave (scales with chain depth)
            const swScale = 1.6 + Math.min(1.0, this.generation * 0.15);
            this.shockwaveRadius = Math.min(this.explosionRadius * swScale, age * 0.8);
            if (age < 400 && this.shockwaveRadius > 0) {
                ctx.globalAlpha = (0.45 + genBoost * 0.3) * (1 - age / 400);
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0.1, this.shockwaveRadius), 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${hue}, 70%, 85%, 1)`;
                ctx.lineWidth = 2.5 + genBoost * 2;
                ctx.stroke();
            }

            // Core
            ctx.globalAlpha = alpha * (0.75 + genBoost * 0.2);
            const cg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
            cg.addColorStop(0, `hsla(45, 100%, 95%, 0.9)`);
            cg.addColorStop(0.15, `hsla(40, 95%, 80%, 0.6)`);
            cg.addColorStop(0.4, `hsla(${hue + 15}, 80%, 65%, 0.3)`);
            cg.addColorStop(0.7, `hsla(${hue}, 70%, 55%, 0.1)`);
            cg.addColorStop(1, `hsla(${hue}, 60%, 45%, 0)`);
            ctx.fillStyle = cg;
            ctx.fillRect(this.x - r, this.y - r, r * 2, r * 2);

            // Edge ring
            ctx.globalAlpha = alpha * 0.85;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Math.max(0.1, r), 0, Math.PI * 2);
            ctx.strokeStyle = `hsla(30, 95%, 65%, ${alpha})`;
            ctx.lineWidth = 2.5;
            ctx.stroke();

            // Inner core
            ctx.globalAlpha = alpha * 0.8;
            const cr = r * 0.2;
            const ig = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, cr);
            ig.addColorStop(0, `hsla(50, 100%, 97%, 1)`);
            ig.addColorStop(1, `hsla(45, 90%, 80%, 0)`);
            ctx.fillStyle = ig;
            ctx.fillRect(this.x - cr, this.y - cr, cr * 2, cr * 2);

            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    // =====================================================================
    // GAME STATE
    // =====================================================================
    let dots = [];
    let explosions = [];

    function pickDotType(typeWeights) {
        const r = Math.random();
        let sum = 0;
        for (const [type, weight] of Object.entries(typeWeights)) {
            sum += weight;
            if (r <= sum) return type;
        }
        return 'standard';
    }

    function generateDots(count, speedMin, speedMax, typeWeights) {
        dots = [];
        let attempts = 0;
        const topMargin = SCREEN_MARGIN + 50;
        const tw = typeWeights || { standard: 1.0 };
        while (dots.length < count && attempts < 5000) {
            const x = SCREEN_MARGIN + Math.random() * (W - SCREEN_MARGIN * 2);
            const y = topMargin + Math.random() * (H - topMargin - SCREEN_MARGIN);
            let valid = true;
            for (const d of dots) {
                if (Math.hypot(d.x - x, d.y - y) < MIN_DOT_DISTANCE) { valid = false; break; }
            }
            if (valid) dots.push(new Dot(x, y, speedMin, speedMax, pickDotType(tw)));
            attempts++;
        }
    }

    function startRound() {
        const params = getRoundParams(round);
        generateDots(params.dots, params.speedMin, params.speedMax, params.typeWeights);
        explosions = [];
        scheduledDetonations = new Set();
        pendingExplosions = [];
        chainLines = [];
        floatingTexts = [];
        particles.clear();
        chainCount = 0;
        score = 0;
        lastChainFreqs = [];
        shakeTrauma = 0;
        bgPulse = 0;
        slowMo = 1.0;
        slowMoTarget = 1.0;
        currentMultiplier = 1;
        multiplierPulse = 0;
        feverIntensity = 0;
        lastCelebration = -1;
        gameState = 'playing';
    }

    function detonateDot(dot, dotIndex, generation, parentX, parentY) {
        dot.active = false;
        dot.bloomTimer = 12;
        chainCount++;

        // Multiplier check
        const newMult = getMultiplier(chainCount);
        if (newMult > currentMultiplier) {
            currentMultiplier = newMult;
            multiplierPulse = 1.0;
            spawnFloatingText(W/2, H * 0.25, `x${newMult}!`, 50);
        }

        // Score with multiplier
        const basePoints = 10 * (generation + 1);
        const points = basePoints * currentMultiplier;
        score += points;

        // Ascending scale audio
        audio.playChainNote(chainCount - 1, generation);

        spawnFloatingText(dot.x, dot.y - 15, `+${points}`, dot.getHue());
        // Particles scale with chain — escalating visual intensity
        emitParticles(dot.x, dot.y, dot.getHue(), generation);
        // Extra burst at high chains
        if (chainCount >= 8) {
            emitParticles(dot.x, dot.y, dot.getHue() + 20, Math.max(0, generation - 2));
        }

        if (parentX !== undefined && parentY !== undefined) {
            spawnChainLine(parentX, parentY, dot.x, dot.y);
        }

        shakeTrauma = Math.min(1.0, shakeTrauma + SHAKE_TRAUMA_PER_DOT);
        bgPulse = Math.min(0.3, bgPulse + 0.03);

        // Fever intensity
        if (chainCount >= 15) feverIntensity = Math.min(1.0, feverIntensity + 0.15);
        else if (chainCount >= 10) feverIntensity = Math.min(0.6, feverIntensity + 0.1);
        else if (chainCount >= 5) feverIntensity = Math.min(0.3, feverIntensity + 0.05);

        // No sustained slow-mo — keep it fast

        // Celebrations
        for (const cel of CELEBRATIONS) {
            if (chainCount === cel.chain && lastCelebration < cel.chain) {
                lastCelebration = cel.chain;
                spawnCelebration(cel.text, cel.hue, cel.size);
                audio.playCelebration(CELEBRATIONS.indexOf(cel));
                break;
            }
        }

        // Schedule child explosion — inherits dot type (property transmission)
        const delay = CASCADE_STAGGER_MS + (Math.random() - 0.5) * 2 * CASCADE_JITTER_MS;
        pendingExplosions.push({
            x: dot.x, y: dot.y,
            generation: generation + 1,
            time: performance.now() + delay,
            parentX: dot.x, parentY: dot.y,
            dotType: dot.type,
        });
    }

    function handleDotCaught(dot, dotIndex, generation, expX, expY) {
        if (scheduledDetonations.has(dotIndex)) return;
        scheduledDetonations.add(dotIndex);
        detonateDot(dot, dotIndex, generation, expX, expY);
    }

    // Simple tap — no charge mechanic
    function handleTap(x, y) {
        if (gameState === 'start') {
            audio.init();
            round = 1;
            totalScore = 0;
            consecutiveFails = 0;
            mercyBonus = 0;
            peakRound = 1;
            replayLog = [];
            replayStartTime = performance.now();
            startRound();
            return;
        }

        if (gameState === 'gameover') {
            // Setback: go back SETBACK_ROUNDS, not to R1
            round = Math.max(1, round - SETBACK_ROUNDS);
            totalScore = Math.max(0, totalScore - score); // remove failed round score
            // Mercy: consecutive fails on same frontier increase radius
            consecutiveFails++;
            mercyBonus = Math.min(MERCY_RADIUS_CAP, consecutiveFails * MERCY_RADIUS_BONUS);
            startRound();
            return;
        }

        if (gameState !== 'playing') return;

        audio.init();
        audio.playTap();

        // Log tap for replay
        replayLog.push({ t: performance.now() - replayStartTime, type: 'tap', data: { x, y, round, chainCount } });

        gameState = 'resolving';
        freezeFrames = HIT_FREEZE_FRAMES;

        // Apply mercy bonus to explosion radius
        const effectiveRadius = explosionRadius * (1 + mercyBonus);
        const exp = new Explosion(x, y, 0, effectiveRadius, handleDotCaught);
        explosions.push(exp);

        let hitAny = false;
        for (const dot of dots) {
            if (dot.active && Math.hypot(dot.x - x, dot.y - y) <= explosionRadius) {
                hitAny = true; break;
            }
        }
        if (!hitAny) audio.playMiss();
    }

    function checkRoundEnd() {
        if (explosions.length > 0 || pendingExplosions.length > 0) return;

        const params = getRoundParams(round);
        if (chainCount >= params.target) {
            totalScore += score;
            if (round > bestRound) {
                bestRound = round;
                localStorage.setItem('cr3_bestRound', bestRound);
            }
            if (totalScore > bestScore) {
                bestScore = totalScore;
                localStorage.setItem('cr3_bestScore', bestScore);
            }

            // Clear = reset mercy (you proved you can do it)
            consecutiveFails = 0;
            mercyBonus = 0;

            // Log round clear for replay
            replayLog.push({ t: performance.now() - replayStartTime, type: 'clear', data: { round, chainCount, score, target: params.target } });

            // Lavish round-clear celebration (Peggle-style)
            spawnCelebration(`Round ${round} Clear!`, 200, 1.4);
            audio.playRoundClear();
            slowMoTarget = 0.6; // Brief celebration pause

            round++;
            if (round > peakRound) peakRound = round;
            const nextParams = getRoundParams(round);
            generateDots(nextParams.dots, nextParams.speedMin, nextParams.speedMax, nextParams.typeWeights);
            explosions = [];
            scheduledDetonations = new Set();
            pendingExplosions = [];
            chainCount = 0;
            score = 0;
            lastChainFreqs = [];
            currentMultiplier = 1;
            multiplierPulse = 0;
            feverIntensity = 0;
            lastCelebration = -1;
            gameState = 'playing';
        } else {
            markNearMissDots();
            gameState = 'gameover';
            gameOverTimer = 0;
            audio.playGameOver();
            // Log failure for replay
            const frustration = params.target > 0 ? chainCount / params.target : 0;
            replayLog.push({ t: performance.now() - replayStartTime, type: 'fail', data: { round, chainCount, target: params.target, frustration: +frustration.toFixed(2) } });
        }
    }

    function markNearMissDots() {
        const nmRadius = explosionRadius * 1.2;
        for (const dot of dots) {
            if (!dot.active) continue;
            for (let i = 0; i < dots.length; i++) {
                const other = dots[i];
                if (other.active || other === dot) continue;
                if (Math.hypot(dot.x - other.x, dot.y - other.y) <= nmRadius) {
                    dot.nearMiss = 1.0;
                    break;
                }
            }
        }
    }

    // =====================================================================
    // UPDATE
    // =====================================================================
    let lastFrame = performance.now();

    function update() {
        const now = performance.now();
        lastFrame = now;

        if (freezeFrames > 0) { freezeFrames--; return; }

        updateAmbient();
        updateFloatingTexts();
        updateChainLines();
        particles.update();

        // Music system — rhythmic arpeggio (present, not buried)
        if (audio.initialized && gameState !== 'start' && now >= nextMusicBeat) {
            nextMusicBeat = now + MUSIC_BEAT_MS;
            const idx = musicBeat % MUSIC_PATTERN.length;
            const [noteIdx, volMult] = MUSIC_PATTERN[idx];
            // Duck during resolving (chain notes are the star) but don't mute
            const musicVol = gameState === 'resolving' ? 0.08 : 0.20;
            audio.playMusicNote(noteIdx, musicVol * volMult);
            if (idx % 4 === 0) audio.playMusicBass(0);
            // Beat pulse — background throbs with the music
            beatPulse = Math.max(beatPulse, idx % 4 === 0 ? 0.08 : 0.04);
            musicBeat++;
        }

        // Dot neighbor count (for connectivity glow)
        for (const d of dots) {
            if (!d.active) continue;
            d._neighbors = 0;
            for (const o of dots) {
                if (o === d || !o.active) continue;
                if (Math.hypot(d.x - o.x, d.y - o.y) <= explosionRadius * 2) d._neighbors++;
            }
        }

        // Process pending explosions
        for (let i = pendingExplosions.length - 1; i >= 0; i--) {
            if (now >= pendingExplosions[i].time) {
                const p = pendingExplosions[i];
                explosions.push(new Explosion(p.x, p.y, p.generation, explosionRadius, handleDotCaught, p.parentX, p.parentY, p.dotType));
                pendingExplosions.splice(i, 1);
            }
        }

        for (const d of dots) d.update();
        explosions = explosions.filter(e => e.update(now));

        // Screen shake
        if (shakeTrauma > 0.001) {
            const s = shakeTrauma * shakeTrauma;
            shakeX = SHAKE_MAX_OFFSET * s * (Math.random() * 2 - 1);
            shakeY = SHAKE_MAX_OFFSET * s * (Math.random() * 2 - 1);
            shakeTrauma *= SHAKE_DECAY;
        } else { shakeX = 0; shakeY = 0; shakeTrauma = 0; }

        if (bgPulse > 0.001) bgPulse *= 0.93; else bgPulse = 0;

        // Multiplier pulse decay
        if (multiplierPulse > 0) multiplierPulse = Math.max(0, multiplierPulse - 0.04);

        // Fever decay
        if (gameState !== 'resolving' && feverIntensity > 0) {
            feverIntensity = Math.max(0, feverIntensity - 0.008);
        }

        // Slow-mo
        if (slowMo !== slowMoTarget) {
            slowMo += (slowMoTarget - slowMo) * 0.15;
            if (Math.abs(slowMo - slowMoTarget) < 0.01) slowMo = slowMoTarget;
        }
        if (slowMoTarget < 1 && explosions.length === 0 && pendingExplosions.length === 0) {
            slowMoTarget = 1.0;
        }

        if (gameState === 'gameover') {
            gameOverTimer = Math.min(1, gameOverTimer + 0.015);
        }

        if (gameState === 'resolving') checkRoundEnd();
    }

    // =====================================================================
    // DRAW
    // =====================================================================
    function draw() {
        ctx.fillStyle = '#020210';
        ctx.fillRect(0, 0, W, H);

        const bp = bgPulse + beatPulse;
        const bgGrad = ctx.createRadialGradient(W/2, H * 0.55, 0, W/2, H * 0.55, Math.max(W, H) * 0.7);
        bgGrad.addColorStop(0, `rgba(${12 + bp * 80|0}, ${8 + bp * 40|0}, ${25 + bp * 100|0}, 1)`);
        bgGrad.addColorStop(0.5, `rgba(${5 + bp * 40|0}, ${4 + bp * 20|0}, ${18 + bp * 50|0}, 1)`);
        bgGrad.addColorStop(1, 'rgba(2, 2, 12, 1)');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, W, H);

        // Vignette
        const vigGrad = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.25, W/2, H/2, Math.max(W,H)*0.75);
        vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
        vigGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
        ctx.fillStyle = vigGrad;
        ctx.fillRect(0, 0, W, H);

        // Fever glow
        if (feverIntensity > 0) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = feverIntensity * 0.04;
            const fh = (performance.now() * 0.05) % 360;
            const fg = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.5);
            fg.addColorStop(0, `hsla(${fh}, 80%, 50%, 1)`);
            fg.addColorStop(1, `hsla(${fh + 30}, 60%, 30%, 0)`);
            ctx.fillStyle = fg;
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        }

        // Screen flash on celebrations (40-50% opacity per research)
        if (screenFlash > 0.005) {
            ctx.fillStyle = `rgba(255, 255, 255, ${screenFlash})`;
            ctx.fillRect(0, 0, W, H);
            screenFlash *= 0.78;
            if (screenFlash < 0.005) screenFlash = 0;
        }

        // Beat pulse decay
        if (beatPulse > 0.001) beatPulse *= 0.86; else beatPulse = 0;

        drawAmbient();

        ctx.save();
        ctx.translate(shakeX, shakeY);

        // Connection lines between chainable dots (always visible)
        drawConnections();

        drawChainLines();
        for (const e of explosions) e.draw(ctx);
        particles.draw(ctx);
        for (const d of dots) d.draw(ctx);
        drawFloatingTexts();

        ctx.restore();

        drawUI();
    }

    // =====================================================================
    // CONNECTIONS — soft auras + lines between chainable dots
    // =====================================================================
    function drawConnections() {
        if (gameState !== 'playing' && gameState !== 'resolving') return;
        const now = performance.now();
        const pulse = Math.sin(now * 0.003) * 0.12 + 0.88;
        const r = explosionRadius;

        // Count neighbors for each active dot
        for (let i = 0; i < dots.length; i++) {
            if (dots[i].active) dots[i]._neighbors = 0;
        }
        const pairs = [];
        for (let i = 0; i < dots.length; i++) {
            const a = dots[i];
            if (!a.active) continue;
            for (let j = i + 1; j < dots.length; j++) {
                const b = dots[j];
                if (!b.active) continue;
                const dist = Math.hypot(a.x - b.x, a.y - b.y);
                if (dist <= r) {
                    a._neighbors++;
                    b._neighbors++;
                    pairs.push(a, b, dist);
                }
            }
        }

        ctx.globalCompositeOperation = 'lighter';

        // Soft gradient auras (NOT rings) around every active dot
        for (const d of dots) {
            if (!d.active) continue;
            const hue = d.getHue();
            const n = d._neighbors;

            // Aura alpha: faint when isolated, brighter with neighbors
            const auraAlpha = (n > 0
                ? 0.06 + Math.min(0.14, n * 0.04)
                : 0.025) * pulse * d.alpha;

            ctx.globalAlpha = auraAlpha;
            const ag = ctx.createRadialGradient(d.x, d.y, DOT_GLOW_SIZE, d.x, d.y, r);
            ag.addColorStop(0, `hsla(${hue}, 50%, 55%, 0.6)`);
            ag.addColorStop(0.6, `hsla(${hue}, 40%, 45%, 0.2)`);
            ag.addColorStop(1, `hsla(${hue}, 30%, 40%, 0)`);
            ctx.fillStyle = ag;
            ctx.beginPath();
            ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Connection lines between chainable pairs
        for (let k = 0; k < pairs.length; k += 3) {
            const a = pairs[k], b = pairs[k+1], dist = pairs[k+2];
            const proximity = 1 - dist / r;
            const hue = (a.getHue() + b.getHue()) / 2;
            const alpha = proximity * 0.40 * pulse;

            // Wide glow
            ctx.globalAlpha = alpha * 0.4;
            ctx.strokeStyle = `hsla(${hue}, 50%, 65%, 1)`;
            ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();

            // Bright core
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = `hsla(${hue}, 40%, 88%, 1)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
        }

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    // =====================================================================
    // UI
    // =====================================================================
    function drawUI() {
        const params = getRoundParams(round);
        const screenMin = Math.min(W, H);
        const s = Math.max(1, screenMin / 600);

        if (gameState === 'start') { drawStartScreen(); return; }

        // Round counter
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.letterSpacing = '2px';
        ctx.fillText('ROUND', W/2, 14 * s);
        ctx.letterSpacing = '0px';

        ctx.font = `300 ${38 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillText(round, W/2, 28 * s);

        // Chain / target
        const infoY = 72 * s;
        if (gameState === 'resolving') {
            const targetMet = chainCount >= params.target;
            ctx.font = `700 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.save();
            ctx.shadowColor = targetMet ? 'rgba(255, 200, 60, 0.4)' : 'rgba(255,255,255,0.2)';
            ctx.shadowBlur = 6;
            ctx.fillStyle = targetMet ? 'rgba(255, 220, 100, 0.95)' : 'rgba(255,255,255,0.7)';
            ctx.fillText(`${chainCount} / ${params.target}`, W/2, infoY);
            ctx.restore();

            // Multiplier display
            if (currentMultiplier > 1) {
                const mp = multiplierPulse > 0 ? 1 + easeOutBack(multiplierPulse) * 0.4 : 1;
                const multSize = Math.round(22 * s * mp);
                const multHue = currentMultiplier >= 5 ? 300 : currentMultiplier >= 3 ? 15 : 50;
                ctx.save();
                ctx.shadowColor = `hsla(${multHue}, 90%, 60%, 0.6)`;
                ctx.shadowBlur = 12 * s;
                ctx.font = `900 ${multSize}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = `hsl(${multHue}, 90%, 70%)`;
                ctx.fillText(`x${currentMultiplier}`, W/2, infoY + 22 * s);
                ctx.restore();
            }
        } else if (gameState === 'playing') {
            ctx.font = `400 ${13 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillText(`Target: ${params.target}`, W/2, infoY);
            // Mercy indicator (subtle)
            if (mercyBonus > 0) {
                ctx.font = `300 ${10 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.fillText(`+${Math.round(mercyBonus * 100)}% reach`, W/2, infoY + 18 * s);
            }
        }

        if (gameState === 'gameover') drawGameOver();

        if (bestRound > 0 && gameState === 'playing') {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fillText(`Best: Round ${bestRound}`, W/2, H - 12 * s);
        }

        // Build info — bottom-right, very subtle
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.font = `300 ${9 * s | 0}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillText(`${BUILD_VERSION} · ${BUILD_DATE}`, W - 8 * s, H - 6 * s);
    }

    // Reusable pill button drawer — returns hit rect
    function drawPill(cx, cy, label, active, hue) {
        const s = Math.max(1, Math.min(W, H) / 600);
        const fontSize = Math.round(12 * s);
        ctx.font = `400 ${fontSize}px Inter, system-ui, sans-serif`;
        const textW = ctx.measureText(label).width;
        const pw = textW + 28 * s;
        const ph = 32 * s;
        const px = cx - pw / 2;
        const py = cy - ph / 2;
        const radius = ph / 2;

        // Background pill
        ctx.beginPath();
        ctx.roundRect(px, py, pw, ph, radius);
        if (active) {
            ctx.fillStyle = `hsla(${hue}, 50%, 45%, 0.35)`;
            ctx.fill();
            ctx.strokeStyle = `hsla(${hue}, 50%, 65%, 0.5)`;
        } else {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.06)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        }
        ctx.lineWidth = 1;
        ctx.stroke();

        // Label
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = active ? `hsla(${hue}, 60%, 80%, 0.9)` : 'rgba(255, 255, 255, 0.5)';
        ctx.fillText(label, cx, cy);

        return { x: px, y: py, w: pw, h: ph };
    }

    function drawStartScreen() {
        uiButtons = [];
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const titleSize = Math.min(52, W * 0.10);
        const subSize = Math.min(16, W * 0.038);
        const s = Math.max(1, Math.min(W, H) / 600);

        ctx.save();
        ctx.shadowColor = 'rgba(120, 180, 255, 0.4)';
        ctx.shadowBlur = 40;
        ctx.font = `300 ${titleSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.98)';
        ctx.letterSpacing = `${Math.max(1, titleSize * 0.06)}px`;
        ctx.fillText('CHAIN REACTION', W/2, H/2 - titleSize * 0.8);
        ctx.shadowBlur = 60;
        ctx.shadowColor = 'rgba(100, 160, 255, 0.2)';
        ctx.fillText('CHAIN REACTION', W/2, H/2 - titleSize * 0.8);
        ctx.letterSpacing = '0px';
        ctx.restore();

        ctx.font = `400 ${subSize}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText('Tap to start a chain reaction.', W/2, H/2 + subSize * 1.2);

        const promptAlpha = 0.2 + 0.12 * Math.sin(performance.now() * 0.003);
        ctx.font = `400 ${Math.min(14, subSize * 0.85)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = `rgba(255,255,255,${promptAlpha + 0.1})`;
        ctx.fillText('Tap anywhere to begin', W/2, H/2 + subSize * 3.5);

        if (bestRound > 0) {
            ctx.font = `200 ${Math.min(13, subSize * 0.8)}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillText(`Best: Round ${bestRound}`, W/2, H/2 + subSize * 6);
        }

        // Bottom buttons — Watch Bot toggle
        const btnY = H - 50 * s;
        const watchRect = drawPill(W / 2, btnY, spectatorMode ? 'Bot: ON' : 'Watch Bot', spectatorMode, 55);
        uiButtons.push({ id: 'watch', ...watchRect });
    }

    function drawGameOver() {
        const t = easeOutCubic(gameOverTimer);
        const s = Math.max(1, Math.min(W, H) / 600);

        ctx.fillStyle = `rgba(0, 0, 0, ${t * 0.55})`;
        ctx.fillRect(0, 0, W, H);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const scaleT = easeOutBack(Math.min(t * 1.5, 1));
        ctx.save();
        ctx.shadowColor = 'rgba(255, 140, 60, 0.35)';
        ctx.shadowBlur = 30 * s;
        ctx.font = `300 ${Math.round(48 * s * scaleT)}px Inter, system-ui, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fillText(`Round ${round}`, W/2, H/2 - 50 * s);
        ctx.restore();

        if (t > 0.3) {
            const t2 = easeOutCubic((t - 0.3) / 0.7);
            ctx.globalAlpha = t2;

            ctx.font = `300 ${18 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255, 160, 80, 0.85)';
            const params = getRoundParams(round);
            ctx.fillText(`Chain: ${chainCount} / ${params.target}`, W/2, H/2);

            ctx.font = `300 ${15 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText(`Total Score: ${totalScore + score}`, W/2, H/2 + 30 * s);

            if (round >= bestRound) {
                ctx.font = `600 ${14 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.fillText('New Best!', W/2, H/2 + 58 * s);
            }

            // Setback info
            const restartRound = Math.max(1, round - SETBACK_ROUNDS);
            if (restartRound > 1) {
                ctx.font = `300 ${12 * s | 0}px Inter, system-ui, sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(`Restart from Round ${restartRound}`, W/2, H/2 + 72 * s);
            }
        }

        if (t > 0.6) {
            const t3 = (t - 0.6) / 0.4;
            const pa = t3 * (0.3 + 0.1 * Math.sin(performance.now() * 0.003));
            ctx.font = `300 ${14 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = `rgba(255,255,255,${pa})`;
            ctx.fillText('Tap to try again', W/2, H/2 + 100 * s);

            // Bottom buttons on game over
            const btnY = H - 50 * s;
            const gap = 10 * s;
            const watchRect = drawPill(W / 2 - 60 * s, btnY, spectatorMode ? 'Bot: ON' : 'Watch Bot', spectatorMode, 55);
            uiButtons.push({ id: 'watch', ...watchRect });
            if (replayLog.length > 0) {
                const replayRect = drawPill(W / 2 + 60 * s, btnY, 'Save Replay', false, 200);
                uiButtons.push({ id: 'replay', ...replayRect });
            }
        }

        ctx.globalAlpha = 1;
    }

    // =====================================================================
    // SPECTATOR BOT (greedy grid search)
    // =====================================================================
    function botFindBestTap() {
        const gridSize = 20;
        let bestX = W / 2, bestY = H / 2, bestCount = 0;
        const r = explosionRadius * (1 + mercyBonus);
        for (let gx = 0; gx < gridSize; gx++) {
            for (let gy = 0; gy < gridSize; gy++) {
                const x = (gx + 0.5) * W / gridSize;
                const y = (gy + 0.5) * H / gridSize;
                let count = 0;
                for (const d of dots) {
                    if (d.active && Math.hypot(d.x - x, d.y - y) <= r) count++;
                }
                if (count > bestCount) { bestCount = count; bestX = x; bestY = y; }
            }
        }
        return { x: bestX, y: bestY, count: bestCount };
    }

    function updateBot(now) {
        if (!spectatorMode) return;

        if (gameState === 'start') {
            handleTap(W / 2, H / 2);
            return;
        }

        if (gameState === 'gameover' && gameOverTimer > 0.8) {
            handleTap(W / 2, H / 2);
            return;
        }

        if (gameState !== 'playing') return;

        // Scan for best position periodically — but don't reset if already committed
        if (!botTarget && now - botLastScan > botScanInterval) {
            botLastScan = now;
            const best = botFindBestTap();
            if (best.count >= 1) {
                botTarget = {
                    x: best.x + (Math.random() - 0.5) * 20,
                    y: best.y + (Math.random() - 0.5) * 20,
                    count: best.count,
                };
                botThinkTimer = botReactionDelay + Math.random() * 200;
            }
        }

        // Countdown reaction delay, then tap
        if (botTarget) {
            botThinkTimer -= 16.67;
            if (botThinkTimer <= 0) {
                // Re-evaluate at tap time (dots moved)
                const fresh = botFindBestTap();
                if (fresh.count >= 1) {
                    handleTap(fresh.x + (Math.random() - 0.5) * 10, fresh.y + (Math.random() - 0.5) * 10);
                }
                botTarget = null;
                botLastScan = now; // reset scan timer after tap
            }
        }
    }

    function drawBotOverlay() {
        const s = Math.max(1, Math.min(W, H) / 600);

        // Bot target crosshair (only when spectating)
        if (spectatorMode && botTarget && gameState === 'playing') {
            const pulse = Math.sin(performance.now() * 0.008) * 0.3 + 0.7;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.4 * pulse;
            ctx.strokeStyle = 'rgba(255, 255, 100, 1)';
            ctx.lineWidth = 1.5;

            const cr = 15 * s;
            ctx.beginPath();
            ctx.moveTo(botTarget.x - cr, botTarget.y);
            ctx.lineTo(botTarget.x + cr, botTarget.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(botTarget.x, botTarget.y - cr);
            ctx.lineTo(botTarget.x, botTarget.y + cr);
            ctx.stroke();

            ctx.globalAlpha = 0.15 * pulse;
            ctx.beginPath();
            ctx.arc(botTarget.x, botTarget.y, explosionRadius * (1 + mercyBonus), 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }

        // Small bot toggle pill — top-left during play, always visible
        if (gameState === 'playing' || gameState === 'resolving') {
            const bx = 8 * s;
            const by = 8 * s;
            const bw = spectatorMode ? 52 * s : 36 * s;
            const bh = 22 * s;
            const br = bh / 2;

            ctx.beginPath();
            ctx.roundRect(bx, by, bw, bh, br);
            ctx.fillStyle = spectatorMode ? 'rgba(255, 255, 100, 0.12)' : 'rgba(255, 255, 255, 0.04)';
            ctx.fill();
            ctx.strokeStyle = spectatorMode ? 'rgba(255, 255, 100, 0.25)' : 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 0.5;
            ctx.stroke();

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `600 ${8 * s | 0}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = spectatorMode ? 'rgba(255, 255, 100, 0.5)' : 'rgba(255, 255, 255, 0.15)';
            ctx.fillText(spectatorMode ? 'BOT' : 'BOT', bx + bw / 2, by + bh / 2);

            // Small dot indicator
            if (spectatorMode) {
                ctx.beginPath();
                ctx.arc(bx + bw - 8 * s, by + bh / 2, 3 * s, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 255, 100, 0.6)';
                ctx.fill();
            }

            uiButtons.push({ id: 'watch', x: bx, y: by, w: bw, h: bh });
        }
    }

    // =====================================================================
    // REPLAY DOWNLOAD
    // =====================================================================
    function downloadReplay() {
        if (replayLog.length === 0) return;
        const data = JSON.stringify({
            version: BUILD_VERSION,
            date: BUILD_DATE,
            viewport: { w: W, h: H },
            peakRound,
            bestRound,
            totalScore,
            events: replayLog,
        }, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `replay-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // =====================================================================
    // GAME LOOP
    // =====================================================================
    function loop() {
        const now = performance.now();
        uiButtons = []; // clear each frame — buttons register themselves in draw
        updateBot(now);
        update();
        draw();
        drawBotOverlay();
        requestAnimationFrame(loop);
    }

    // =====================================================================
    // INPUT
    // =====================================================================
    function hitTestButtons(x, y) {
        for (const btn of uiButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                return btn.id;
            }
        }
        return null;
    }

    canvas.addEventListener('pointerdown', e => {
        e.preventDefault();
        const x = e.clientX, y = e.clientY;

        // Check UI buttons first
        const hit = hitTestButtons(x, y);
        if (hit === 'watch') {
            spectatorMode = !spectatorMode;
            if (spectatorMode) { botTarget = null; botLastScan = 0; }
            return;
        }
        if (hit === 'replay') {
            downloadReplay();
            return;
        }

        // Normal game input
        if (!spectatorMode) handleTap(x, y);
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Keyboard shortcuts (desktop fallback)
    document.addEventListener('keydown', e => {
        if (e.key === 'w' || e.key === 'W') {
            spectatorMode = !spectatorMode;
            if (spectatorMode) { botTarget = null; botLastScan = 0; }
        }
        if (e.key === 'r' || e.key === 'R') {
            downloadReplay();
        }
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initAmbient();
    generateDots(10, 0.5, 1.0);
    gameState = 'start';
    lastFrame = performance.now();
    if (spectatorMode) audio.init();
    loop();

    </script>
</body>
</html>
