<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Chain Reaction — PvP</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; }
body { background: #04040f; overflow: hidden; font-family: 'Inter', sans-serif; }
canvas { display: block; }
</style>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;400;700;900&display=swap" rel="stylesheet">
</head>
<body>
<canvas id="pvp"></canvas>
<script src="game-core.js"></script>
<script>
'use strict';

// =========================================================================
// CHAIN REACTION — Local PvP Mode
//
// Split-screen 2-player mode. Each player taps their half of the screen.
// Chains generate garbage dots sent to the opponent's board.
// First player to overflow loses.
// =========================================================================

const canvas = document.getElementById('pvp');
const ctx = canvas.getContext('2d');

// =========================================================================
// PVP CONFIG
// =========================================================================

const PVP_CONFIG = {
    garbageDivisor: 7,
    garbageDelay: 3000,
    maxPendingGarbage: 30,
    tier: 'FLOW',
    dividerWidth: 4,
};

// =========================================================================
// STATE
// =========================================================================

let W, H, playerW;
let gameA, gameB;
let stateA, stateB; // per-player state
let pvpState = 'menu'; // 'menu' | 'playing' | 'gameover'
let winner = null;
let selectedTier = 'FLOW';
let vsMode = 'bot'; // '2p' | 'bot'
let botDifficulty = 'FLOW'; // bot skill key
let botRunner = null;
let botRng = null;

const TIERS = Object.keys(CONTINUOUS_TIERS);
const BOT_DIFFICULTIES = ['CALM', 'FLOW', 'SURGE', 'TRANSCENDENCE', 'IMPOSSIBLE'];

// =========================================================================
// GARBAGE QUEUE
// =========================================================================

class GarbageQueue {
    constructor() {
        this.pending = [];
        this.totalSent = 0;
        this.totalReceived = 0;
        this.totalOffset = 0;
    }

    queue(amount, spawnTime) {
        if (amount <= 0) return;
        this.pending.push({ amount, spawnTime });
        this.totalSent += amount;
    }

    offset(chainGarbage) {
        let remaining = chainGarbage;
        for (let i = 0; i < this.pending.length && remaining > 0; i++) {
            const cancel = Math.min(this.pending[i].amount, remaining);
            this.pending[i].amount -= cancel;
            remaining -= cancel;
            this.totalOffset += cancel;
        }
        this.pending = this.pending.filter(p => p.amount > 0);
        return remaining;
    }

    getReady(currentTime) {
        let total = 0;
        this.pending = this.pending.filter(p => {
            if (currentTime >= p.spawnTime) {
                total += p.amount;
                return false;
            }
            return true;
        });
        this.totalReceived += total;
        return total;
    }

    pendingTotal() {
        return this.pending.reduce((a, p) => a + p.amount, 0);
    }
}

function calcGarbage(chainLength, divisor) {
    if (chainLength < 2) return 0;
    return Math.floor(chainLength * chainLength / divisor);
}

// =========================================================================
// INITIALIZATION
// =========================================================================

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    playerW = Math.floor((W - PVP_CONFIG.dividerWidth) / 2);

    if (gameA) {
        gameA.W = playerW;
        gameA.H = H;
        const REF_AREA = 390 * 844;
        gameA.spatialScale = Math.sqrt((playerW * H) / REF_AREA);
        gameA.cfg.SCREEN_MARGIN = 16 * gameA.spatialScale;
        gameA.cfg.MIN_DOT_DISTANCE = 25 * gameA.spatialScale;
        gameA.recalcRadius(0);
    }
    if (gameB) {
        gameB.W = playerW;
        gameB.H = H;
        const REF_AREA = 390 * 844;
        gameB.spatialScale = Math.sqrt((playerW * H) / REF_AREA);
        gameB.cfg.SCREEN_MARGIN = 16 * gameB.spatialScale;
        gameB.cfg.MIN_DOT_DISTANCE = 25 * gameB.spatialScale;
        gameB.recalcRadius(0);
    }
}

function startMatch() {
    const tier = CONTINUOUS_TIERS[selectedTier];
    const tierCfg = {
        spawnRate: tier.spawnRate,
        spawnAccel: 0,
        cooldown: tier.cooldown,
        maxDots: tier.maxDots,
        speedMin: tier.speedMin,
        speedMax: tier.speedMax,
        dotTypes: tier.dotTypes,
        overflowDensity: tier.overflowDensity,
        spawnDensityScale: tier.spawnDensityScale || 0,
    };

    gameA = new Game(playerW, H, {}, Math.random);
    gameB = new Game(playerW, H, {}, Math.random);
    gameA.startContinuous(tierCfg);
    gameB.startContinuous(tierCfg);

    stateA = {
        garbageQueue: new GarbageQueue(),
        prevChainCount: 0,
        score: 0,
        label: 'P1',
        color: '#4af',
        particles: [],
    };
    stateB = {
        garbageQueue: new GarbageQueue(),
        prevChainCount: 0,
        score: 0,
        label: vsMode === 'bot' ? 'BOT' : 'P2',
        color: '#f64',
        particles: [],
    };

    // Set up bot if vs bot mode
    if (vsMode === 'bot') {
        botRng = createRNG(Date.now());
        botRunner = new BotRunner(gameB, botDifficulty, botRng);
    } else {
        botRunner = null;
    }

    pvpState = 'playing';
    winner = null;
}

// =========================================================================
// GAME LOOP
// =========================================================================

const DT = 16.67;

function update() {
    if (pvpState !== 'playing') return;

    gameA.step(DT);
    gameB.step(DT);
    gameA.events = [];
    gameB.events = [];

    // Bot plays on the right side
    if (botRunner) {
        const tap = botRunner.update(DT);
        if (tap) {
            gameB.tap(tap.x, tap.y);
        }
    }

    // Check chain completions and send garbage
    processChains(gameA, stateA, gameB, stateB);
    processChains(gameB, stateB, gameA, stateA);

    // Spawn ready garbage
    spawnGarbage(gameA, stateA);
    spawnGarbage(gameB, stateB);

    // Update particles
    updateParticles(stateA.particles);
    updateParticles(stateB.particles);

    // Check game over
    if (gameA.overflowed) {
        pvpState = 'gameover';
        winner = 'P2';
    } else if (gameB.overflowed) {
        pvpState = 'gameover';
        winner = 'P1';
    }
}

function processChains(attacker, attackerState, defender, defenderState) {
    if (attacker.chainLengths.length > attackerState.prevChainCount) {
        const chainLen = attacker.chainLengths[attacker.chainLengths.length - 1];
        const rawGarbage = calcGarbage(chainLen, PVP_CONFIG.garbageDivisor);

        // Offset own incoming garbage first
        const surplus = attackerState.garbageQueue.offset(rawGarbage);

        // Send surplus to defender
        if (surplus > 0) {
            const capped = Math.min(surplus, PVP_CONFIG.maxPendingGarbage - defenderState.garbageQueue.pendingTotal());
            if (capped > 0) {
                defenderState.garbageQueue.queue(capped, attacker.time + PVP_CONFIG.garbageDelay);
            }
        }

        attackerState.prevChainCount = attacker.chainLengths.length;
        attackerState.score = attacker.score;

        // Spawn particles for chain
        if (chainLen >= 3) {
            for (let i = 0; i < chainLen; i++) {
                attackerState.particles.push({
                    x: Math.random() * playerW,
                    y: Math.random() * H,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 3 - 1,
                    life: 30 + Math.random() * 30,
                    maxLife: 60,
                    size: 2 + Math.random() * 3,
                });
            }
        }
    }
}

function spawnGarbage(game, state) {
    const tier = CONTINUOUS_TIERS[selectedTier];
    const garbageCount = state.garbageQueue.getReady(game.time);
    for (let i = 0; i < garbageCount && game.activeDotCount() < tier.maxDots; i++) {
        const prevLen = game.dots.length;
        game._spawnOneDot();
        // Mark newly spawned dot as garbage for visual differentiation
        if (game.dots.length > prevLen) {
            game.dots[game.dots.length - 1].isGarbage = true;
        }
    }
}

function updateParticles(particles) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

// =========================================================================
// RENDERING
// =========================================================================

const TYPE_HUES = { standard: 210, gravity: 270, volatile: 30, poison: 120 };

function drawDot(d, game) {
    if (!d.active) return;
    const r = Math.max(4, Math.min(game.W, game.H) * 0.012);

    if (d.isGarbage) {
        // Garbage dots: desaturated, reddish, with warning ring
        ctx.beginPath();
        ctx.arc(d.x, d.y, r * 2.5, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(d.x, d.y, r * 0.3, d.x, d.y, r * 2.5);
        glow.addColorStop(0, 'rgba(255, 80, 60, 0.25)');
        glow.addColorStop(1, 'rgba(255, 80, 60, 0)');
        ctx.fillStyle = glow;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
        ctx.fillStyle = 'hsl(0, 30%, 50%)';
        ctx.fill();

        // Dashed warning ring
        ctx.beginPath();
        ctx.arc(d.x, d.y, r * 1.6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 80, 60, 0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.stroke();
        ctx.setLineDash([]);
    } else {
        const hue = TYPE_HUES[d.type] || (195 - (d.y / game.H) * 180);

        // Glow
        ctx.beginPath();
        ctx.arc(d.x, d.y, r * 3, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(d.x, d.y, r * 0.5, d.x, d.y, r * 3);
        glow.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.3)`);
        glow.addColorStop(1, `hsla(${hue}, 80%, 60%, 0)`);
        ctx.fillStyle = glow;
        ctx.fill();

        // Core
        ctx.beginPath();
        ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
        ctx.fillStyle = `hsl(${hue}, 80%, 65%)`;
        ctx.fill();
    }

    // Bloom flash
    if (d.bloomTimer > 0) {
        ctx.beginPath();
        ctx.arc(d.x, d.y, r * 2, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${d.bloomTimer / 12 * 0.5})`;
        ctx.fill();
        d.bloomTimer--;
    }
}

function drawExplosion(e) {
    if (e.radius <= 0) return;
    const hue = TYPE_HUES[e.dotType] || 210;

    // Outer glow
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius * 1.5, 0, Math.PI * 2);
    const outerGlow = ctx.createRadialGradient(e.x, e.y, e.radius * 0.3, e.x, e.y, e.radius * 1.5);
    outerGlow.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.15)`);
    outerGlow.addColorStop(1, `hsla(${hue}, 70%, 50%, 0)`);
    ctx.fillStyle = outerGlow;
    ctx.fill();

    // Core
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
    const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius);
    grad.addColorStop(0, `hsla(${hue}, 60%, 70%, 0.3)`);
    grad.addColorStop(0.7, `hsla(${hue}, 70%, 50%, 0.15)`);
    grad.addColorStop(1, `hsla(${hue}, 80%, 40%, 0)`);
    ctx.fillStyle = grad;
    ctx.fill();

    // Ring
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
    ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${e.phase === 'shrink' ? 0.2 : 0.4})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();
}

function drawPlayer(game, state, offsetX) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(offsetX, 0, playerW, H);
    ctx.clip();
    ctx.translate(offsetX, 0);

    // Background
    const density = game.density();
    const bgR = Math.floor(4 + density * 20);
    const bgG = Math.floor(4 + density * 5);
    const bgB = Math.floor(15 + density * 10);
    ctx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
    ctx.fillRect(0, 0, playerW, H);

    // Dots
    for (const d of game.dots) drawDot(d, game);

    // Explosions
    for (const e of game.explosions) drawExplosion(e);

    // Particles
    for (const p of state.particles) {
        const alpha = p.life / p.maxLife;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
        ctx.fill();
    }

    // HUD
    const fontSize = Math.max(12, playerW * 0.04);

    // Player label
    ctx.font = `900 ${fontSize * 1.5}px Inter`;
    ctx.fillStyle = state.color;
    ctx.textAlign = 'center';
    ctx.fillText(state.label, playerW / 2, fontSize * 2);

    // Score
    ctx.font = `700 ${fontSize}px Inter`;
    ctx.fillStyle = '#fff';
    ctx.fillText(game.score.toLocaleString(), playerW / 2, fontSize * 3.5);

    // Density bar
    const barW = playerW * 0.8;
    const barH = 6;
    const barX = (playerW - barW) / 2;
    const barY = H - 40;

    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.fillRect(barX, barY, barW, barH);

    const densityColor = density > 0.7 ? '#f44' : density > 0.5 ? '#fa4' : '#4f4';
    ctx.fillStyle = densityColor;
    ctx.fillRect(barX, barY, barW * Math.min(1, density), barH);

    // Density text
    ctx.font = `400 ${fontSize * 0.7}px Inter`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.textAlign = 'center';
    ctx.fillText(`${(density * 100).toFixed(0)}%`, playerW / 2, barY - 4);

    // Pending garbage indicator
    const pending = state.garbageQueue.pendingTotal();
    if (pending > 0) {
        const garbageBarH = Math.min(H * 0.3, pending * 8);
        ctx.fillStyle = 'rgba(255, 60, 60, 0.4)';
        ctx.fillRect(playerW - 12, 0, 12, garbageBarH);

        ctx.font = `900 ${fontSize * 0.8}px Inter`;
        ctx.fillStyle = '#f44';
        ctx.textAlign = 'right';
        ctx.fillText(`+${pending}`, playerW - 16, garbageBarH + fontSize);
    }

    // Cooldown indicator
    const cdRemaining = game.cooldownRemaining();
    if (cdRemaining > 0) {
        const cdFrac = cdRemaining / (CONTINUOUS_TIERS[selectedTier].cooldown || 2000);
        ctx.fillStyle = `rgba(255, 255, 255, ${0.15 * cdFrac})`;
        ctx.fillRect(0, H - 4, playerW * (1 - cdFrac), 4);
    }

    // Chain info
    if (game.chainLengths.length > 0) {
        const lastChain = game.chainLengths[game.chainLengths.length - 1];
        const maxChain = Math.max(...game.chainLengths);
        ctx.font = `400 ${fontSize * 0.7}px Inter`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.textAlign = 'left';
        ctx.fillText(`Chain: ${lastChain} | Best: ${maxChain}`, 10, H - 50);
    }

    ctx.restore();
}

function drawDivider() {
    const x = playerW;
    ctx.fillStyle = '#222';
    ctx.fillRect(x, 0, PVP_CONFIG.dividerWidth, H);
}

function drawMenu() {
    ctx.fillStyle = '#04040f';
    ctx.fillRect(0, 0, W, H);

    const fontSize = Math.max(14, Math.min(W, H) * 0.028);

    // Title
    ctx.font = `900 ${fontSize * 2.5}px Inter`;
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText('CHAIN REACTION', W / 2, H * 0.12);

    ctx.font = `200 ${fontSize * 1.2}px Inter`;
    ctx.fillStyle = '#4af';
    ctx.fillText('V E R S U S', W / 2, H * 0.12 + fontSize * 3);

    // Mode selector: vs Bot | 2P Local
    const modeY = H * 0.28;
    ctx.font = `400 ${fontSize * 0.8}px Inter`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.fillText('MODE', W / 2, modeY - fontSize);

    const modes = [
        { id: 'bot', label: 'VS BOT' },
        { id: '2p', label: '2P LOCAL' },
    ];
    const modeSpacing = fontSize * 5;
    for (let i = 0; i < modes.length; i++) {
        const x = W / 2 + (i - 0.5) * modeSpacing;
        const selected = modes[i].id === vsMode;
        ctx.font = `${selected ? 900 : 400} ${fontSize * 1.1}px Inter`;
        ctx.fillStyle = selected ? '#fff' : 'rgba(255, 255, 255, 0.25)';
        ctx.fillText(modes[i].label, x, modeY);
        if (selected) {
            ctx.fillStyle = '#4af';
            ctx.fillRect(x - modeSpacing * 0.25, modeY + 6, modeSpacing * 0.5, 3);
        }
    }

    // Bot difficulty (only in bot mode)
    if (vsMode === 'bot') {
        const botY = H * 0.40;
        ctx.font = `400 ${fontSize * 0.8}px Inter`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fillText('BOT DIFFICULTY', W / 2, botY - fontSize);

        const botSpacing = fontSize * 3;
        const botTotalW = BOT_DIFFICULTIES.length * botSpacing;
        const botStartX = (W - botTotalW) / 2 + botSpacing / 2;

        for (let i = 0; i < BOT_DIFFICULTIES.length; i++) {
            const x = botStartX + i * botSpacing;
            const selected = BOT_DIFFICULTIES[i] === botDifficulty;
            ctx.font = `${selected ? 900 : 400} ${fontSize * (selected ? 1.0 : 0.85)}px Inter`;
            ctx.fillStyle = selected ? '#f64' : 'rgba(255, 255, 255, 0.25)';
            ctx.fillText(BOT_DIFFICULTIES[i].substring(0, 4), x, botY);
            if (selected) {
                ctx.fillStyle = '#f64';
                ctx.fillRect(x - botSpacing * 0.3, botY + 6, botSpacing * 0.6, 3);
            }
        }
    }

    // Tier selector
    const tierLabelY = vsMode === 'bot' ? H * 0.52 : H * 0.40;
    const tierY = tierLabelY + fontSize * 1.5;

    ctx.font = `400 ${fontSize * 0.8}px Inter`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.fillText('GAME TIER', W / 2, tierLabelY);

    const tierSpacing = fontSize * 3;
    const totalWidth = TIERS.length * tierSpacing;
    const startX = (W - totalWidth) / 2 + tierSpacing / 2;

    for (let i = 0; i < TIERS.length; i++) {
        const x = startX + i * tierSpacing;
        const selected = TIERS[i] === selectedTier;

        ctx.font = `${selected ? 900 : 400} ${fontSize * (selected ? 1.0 : 0.85)}px Inter`;
        ctx.fillStyle = selected ? '#fff' : 'rgba(255, 255, 255, 0.25)';
        ctx.fillText(TIERS[i].substring(0, 4), x, tierY);

        if (selected) {
            ctx.fillStyle = '#4af';
            ctx.fillRect(x - tierSpacing * 0.3, tierY + 6, tierSpacing * 0.6, 3);
        }
    }

    // Start prompt
    const startY = H * 0.78;
    ctx.font = `700 ${fontSize * 1.5}px Inter`;
    ctx.fillStyle = '#fff';
    ctx.fillText('TAP TO START', W / 2, startY);

    ctx.font = `400 ${fontSize * 0.8}px Inter`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
    if (vsMode === 'bot') {
        ctx.fillText('You play the left side', W / 2, startY + fontSize * 2);
    } else {
        ctx.fillText('Left = P1    Right = P2', W / 2, startY + fontSize * 2);
    }

    // Back to solo link
    ctx.font = `300 ${fontSize * 0.8}px Inter`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.fillText('\u2190 Solo Mode', W / 2, H - fontSize * 1.5);
}

function drawGameOver() {
    // Dim the boards
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(0, 0, W, H);

    const fontSize = Math.max(16, W * 0.03);

    ctx.font = `900 ${fontSize * 3}px Inter`;
    const winLabel = winner === 'P1' ? 'YOU WIN' : (vsMode === 'bot' ? 'BOT WINS' : 'P2 WINS');
    ctx.fillStyle = winner === 'P1' ? stateA.color : stateB.color;
    ctx.textAlign = 'center';
    ctx.fillText(winLabel, W / 2, H * 0.35);

    // Stats
    ctx.font = `400 ${fontSize}px Inter`;
    ctx.fillStyle = '#fff';
    ctx.fillText(
        `P1: ${gameA.score.toLocaleString()} pts | P2: ${gameB.score.toLocaleString()} pts`,
        W / 2, H * 0.45
    );

    const timeS = (Math.min(gameA.time, gameB.time) / 1000).toFixed(1);
    ctx.fillText(`Duration: ${timeS}s`, W / 2, H * 0.52);

    const gA = stateA.garbageQueue;
    const gB = stateB.garbageQueue;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.font = `400 ${fontSize * 0.8}px Inter`;
    ctx.fillText(
        `Garbage: P1 sent ${gB.totalReceived + gB.totalOffset} | P2 sent ${gA.totalReceived + gA.totalOffset}`,
        W / 2, H * 0.58
    );
    const totalGarbage = gA.totalSent + gB.totalSent;
    const totalOffset = gA.totalOffset + gB.totalOffset;
    ctx.fillText(
        `Offset rate: ${totalGarbage > 0 ? (totalOffset / totalGarbage * 100).toFixed(0) : 0}%`,
        W / 2, H * 0.63
    );

    ctx.font = `700 ${fontSize * 1.2}px Inter`;
    ctx.fillStyle = '#fff';
    ctx.fillText('TAP TO REMATCH', W / 2, H * 0.78);

    ctx.font = `300 ${fontSize * 0.8}px Inter`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fillText('or tap here for menu', W / 2, H * 0.85);
}

function draw() {
    if (pvpState === 'menu') {
        drawMenu();
        return;
    }

    // Clear
    ctx.fillStyle = '#04040f';
    ctx.fillRect(0, 0, W, H);

    // Draw both players
    drawPlayer(gameA, stateA, 0);
    drawPlayer(gameB, stateB, playerW + PVP_CONFIG.dividerWidth);
    drawDivider();

    if (pvpState === 'gameover') {
        drawGameOver();
    }
}

// =========================================================================
// INPUT
// =========================================================================

function handleTap(x, y) {
    if (pvpState === 'menu') {
        const fontSize = Math.max(14, Math.min(W, H) * 0.028);

        // Mode selector
        const modeY = H * 0.28;
        if (Math.abs(y - modeY) < fontSize * 1.5) {
            const modeSpacing = fontSize * 5;
            const modes = ['bot', '2p'];
            for (let i = 0; i < modes.length; i++) {
                const mx = W / 2 + (i - 0.5) * modeSpacing;
                if (Math.abs(x - mx) < modeSpacing * 0.4) {
                    vsMode = modes[i];
                    return;
                }
            }
        }

        // Bot difficulty selector (only in bot mode)
        if (vsMode === 'bot') {
            const botY = H * 0.40;
            if (Math.abs(y - botY) < fontSize * 1.5) {
                const botSpacing = fontSize * 3;
                const botTotalW = BOT_DIFFICULTIES.length * botSpacing;
                const botStartX = (W - botTotalW) / 2 + botSpacing / 2;
                for (let i = 0; i < BOT_DIFFICULTIES.length; i++) {
                    const bx = botStartX + i * botSpacing;
                    if (Math.abs(x - bx) < botSpacing * 0.5) {
                        botDifficulty = BOT_DIFFICULTIES[i];
                        return;
                    }
                }
            }
        }

        // Tier selector
        const tierLabelY = vsMode === 'bot' ? H * 0.52 : H * 0.40;
        const tierY = tierLabelY + fontSize * 1.5;
        const tierSpacing = fontSize * 3;
        const totalWidth = TIERS.length * tierSpacing;
        const startX = (W - totalWidth) / 2 + tierSpacing / 2;

        if (Math.abs(y - tierY) < fontSize * 1.5) {
            for (let i = 0; i < TIERS.length; i++) {
                const tx = startX + i * tierSpacing;
                if (Math.abs(x - tx) < tierSpacing * 0.5) {
                    selectedTier = TIERS[i];
                    return;
                }
            }
        }

        // Back to solo link (bottom of menu)
        if (y > H - fontSize * 3) {
            window.location.href = 'index.html';
            return;
        }

        // Start match on tap below selectors
        if (y > H * 0.65) {
            startMatch();
        }
        return;
    }

    if (pvpState === 'gameover') {
        if (y > H * 0.82) {
            pvpState = 'menu';
        } else {
            startMatch();
        }
        return;
    }

    if (pvpState === 'playing') {
        if (x < playerW) {
            // Player 1 tap (always human)
            if (gameA.canTap()) {
                gameA.tap(x, y);
            }
        } else if (x > playerW + PVP_CONFIG.dividerWidth && vsMode === '2p') {
            // Player 2 tap — only in 2P local mode
            const localX = x - playerW - PVP_CONFIG.dividerWidth;
            if (gameB.canTap()) {
                gameB.tap(localX, y);
            }
        }
    }
}

canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    handleTap(e.clientX, e.clientY);
});

// =========================================================================
// MAIN LOOP
// =========================================================================

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

window.addEventListener('resize', resize);
resize();
requestAnimationFrame(loop);

</script>
</body>
</html>
